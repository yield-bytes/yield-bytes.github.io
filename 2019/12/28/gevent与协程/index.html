<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.gitee.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1、 yield 实现协程1.1 yield 同步执行1234567891011121314151617181920212223import timedef consumer():    send_msg&#x3D;&amp;#x27;&amp;#x27;    while 1:        # 3、consumer通过yield拿到producer发来的消息，又通过yield把结果send_msg返回给producer">
<meta property="og:type" content="article">
<meta property="og:title" content="gevent与协程">
<meta property="og:url" content="https://yield-bytes.gitee.io/blog/2019/12/28/gevent%E4%B8%8E%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="1、 yield 实现协程1.1 yield 同步执行1234567891011121314151617181920212223import timedef consumer():    send_msg&#x3D;&amp;#x27;&amp;#x27;    while 1:        # 3、consumer通过yield拿到producer发来的消息，又通过yield把结果send_msg返回给producer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191228112520473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2019-12-28T06:42:52.000Z">
<meta property="article:modified_time" content="2020-02-03T07:01:40.000Z">
<meta property="article:tag" content="gevent">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20191228112520473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="https://yield-bytes.gitee.io/blog/2019/12/28/gevent%E4%B8%8E%E5%8D%8F%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>gevent与协程 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享与沉淀</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.gitee.io/blog/2019/12/28/gevent%E4%B8%8E%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个非常专注技术总结与分享的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gevent与协程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 14:42:52" itemprop="dateCreated datePublished" datetime="2019-12-28T14:42:52+08:00">2019-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 15:01:40" itemprop="dateModified" datetime="2020-02-03T15:01:40+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="1、-yield-实现协程"><a href="#1、-yield-实现协程" class="headerlink" title="1、 yield 实现协程"></a>1、 yield 实现协程</h4><h5 id="1-1-yield-同步执行"><a href="#1-1-yield-同步执行" class="headerlink" title="1.1 yield 同步执行"></a>1.1 yield 同步执行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    send_msg=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 3、consumer通过yield拿到producer发来的消息，又通过yield把结果send_msg返回给producer</span></span><br><span class="line">        output=<span class="keyword">yield</span> send_msg</span><br><span class="line">        print(<span class="string">&#x27;[consumer] consuming &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(output))</span><br><span class="line">        send_msg=<span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">consumer_obj,num</span>):</span></span><br><span class="line">    <span class="comment"># 1、启动consumer()生成器</span></span><br><span class="line">    <span class="built_in">next</span>(consumer_obj)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;[producer] producing &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2、通过send()切换到consumer()执行</span></span><br><span class="line">        receive_msg=consumer_obj.send(i)</span><br><span class="line">        print(<span class="string">&#x27;[producer] received a message &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(receive_msg))</span><br><span class="line">    consumer_obj.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c=consumer()</span><br><span class="line">    producer(c,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[producer] producing <span class="number">1</span></span><br><span class="line">[consumer] consuming <span class="number">1</span></span><br><span class="line">[producer] received a message ok</span><br><span class="line">[producer] producing <span class="number">2</span></span><br><span class="line">[consumer] consuming <span class="number">2</span></span><br><span class="line">[producer] received a message ok</span><br><span class="line">[producer] producing <span class="number">3</span></span><br><span class="line">[consumer] consuming <span class="number">3</span></span><br><span class="line">[producer] received a message ok</span><br><span class="line">[producer] producing <span class="number">4</span></span><br><span class="line">[consumer] consuming <span class="number">4</span></span><br><span class="line">[producer] received a message ok</span><br><span class="line">[producer] producing <span class="number">5</span></span><br><span class="line">[consumer] consuming <span class="number">5</span></span><br><span class="line">[producer] received a message ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个过程无锁，由一个线程执行，producer和consumer协作完成任务，但是以上无法实现并发，生产1个，消费1个，也即1个生产者对应1个消费者</p>
<h5 id="1-2-启动多个yield模拟consumer并发"><a href="#1-2-启动多个yield模拟consumer并发" class="headerlink" title="1.2 启动多个yield模拟consumer并发"></a>1.2 启动多个yield模拟consumer并发</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span>():</span></span><br><span class="line">    d=datetime.datetime.now()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s:%s:%s&#x27;</span>%(d.hour,d.minute,d.second)        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">consumer_index</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;consumer-&#123;&#125; started at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(consumer_index,get_time()))</span><br><span class="line">    send_msg=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 消费者保持监听producer的发来的信息</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 3、consumer通过yield拿到producer发来的消息，又通过yield把结果send_msg返回给producer</span></span><br><span class="line">        output=<span class="keyword">yield</span> send_msg</span><br><span class="line">        print(<span class="string">&#x27;[consumer-&#123;&#125;] consuming &#123;&#125; at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(consumer_index,output,get_time()))</span><br><span class="line">        time.sleep(<span class="number">1</span>) <span class="comment"># 模拟IO耗时操作</span></span><br><span class="line">        send_msg=<span class="string">&#x27;ack&#x27;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">consumer_obj,consumer_num,count</span>):</span></span><br><span class="line">    <span class="comment"># 1、启动n个consumer()生成器，相当于用协程方式模拟并发</span></span><br><span class="line">    consumers=[consumer_obj(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(consumer_num) ]</span><br><span class="line">    <span class="keyword">for</span> each_cons <span class="keyword">in</span> consumers:</span><br><span class="line">        <span class="built_in">next</span>(each_cons)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        print(<span class="string">&#x27;[producer] producing &#123;&#125; at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i,get_time()))</span><br><span class="line">        <span class="comment"># 2、对每个consumer_obj使用send()切换到consumer()执行</span></span><br><span class="line">        <span class="keyword">for</span> index,each_cons <span class="keyword">in</span> <span class="built_in">enumerate</span>(consumers):</span><br><span class="line">            receive_msg=each_cons.send(i)</span><br><span class="line">            print(<span class="string">&#x27;[producer] received &#123;&#125; from consumer-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(receive_msg,index,get_time()))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> each_cons <span class="keyword">in</span> consumers:</span><br><span class="line">        each_cons.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    producer(consumer,<span class="number">5</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>1个producer，5个consumer</p>
<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">consumer-0 started at 21:12:45</span><br><span class="line">consumer-1 started at 21:12:45</span><br><span class="line">consumer-2 started at 21:12:45</span><br><span class="line">consumer-3 started at 21:12:45</span><br><span class="line">consumer-4 started at 21:12:45</span><br><span class="line">[producer] producing 0 at 21:12:45</span><br><span class="line">[consumer-0] consuming 0 at 21:12:45</span><br><span class="line">[producer] received ack from consumer-0</span><br><span class="line">[consumer-1] consuming 0 at 21:12:46</span><br><span class="line">[producer] received ack from consumer-1</span><br><span class="line">[consumer-2] consuming 0 at 21:12:47</span><br><span class="line">[producer] received ack from consumer-2</span><br><span class="line">[consumer-3] consuming 0 at 21:12:48</span><br><span class="line">[producer] received ack from consumer-3</span><br><span class="line">[consumer-4] consuming 0 at 21:12:49</span><br><span class="line">[producer] received ack from consumer-4</span><br><span class="line">[producer] producing 1 at 21:12:50</span><br><span class="line">[consumer-0] consuming 1 at 21:12:50</span><br><span class="line">[producer] received ack from consumer-0</span><br><span class="line">[consumer-1] consuming 1 at 21:12:51</span><br><span class="line">[producer] received ack from consumer-1</span><br><span class="line">[consumer-2] consuming 1 at 21:12:52</span><br><span class="line">[producer] received ack from consumer-2</span><br><span class="line">[consumer-3] consuming 1 at 21:12:53</span><br><span class="line">[producer] received ack from consumer-3</span><br><span class="line">[consumer-4] consuming 1 at 21:12:54</span><br><span class="line">[producer] received ack from consumer-4</span><br></pre></td></tr></table></figure>
<p>以上运行过程确实是协程运行，但yield无法自动切换协程，上面的运行过程打印出的实际可以发现代码同步执行：<br>5个consumer同时启动，当producer生产1个数据，consumer-0消费数据，而consumer内部有IO耗时操作（time.sleep(1)模拟IO），此时代码逻辑没有把线程当前控制权从consumer-0自动切换到consumer-1，consumer-1等待前面1秒后，才能接着干活。</p>
<h4 id="2-、greenlet实现的协程"><a href="#2-、greenlet实现的协程" class="headerlink" title="2 、greenlet实现的协程"></a>2 、greenlet实现的协程</h4><h5 id="2-1-简单gevent协程例子"><a href="#2-1-简单gevent协程例子" class="headerlink" title="2.1 简单gevent协程例子"></a>2.1 简单gevent协程例子</h5><p>&#8195;&#8195;greenlet是一个用C实现的协程模块，相比于上面使用python的yield实现协程，greenlet可以无需将函数声明为generator的前提下，用手动方式在任意函数之间切换。但在实际使用，往往不会直接使用greenlet，因为它遇到有IO地方是不会自动切换，而Gevent库可以实现这个需求，gevent是对greenlet的封装，实现自动切换，大体的设计逻辑如下：<br>&#8195;&#8195;当一个greenlet（你可以认为这个greenlet是一个协程对象，类比于线程对象thread）遇到IO操作时，比如访问读取文件或者网络socket连接，它会自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换原来位置继续执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent,datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;f1 started at&#x27;</span>,get_time())</span><br><span class="line">    <span class="comment"># gevent模拟IO耗时操作，并且gevent会在此保留现场后自动切换到其它函数</span></span><br><span class="line">    gevent.sleep(<span class="number">4</span>) </span><br><span class="line">    print(<span class="string">&#x27;f1 done at&#x27;</span>,get_time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;f2 started at&#x27;</span>,get_time())</span><br><span class="line">    gevent.sleep(<span class="number">2</span>) </span><br><span class="line">    print(<span class="string">&#x27;f2 done at&#x27;</span>,get_time())</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;f3 started at&#x27;</span>,get_time())</span><br><span class="line">    gevent.sleep(<span class="number">3</span>) </span><br><span class="line">    print(<span class="string">&#x27;f3 done at&#x27;</span>,get_time())</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gevent.joinall([gevent.spawn(f1),gevent.spawn(f2),gevent.spawn(f3)])</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1 started at  09:21:17.066251</span><br><span class="line">f2 started at  09:21:17.066355</span><br><span class="line">f3 started at  09:21:17.066388</span><br><span class="line">f2 done at  09:21:19.067741</span><br><span class="line">f3 done at  09:21:20.067747</span><br><span class="line">f1 done at  09:21:21.067812</span><br></pre></td></tr></table></figure>

<p>可以看到，gevent在同一时刻运行3个函数，并且，f2先完成，接着f3完成，最后IO耗时最长的f1完成，三个函数共同完成耗时为4秒，说明三个函数并发执行了。如果是同步运行，整个过程耗时为4+2+3=9秒耗时，协程优势凸显。</p>
<h5 id="2-2-gevent-高并发测试"><a href="#2-2-gevent-高并发测试" class="headerlink" title="2.2 gevent 高并发测试"></a>2.2 gevent 高并发测试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">task_index</span>):</span></span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;task-&#123;&#125; done at &#123;&#125; &#x27;</span>.<span class="built_in">format</span>(task_index,datetime.datetime.now()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">syn</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        task(i)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    syn(<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同步情况下，耗时4秒</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task-0 done at  09:41:14.075001 </span><br><span class="line">task-1 done at  09:41:15.076049 </span><br><span class="line">task-2 done at  09:41:16.077101 </span><br><span class="line">task-3 done at  09:41:17.078055 </span><br></pre></td></tr></table></figure>
<p>gevent实现的协程异步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asyn</span>(<span class="params">n</span>):</span></span><br><span class="line">    coroutines=[gevent.spawn(task,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    gevent.joinall(coroutines)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyn(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>原本需要4秒的执行流，现在只需1秒完成所有任务。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task-0 done at  09:44:30.535495 </span><br><span class="line">task-1 done at  09:44:30.535749 </span><br><span class="line">task-2 done at  09:44:30.535801 </span><br><span class="line">task-3 done at  09:44:30.535833 </span><br></pre></td></tr></table></figure>

<p>尝试启动10万个任务，用line_profiler 查看函数中耗时操作（line_profiler 目前不兼容3.7，最好用pyenv 切换到3.6进行测试）。只需要在asyn函数上加@profile装饰器即可</p>
<p>创建asyn.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent,datetime,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">task_index</span>):</span></span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#print(&#x27;task-&#123;&#125; done at &#123;&#125; &#x27;.format(task_index,datetime.datetime.now()))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asyn</span>(<span class="params">n</span>):</span></span><br><span class="line">    threads=[gevent.spawn(task,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    gevent.joinall(threads)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start=time.time()</span><br><span class="line">    asyn(<span class="number">100000</span>)</span><br><span class="line">    cost=time.time()-start</span><br><span class="line">    print(cost)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(spk) [root@nn spv]# kernprof -l -v asyn.py </span><br><span class="line">5.805598974227905</span><br><span class="line">Wrote profile results to asyn.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 5.73735 s</span><br><span class="line">File: asyn.py</span><br><span class="line">Function: asyn at line 6</span><br><span class="line"></span><br><span class="line">Line #      Hits         Time  Per Hit   % Time  Line Contents</span><br><span class="line">==============================================================</span><br><span class="line">     6                                           @profile</span><br><span class="line">     7                                           def asyn(n):</span><br><span class="line">     8         1    1204525.0 1204525.0     21.0      threads=[gevent.spawn(task,i) for i in range(n)]</span><br><span class="line">     9         1    4532823.0 4532823.0     79.0      gevent.joinall(threads)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非常清晰看到，理论上：10万个任务使用协程实现并发运行，总耗时1秒，但实际上，因为需要创建大量greenlet对象，列表创建10万个项耗时1.2秒，gevent joinall 10万个greenlet对象耗时4.5秒，所以整个程序完成总耗时实际为5.7秒左右。</p>
<p>使用memory_profiler库查看asyn.py内存使用情况，使用也简单与line_profiler相似，使用@profile装饰器来标识需要追踪的函数即可。使用协程，10万个对象消耗300多M，鉴于其并发效率高，而且所有的执行都只在一个线程实现 了，因此内存消耗可接受。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(spk) [root@nn spv]<span class="comment"># python -m memory_profiler asyn.py</span></span><br><span class="line">Filename: asyn.py</span><br><span class="line"></span><br><span class="line">Line <span class="comment">#    Mem usage    Increment   Line Contents</span></span><br><span class="line">================================================</span><br><span class="line">     <span class="number">6</span>   <span class="number">36.137</span> MiB   <span class="number">36.137</span> MiB   @profile</span><br><span class="line">     <span class="number">7</span>                             <span class="function"><span class="keyword">def</span> <span class="title">asyn</span>(<span class="params">n</span>):</span></span><br><span class="line">     <span class="number">8</span>  <span class="number">229.531</span> MiB    <span class="number">0.773</span> MiB       threads=[gevent.spawn(task,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     <span class="number">9</span>  <span class="number">366.270</span> MiB  <span class="number">136.738</span> MiB       gevent.joinall(threads)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：内存的单位MiB，表示的mebibyte，</p>
<p>MB/s的意思是每秒中传输10^6 byte的数据，以10为底数的指数</p>
<p>MiB/s的意思是每秒中传输2^20 byte的数据，以2为底数的指数</p>
<p>1 MiB =0.9765625 MB</p>
<p>创建100万个task，再看看kernprof -l -v asyn.py ，内存方面使用top可以直观看到asyn.py 占用了2G*0.816=1632 MiB</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KiB Swap:  2097148 total,  1039272 free,  1057876 used.    14348 avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                </span><br><span class="line">    30 root      20   0       0      0      0 S 45.1  0.0   0:47.13 kswapd0                                </span><br><span class="line"> 29380 root      20   0 2319772   1.4g     56 R 42.8 81.6   1:04.53 kernprof</span><br></pre></td></tr></table></figure>

<p>将协程并发数设为100万，总共耗时为534秒，时间略长，使用gevent在单台服务器上，并发数不要设太离谱，1000个并发足以应付普通项目的需求，例如爬虫，例如做服务端接收客户端发来的socket流数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(spk) [root@nn spv]<span class="comment"># kernprof -l -v asyn.py           </span></span><br><span class="line"><span class="number">534.7752296924591</span></span><br><span class="line">Wrote profile results to asyn.py.lprof</span><br><span class="line">Timer unit: <span class="number">1e-06</span> s</span><br><span class="line"></span><br><span class="line">Total time: <span class="number">532.165</span> s</span><br><span class="line">File: asyn.py</span><br><span class="line">Function: asyn at line <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Line <span class="comment">#      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line">     <span class="number">6</span>                                           @profile</span><br><span class="line">     <span class="number">7</span>                                           <span class="function"><span class="keyword">def</span> <span class="title">asyn</span>(<span class="params">n</span>):</span></span><br><span class="line">     <span class="number">8</span>         <span class="number">1</span>   <span class="number">82927089.0</span> <span class="number">82927089.0</span>     <span class="number">15.6</span>      threads=[gevent.spawn(task,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     <span class="number">9</span>         <span class="number">1</span>  <span class="number">449238172.0</span> <span class="number">449238172.0</span>     <span class="number">84.4</span>      gevent.joinall(threads)</span><br></pre></td></tr></table></figure>

<h5 id="2-3-理解gevent的monkey-patch-all"><a href="#2-3-理解gevent的monkey-patch-all" class="headerlink" title="2.3  理解gevent的monkey.patch_all()"></a>2.3  理解gevent的monkey.patch_all()</h5><p>&#8195;&#8195;在接下有关gevent的实际项目中，py程序都会引用monkey.patch_all()这个方法，它的作用是用非阻塞模块替换python自带的阻塞模块，这就是所谓”猴子补丁”，原理是运行时用非阻塞的对象属性替换对应阻塞对象的属性，或者用自己实现的同名非阻塞模块，替换对应的阻塞模块。<br>&#8195;&#8195;注意：这里说的模块就是“有完整功能的一个.py文件“或者”由多个py文件组成的一个完整功能的模块“<br>&#8195;&#8195;例如下面要实现这么一个需求：server.py运行时，将thread.py模块的synfoo函数替换为自定义的mythread.py模块里面asynfoo函数</p>
<p>thread.py 模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;builtin method synfoo of thread.py&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>自定义的mythread.py模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;builtin method asynfoo of mythread.py&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>server.py程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> thread</span><br><span class="line"><span class="comment"># 在本程序的modules字典里面删除原thread模块</span></span><br><span class="line"><span class="keyword">del</span> sys.modules[<span class="string">&#x27;thread&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用异步的模块替换当前thread模块</span></span><br><span class="line">sys.modules[<span class="string">&#x27;thread&#x27;</span>] = <span class="built_in">__import__</span>(<span class="string">&#x27;mythread&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载thread</span></span><br><span class="line"><span class="keyword">import</span> thread</span><br><span class="line">thread.foo() <span class="comment">#这里的thread已经是mythread模块</span></span><br><span class="line">print(thread)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># server.py运行时已经成功将内建同步模块替换为异步的模块</span><br><span class="line">builtin method asynfoo of mythread.py</span><br><span class="line"># thread的指向自定义模块mythread</span><br><span class="line">&lt;module &#x27;mythread&#x27; from &#x27;/opt/spv/mythread.py&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>以上就是monkey.patch_all()大致逻辑，gevent可以把python内建的多个模块在程序运行时替换为它写的异步模块，默认是把内建的socket、thread、queue等模块替换为非阻塞同名模块</p>
<p>（site-packages/gevent/monkey.py）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_all</span>(<span class="params">socket=<span class="literal">True</span>, dns=<span class="literal">True</span>, time=<span class="literal">True</span>, select=<span class="literal">True</span>, thread=<span class="literal">True</span>, os=<span class="literal">True</span>, ssl=<span class="literal">True</span>, httplib=<span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params">              subprocess=<span class="literal">True</span>, sys=<span class="literal">False</span>, aggressive=<span class="literal">True</span>, Event=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              builtins=<span class="literal">True</span>, signal=<span class="literal">True</span></span>):</span></span><br><span class="line">    _warnings, first_time = _check_repatching(**<span class="built_in">locals</span>())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _warnings <span class="keyword">and</span> <span class="keyword">not</span> first_time:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> os:</span><br><span class="line">        patch_os()</span><br><span class="line">    <span class="keyword">if</span> time:</span><br><span class="line">        patch_time()</span><br><span class="line">    <span class="keyword">if</span> thread:</span><br><span class="line">        patch_thread(Event=Event, _warnings=_warnings)</span><br><span class="line">    <span class="comment"># sys must be patched after thread. in other cases threading._shutdown will be</span></span><br><span class="line">    <span class="comment"># initiated to _MainThread with real thread ident</span></span><br><span class="line">    <span class="keyword">if</span> sys:</span><br><span class="line">        patch_sys()</span><br><span class="line">    <span class="keyword">if</span> socket:</span><br><span class="line">        patch_socket(dns=dns, aggressive=aggressive)</span><br><span class="line">    <span class="keyword">if</span> select:</span><br><span class="line">        patch_select(aggressive=aggressive)</span><br><span class="line">    <span class="keyword">if</span> ssl:</span><br><span class="line">        patch_ssl()</span><br><span class="line">    <span class="keyword">if</span> httplib:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;gevent.httplib is no longer provided, httplib must be False&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> subprocess:</span><br><span class="line">        patch_subprocess()</span><br><span class="line">    <span class="keyword">if</span> builtins:</span><br><span class="line">        patch_builtins()</span><br></pre></td></tr></table></figure>

<p>如果不想gevent对某个内建模块覆盖为非阻塞，可以将该模块设为False：monkey.patch_all(thread=False)<br>或者在monkey.patch_all(thread=False) 语句后面追加import threading<br>目的是内建同步模块再次覆盖前面的gevent异步模块，例如server.py文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all(thread=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 或者 import threading</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">syn</span>():</span></span><br><span class="line">	t=threading.thread(target=task,args=())</span><br><span class="line">	t.start()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">	gevent.joinall...</span><br></pre></td></tr></table></figure>

<p>由此可知，gevent的patch_all针对模块的覆盖是有顺序的，因为当使用gevent时，import的模块顺序很重要，内建模块在patch_all前面或者在patch_all后面，对应是同步还是异步模块导入。</p>
<h6 id="2-2-1-locals-方法"><a href="#2-2-1-locals-方法" class="headerlink" title="2.2.1 locals()方法"></a>2.2.1 locals()方法</h6><p>&#8195;&#8195;locals()返回一个字典，它可以获取当前模块所有的局部变量以及当前模块引入的其他模块，例如myFoo.py模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">local_module_dict=<span class="built_in">locals</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">print(local_module_dict[<span class="string">&#x27;threading&#x27;</span>])</span><br><span class="line">print(local_module_dict[<span class="string">&#x27;socket&#x27;</span>])</span><br><span class="line">输出</span><br><span class="line"><span class="comment"># &lt;module &#x27;threading&#x27; from &#x27;/root/.pyenv/versions/3.7.5/lib/python3.7/threading.py&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;module &#x27;socket&#x27; from &#x27;/root/.pyenv/versions/3.7.5/lib/python3.7/socket.py&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gevent通过locals()获取这些模块后，将需要替换的模块都替换gevent自己实现的非阻塞模块</p>
<h6 id="2-2-2-gevent-替换非阻塞的模块的思路"><a href="#2-2-2-gevent-替换非阻塞的模块的思路" class="headerlink" title="2.2.2 gevent 替换非阻塞的模块的思路"></a>2.2.2 gevent 替换非阻塞的模块的思路</h6><p>&#8195;&#8195;在前面的例子中，使用gevent.sleep()可以让协程自动切换实现异步方式执行，如果使用内建的time.sleep()，则变成同步执行，下面看看gevent如何使用patch_time()方法为sleep打补丁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_time</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Replace :func:`time.sleep` with :func:`gevent.sleep`.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> gevent.hub <span class="keyword">import</span> sleep</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="comment"># 用gevent.hub.sleep方法替换内建的sleep方法</span></span><br><span class="line">    patch_item(time, <span class="string">&#x27;sleep&#x27;</span>, sleep)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_item</span>(<span class="params">module, attr, newitem</span>):</span></span><br><span class="line">    olditem = <span class="built_in">getattr</span>(module, attr, _NONE)</span><br><span class="line">    <span class="keyword">if</span> olditem <span class="keyword">is</span> <span class="keyword">not</span> _NONE:</span><br><span class="line">        saved.setdefault(module.__name__, &#123;&#125;).setdefault(attr, olditem)</span><br><span class="line">    <span class="built_in">setattr</span>(module, attr, newitem)</span><br></pre></td></tr></table></figure>

<p>实现原理跟2.2提到monke.patch_all()一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.hub <span class="keyword">import</span> sleep <span class="comment"># 先导入gevent的sleep</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment"># 再导入内建time模块</span></span><br><span class="line">print(<span class="built_in">getattr</span>(time,<span class="string">&#x27;sleep&#x27;</span>)) <span class="comment"># 获取原内建sleep</span></span><br><span class="line"><span class="comment"># &lt;function time.sleep&gt;</span></span><br><span class="line"><span class="built_in">setattr</span>(time,<span class="string">&#x27;sleep&#x27;</span>,sleep) <span class="comment"># 将gevent的异步sleep方法替换原sleep方法</span></span><br><span class="line">print(<span class="built_in">getattr</span>(time,<span class="string">&#x27;sleep&#x27;</span>)) <span class="comment"># 打印运行是sleep方法看看是内建的还是gevent实现的</span></span><br><span class="line"><span class="comment"># &lt;function gevent.hub.sleep(seconds=0, ref=True)&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于模块的导入，则需要使用<code>getattr自省模式创建一个对象，然后通过__import__引入</code></p>
<p>以gevent替换os为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_os</span>():</span></span><br><span class="line">    patch_module(<span class="string">&#x27;os&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用gevent的os替换内建的os模块，这里的name就是&#x27;os&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_module</span>(<span class="params">name, items=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="comment"># 通过__import__方法导入用gevent的os</span></span><br><span class="line">    gevent_module = <span class="built_in">getattr</span>(<span class="built_in">__import__</span>(<span class="string">&#x27;gevent.&#x27;</span> + name), name)</span><br><span class="line">    module_name = <span class="built_in">getattr</span>(gevent_module, <span class="string">&#x27;__target__&#x27;</span>, name)</span><br><span class="line">    module = <span class="built_in">__import__</span>(module_name)</span><br><span class="line">    <span class="keyword">if</span> items <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    	<span class="comment"># 获取gevent_module里面跟os相关的方法</span></span><br><span class="line">        items = <span class="built_in">getattr</span>(gevent_module, <span class="string">&#x27;__implements__&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> items <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;%r does not have __implements__&#x27;</span> % gevent_module)</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> items:</span><br><span class="line">    	<span class="comment"># 用 gevent自己实现的os里面方法替换内建os指定方法</span></span><br><span class="line">        patch_item(module, attr, <span class="built_in">getattr</span>(gevent_module, attr))</span><br><span class="line">    <span class="keyword">return</span> module</span><br></pre></td></tr></table></figure>


<p>相信到了这里，已经可以理解 monkey.patch_all()为何要在gevent的程序头部引入，常见“模板”如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure>

<p>很多文章在讨论gevent的协程时，基本都是一句话“这是打补丁，将阻塞模块替换为非阻塞模块”简单带过，对于大部分人来说，这种说明一般会感到疑惑。</p>
<h4 id="3、gevent-examples"><a href="#3、gevent-examples" class="headerlink" title="3、gevent examples"></a>3、gevent examples</h4><p>&#8195;&#8195;本章主要结合一些场景给出gevent用法，参考了gevent官网给出的examples：<a target="_blank" rel="noopener" href="http://www.gevent.org/examples/index.html">地址</a></p>
<h5 id="3-1-使用协程高并发爬网页"><a href="#3-1-使用协程高并发爬网页" class="headerlink" title="3.1 使用协程高并发爬网页"></a>3.1 使用协程高并发爬网页</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> random,datetime</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># patches stdlib (including socket and ssl modules) to cooperate with other greenlets</span></span><br><span class="line"><span class="comment"># 将标准lib打补丁，例如下面的https请求需要用到ssl模块，将该内建的ssl模块替换为gevent的ssl</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里给出的https协议来说明gevent可进行SSL的相关任务处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span> (<span class="params">workers=<span class="number">1000</span></span>):</span></span><br><span class="line">    start=time.time()</span><br><span class="line">    url_pool = [</span><br><span class="line">        <span class="string">&#x27;https://www.baidu.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.apple.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.qq.com/&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    urls=[ random.choice(url_pool) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(workers)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_head</span>(<span class="params">url</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Starting &#123;&#125; at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url,datetime.datetime.now()))</span><br><span class="line">        data = requests.get(url).text <span class="comment"># gevent会在发生IO的位置实现协程自动切换</span></span><br><span class="line">        <span class="comment">#print(&#x27;%s: %s bytes: %r&#x27; % (url, len(data), data[:2]))</span></span><br><span class="line">    jobs = [gevent.spawn(print_head, _url) <span class="keyword">for</span> _url <span class="keyword">in</span> urls]</span><br><span class="line">    gevent.wait(jobs) <span class="comment"># 阻塞主线程，让所有协程得以持续运行</span></span><br><span class="line">    cost=time.time()-start</span><br><span class="line">    print(<span class="string">&#x27;cost:&#x27;</span>,cost)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>以上1000个请求，只需运行一个线程，非常轻量且“低功耗”，而多线程方式，则需创建1000个线程，这就是协程的优势。</p>
<h5 id="3-2-gevent实现的socket高并发"><a href="#3-2-gevent实现的socket高并发" class="headerlink" title="3.2 gevent实现的socket高并发"></a>3.2 gevent实现的socket高并发</h5><p><strong>server.py端逻辑</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,datetime</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeErr</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8090</span>,conns=<span class="number">100</span></span>):</span></span><br><span class="line">        self._s=socket.socket()</span><br><span class="line">        self._s.bind((host,port))</span><br><span class="line">        self._s.listen(conns)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_request</span>(<span class="params">self,conn</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 接收客户端发送的是比特字节，需要decode为str类型</span></span><br><span class="line">            msg=conn.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">&#x27;got the msg:&#123;&#125; at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg,self.recv_time()))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 发送给client需要byte类型</span></span><br><span class="line">            conn.send(<span class="built_in">bytes</span>(msg,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> msg ==<span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">                conn.shutdown(socket.SHUT_RDWR)</span><br><span class="line">                conn.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line"><span class="meta">    @staticmethod            </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv_time</span>():</span></span><br><span class="line">        d=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s:%s:%s&#x27;</span>%(d.hour,d.minute,d.second)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                client_conn,client_ip=self._s.accept()</span><br><span class="line">                <span class="comment"># 创建一个新的Greenlet服务新的请求</span></span><br><span class="line">                g=gevent.spawn(self.parse_request,client_conn)</span><br><span class="line">                print(<span class="string">&#x27;new client connected:&#123;&#125; &#123;&#125; serving...&#x27;</span>.<span class="built_in">format</span>(client_ip,g.name))</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conns=<span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    server=Server(conns=conns)</span><br><span class="line">    server.serve_forever()                   </span><br></pre></td></tr></table></figure>

<p>另外打开2个终端使用 telnet 188.0.0.10 8090</p>
<p>输出：<br>可以看到每个client请求都是由新的greenlet来服务，这个Greenlet就是协程对象<code>&lt;Greenlet at 0x7f7dc87efa70: parse_request(&lt;gevent._socket3.socket object, fd=7, family=2, ty)&gt;</code>，而非多线程对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# python server.py 100</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21042) Greenlet-0 serving...</span><br><span class="line">got the msg:foo</span><br><span class="line"> at 10:8:3</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21044) Greenlet-1 serving...</span><br><span class="line">got the msg:bar</span><br><span class="line"> at 10:8:37</span><br></pre></td></tr></table></figure>
<p>这里需要注意：<br>在parse_request里面关闭client的连接用conn.shutdown(socket.SHUT_WR)<br>shutdown 方法的 how 参数接受如下参数值： </p>
<ul>
<li> SHUT_RD：关闭 socket 的输入部分，程序还可通过该 socket 输出数据。(tcp半开状态)</li>
<li> SHUT_WR： 关闭该 socket 的输出部分，程序还可通过该 socket 读取数据。（(tcp半开)状态）</li>
<li> SHUT_RDWR：全关闭。该 socket 既不能读取数据，也不能写入数据。</li>
</ul>
<p>conn.close():关闭完整tcp连接通道<br>close方法不是立即释放，如果想立即释放，需在close之前使用shutdown方法<br>server.py 使用gevent实现可接受高并发连接，下面给出gevent版的client，高并发socket请求</p>
<p>*<em>client.py端代码**</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,server_ip,port,workers=<span class="number">10</span></span>):</span></span><br><span class="line">        self.server_ip=server_ip</span><br><span class="line">        self.port=port</span><br><span class="line">        self.workers=workers</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod            </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv_time</span>():</span></span><br><span class="line">        d=datetime.datetime.now()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s:%s:%s&#x27;</span>%(d.hour,d.minute,d.second)        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asyn_sock</span>(<span class="params">self,msg</span>):</span></span><br><span class="line">        client=socket.socket()</span><br><span class="line">        client.connect((self.server_ip,self.port))</span><br><span class="line">        bmsg=<span class="built_in">bytes</span>(msg,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        client.sendall(bmsg)</span><br><span class="line">        recv_data=client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;gevent object:&#123;&#125; data:&#123;&#125; at:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(gevent.getcurrent(),recv_data,self.recv_time()))</span><br><span class="line">        client.close()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        threads=[gevent.spawn(self.asyn_sock,<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.workers)]</span><br><span class="line">        gevent.joinall(threads)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    workers=<span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    c=Client(server_ip=<span class="string">&#x27;188.0.0.10&#x27;</span>,port=<span class="number">8090</span>,workers=workers)</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure>

<p>服务器端启动100个连接数，客户端并发10个请求。</p>
<p>服务端打印如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# python server.py 100</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21246) Greenlet-0 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21248) Greenlet-1 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21250) Greenlet-2 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21252) Greenlet-3 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21254) Greenlet-4 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21256) Greenlet-5 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21258) Greenlet-6 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21260) Greenlet-7 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21262) Greenlet-8 serving...</span><br><span class="line">new client connected:(&#x27;188.0.0.10&#x27;, 21264) Greenlet-9 serving...</span><br><span class="line">got the msg:0 at 10:11:5</span><br><span class="line">got the msg:1 at 10:11:5</span><br><span class="line">got the msg:2 at 10:11:5</span><br><span class="line">got the msg:3 at 10:11:5</span><br><span class="line">got the msg:4 at 10:11:5</span><br><span class="line">got the msg:5 at 10:11:5</span><br><span class="line">got the msg:6 at 10:11:5</span><br><span class="line">got the msg:7 at 10:11:5</span><br><span class="line">got the msg:8 at 10:11:5</span><br><span class="line">got the msg:9 at 10:11:5</span><br></pre></td></tr></table></figure>

<p>客户端打印如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# python asyn.py 10</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a85f0: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;9&#x27;)&gt; data:9 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a84d0: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;8&#x27;)&gt; data:8 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a83b0: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;7&#x27;)&gt; data:7 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a8290: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;6&#x27;)&gt; data:6 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a8170: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;5&#x27;)&gt; data:5 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41a9a8050: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;4&#x27;)&gt; data:4 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41b586ef0: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;3&#x27;)&gt; data:3 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41b586b90: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;2&#x27;)&gt; data:2 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41b586cb0: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;1&#x27;)&gt; data:1 at:10:11:5</span><br><span class="line">gevent object:&lt;Greenlet at 0x7ff41b586a70: &lt;bound method Client.asyn_sock of &lt;__main__.Client object at 0x7ff41a9da210&gt;&gt;(&#x27;0&#x27;)&gt; data:0 at:10:11:5</span><br></pre></td></tr></table></figure>

<p>可以看到不管是服务器和客户端，都是由多个greenlet协程对象负责请求或者负责服务。<br>如果server.py端并发数设为10000，client.py并发也设为10000，那么会出现以下情况：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init__</span><br><span class="line">OSError: [Errno 24] Too many open files</span><br><span class="line">During handling of the above exception, another exception occurred:</span><br></pre></td></tr></table></figure>
<p>这里因为centos限制用户级别在打开文件描述符的数量，可查看默认值：限制至多打开1024个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# ulimit -n</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<p>linux 一般会在以下几个文件对系统资源做限制，例如用户级别（此外还有系统级别）的限制： /etc/security/limits.conf，和/etc/security/limits.d/目录，/etc/security/limits.d/里面配置会覆盖/etc/security/limits.conf的配置：</p>
<blockquote>
<p>系统限制用户的资源有：所创建的内核文件的大小、进程数据块的大小、Shell<br>进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell<br>进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
</blockquote>
<p>提升并发性能：临时修改：ulimit -n 100000；永久性修改：root权限下，在/etc/security/limits.conf中添加如下两行，*表示所有用户，重启/或者注销重登陆生效</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 102400</span><br><span class="line">* hard nofile 104800</span><br></pre></td></tr></table></figure>

<p>注意hard limit必须大于soft limit</p>
<p>这里将linux设为ulimit -n 100000，10万个描述符！ python server.py 20000个并发，python client.py 10000并发请求打过去，3秒内完成，而且这是因为程序加入print打印语句影响性能，去掉所有print语句，2万个客户端并发不到2秒内完成，gevent或者说底层Greenlet的并发性能非常强。</p>
<h5 id="3-3-gevent数据库操作"><a href="#3-3-gevent数据库操作" class="headerlink" title="3.3 gevent数据库操作"></a>3.3 gevent数据库操作</h5><p>&#8195;&#8195;这里将给出协程方式、多线程方式连接mysql数据库某实际项目备份表，15个字段，2万多条数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> socket,monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start=time.time()</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        cost=time.time()-start</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; cost:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(func.__name__,cost))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_db</span>(<span class="params">index</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;负责读数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#print(&#x27;start:&#x27;,index)</span></span><br><span class="line">    db = pymysql.connect(host = <span class="string">&#x27;****&#x27;</span>, user = <span class="string">&#x27;****&#x27;</span>, passwd = <span class="string">&#x27;****&#x27;</span>, db= <span class="string">&#x27;****&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    sql=<span class="string">&#x27;select count(1) from `article &#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    nums = cursor.fetchall()</span><br><span class="line">    <span class="comment">#print(&#x27;total itmes:&#x27;,nums)</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="comment">#print(&#x27;end:&#x27;,index)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gevent_read</span>(<span class="params">workers</span>):</span></span><br><span class="line">    <span class="comment"># 创建多个greenlets协程对象</span></span><br><span class="line">    greenlets = [gevent.spawn(read_db,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(workers)]</span><br><span class="line">    gevent.joinall(greenlets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="comment"># 5次测试。这里每次间隔1秒，让客户端连接mysql的connections及时关闭，避免释放不及时导致超过数据库端的允许连接数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        gevent_read(<span class="number">100</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从代码逻辑可以看出，gevent使用协程非常简单，在头部引入相关模块，再使用gevent.spawn创建多个greenlets对象，最后joinall。以下是测试结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# python asyn_mysql.py </span><br><span class="line">gevent_read cost:2.702486276626587</span><br><span class="line">gevent_read cost:2.120276689529419</span><br><span class="line">gevent_read cost:2.1487138271331787</span><br><span class="line">gevent_read cost:2.61714243888855</span><br><span class="line">gevent_read cost:2.1180896759033203</span><br></pre></td></tr></table></figure>

<h5 id="3-4-gevent-多线程"><a href="#3-4-gevent-多线程" class="headerlink" title="3.4 gevent 多线程"></a>3.4 gevent 多线程</h5><p>gevent也有自己线程池，使用的python的thread，两者没区别，如果用了多线程，那么gevent其实就没多大意义了，因为不是协程模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.threadpool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start=time.time()</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        cost=time.time()-start</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; cost:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(func.__name__,cost))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gpool</span>(<span class="params">workers</span>):</span></span><br><span class="line">    pool = ThreadPool(workers)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool.spawn(time.sleep, <span class="number">1</span>)</span><br><span class="line">    gevent.wait()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gpool(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<p>输出3秒，10个任务，线程池只有4个worker，因此需分三轮工作，因为耗时3秒</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nn spv]# python gpool.py </span><br><span class="line">gpool cost:3.006455183029175</span><br></pre></td></tr></table></figure>

<h5 id="3-5-gevent-其他examples"><a href="#3-5-gevent-其他examples" class="headerlink" title="3.5 gevent 其他examples"></a>3.5 gevent 其他examples</h5><p>这里不再一一列出，可以参考gevent github的<a target="_blank" rel="noopener" href="https://github.com/gevent/gevent/tree/master/examples">example目录</a></p>
<p>不过建议看看<strong>geventsendfile.py</strong>和<strong>wsgiserver_ssl.py</strong><br>第一是零拷贝技术的协程，第二个是基于https的协程webserver</p>
<h4 id="4、greenlet-eventlet-gevent的关系"><a href="#4、greenlet-eventlet-gevent的关系" class="headerlink" title="4、greenlet/eventlet/gevent的关系"></a>4、greenlet/eventlet/gevent的关系</h4><p>&#8195;&#8195;Greelent实现了一个比较易用(相比yeild)的协程切换的库。但是greenlet没有自己的调度过程，所以一般不会直接使用。<br>&#8195;&#8195;Eventlet在Greenlet的基础上实现了自己的GreenThread，实际上就是greenlet类的扩展封装，而与Greenlet的不同是，Eventlet实现了自己调度器称为Hub，Hub类似于Tornado的IOLoop，是单实例的。在Hub中有一个event loop，根据不同的事件来切换到对应的GreenThread。同时Eventlet还实现了一系列的补丁来使Python标准库中的socket等等module来支持GreenThread的切换。Eventlet的Hub可以被定制来实现自己调度过程。<br>&#8195;&#8195;Gevent基于libev和Greenlet。不同于Eventlet的用python实现的hub调度，Gevent通过Cython调用libev来实现一个高效的event loop调度循环。同时类似于Eventlet，Gevent也有自己的monkey_patch，在打了补丁后，完全可以使用python线程的方式来无感知的使用协程，减少了开发成本。<br>&#8195;&#8195;这里也顺便给出greenlet/eventlet/gevent和其他可以实现协程模式库的对比表格，该表来自Gruvi作者的项目介绍页。Gruvi是一个轻量且特别的协程库，项目作者因为不太认同常见python协程库的实现方式，而且也不认同不推荐使用monkey patch方式，所有他写了Gruvi，专注green thread：<a target="_blank" rel="noopener" href="https://gruvi.readthedocs.io/en/latest/rationale.html">项目地址</a></p>
<table>
<thead>
<tr>
<th align="left">Feature</th>
<th align="left">Gruvi</th>
<th align="left">Asyncio</th>
<th align="left">Gevent</th>
<th align="left">Eventlet</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IO library</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/joyent/libuv">libuv</a></td>
<td align="left">stdlib</td>
<td align="left"><a target="_blank" rel="noopener" href="http://libev.schmorp.de/">libev</a></td>
<td align="left">stdlib / <a target="_blank" rel="noopener" href="http://libevent.org/">libevent</a></td>
</tr>
<tr>
<td align="left">IO abstraction</td>
<td align="left">Transports / Protocols</td>
<td align="left">Transports / Protocols</td>
<td align="left">Green sockets</td>
<td align="left">Green sockets</td>
</tr>
<tr>
<td align="left">Threading</td>
<td align="left"><a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/fibers">fibers</a></td>
<td align="left"><code>yield from</code></td>
<td align="left"><a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/greenlet">greenlet</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/greenlet">greenlet</a></td>
</tr>
<tr>
<td align="left">Resolver</td>
<td align="left">threadpool</td>
<td align="left">threadpool</td>
<td align="left">threadpool / <a target="_blank" rel="noopener" href="http://c-ares.haxx.se/">c-ares</a></td>
<td align="left">blocking / <a target="_blank" rel="noopener" href="http://www.dnspython.org/">dnspython</a></td>
</tr>
<tr>
<td align="left">Python: 2.x</td>
<td align="left">YES (2.7)</td>
<td align="left">YES (2.6+, via <a target="_blank" rel="noopener" href="https://bitbucket.org/enovance/trollius">Trollius</a>)</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Python: 3.x</td>
<td align="left">YES (3.3+)</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">Python: PyPy</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Platform: Linux</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
</tr>
<tr>
<td align="left">Platform: Mac OSX</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
</tr>
<tr>
<td align="left">Platform: Windows</td>
<td align="left">FAST (IOCP)</td>
<td align="left">FAST (IOCP)</td>
<td align="left">SLOW (select)</td>
<td align="left">SLOW (select)</td>
</tr>
<tr>
<td align="left">SSL: Posix</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
<td align="left">FAST</td>
</tr>
<tr>
<td align="left">SSL: Windows</td>
<td align="left">FAST (IOCP)</td>
<td align="left">FAST (IOCP 3.5+)</td>
<td align="left">SLOW (select)</td>
<td align="left">SLOW (select)</td>
</tr>
<tr>
<td align="left">SSL: Contexts</td>
<td align="left">YES (also Py2.7)</td>
<td align="left">YES (also Py2.6+)</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">HTTP</td>
<td align="left">FAST (via <a target="_blank" rel="noopener" href="https://github.com/joyent/http-parser">http-parser</a>)</td>
<td align="left">NO (external)</td>
<td align="left">SLOW (stdlib)</td>
<td align="left">SLOW (stdlib)</td>
</tr>
<tr>
<td align="left">Monkey Patching</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
</tbody></table>
<p>本博客也会为Gruvi写一篇文章，主要是欣赏作者阐述的设计理念。从对比表格来看，Asyncio各方面都出色，而且完全由Python标准库实现，后面也有关于Asyncio深入讨论的文章。</p>
<h4 id="5、gevent-不适用的场合"><a href="#5、gevent-不适用的场合" class="headerlink" title="5、gevent 不适用的场合"></a>5、gevent 不适用的场合</h4><p>这里参考Stack Overflow的文章<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/54254252/asyncio-vs-gevent">《Asyncio vs. Gevent 》</a></p>
<p>it wasn’t perfect:</p>
<ul>
<li>Back then, it didn’t work well on Windows (and it still has some limitations today). gevent在Windows 表现不佳</li>
<li>It couldn’t monkey-patch C extensions, so we coudn’t use MySQLdb,  for example. Luckily, there were many pure Python alternatives, like  PyMySQL. 由于gevent的 monkey-patch替换原理，参考上面2.2，它只支持对存python库打补丁，对于C语言实现的python库，例如MySQLdb，则不支持。</li>
</ul>
<p>这里篇文章大致意思是建议用asyncio，因为它是标准库，有着非常详细的文档以及稳定的python官方维护。gevent也可以用，但是自己要清楚项目演进的后续维护情况。</p>
<p>Supported Platforms</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pypi.org/project/gevent/whatsnew_1_3.html">gevent 1.3</a> runs on Python 2.7 and Python 3. Releases 3.4, 3.5 and<br>3.6 of Python 3 are supported. (Users of older versions of Python 2<br>need to install gevent 1.0.x (2.5), 1.1.x (2.6) or 1.2.x (&lt;=2.7.8);<br>gevent 1.2 can be installed on Python 3.3.) gevent requires the<br><a target="_blank" rel="noopener" href="https://greenlet.readthedocs.io/">greenlet</a> library and will install<br>the <a target="_blank" rel="noopener" href="https://cffi.readthedocs.io/">cffi</a> library by default on Windows.</p>
</blockquote>
<h4 id="6、协程原理解析"><a href="#6、协程原理解析" class="headerlink" title="6、协程原理解析"></a>6、协程原理解析</h4><p>&#8195;&#8195;前面具体的gevent代码示例，对深入理解协程有一定帮助，因为在本文中，把原理性的讨论放在最后一节显得更为合理。谈到协程又不得不把进程、线程以及堆、栈相关概念抛出，以便从全局把握协程、线程和进程。</p>
<h5 id="6-1-进程与内存分配"><a href="#6-1-进程与内存分配" class="headerlink" title="6.1 进程与内存分配"></a>6.1 进程与内存分配</h5><p>&#8195;&#8195;进程是系统资源分配的最小单位，Linux系统由一个个在后台运行process提供所有功能的组成，你可以用<code>ll /proc |wc -l</code>或者<code>ps aus|less</code>查看系统运行的进程。进程自己是需要占用系统资源的，例如cpu、内存、网络，这里我们关注其<br>程序的内存分配。<br>这里以一个由C /C++编译的程序占用的内存分为以下几个部分为例说明，这段内容参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZXR_LJ/article/details/79440577">《堆栈的区别》</a>：</p>
<ul>
<li><p>栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
</li>
<li><p>堆区（heap）：一般由程序员（在代码里面自行申请内存）分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
</li>
<li><p>全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放</p>
</li>
<li><p>文字常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放</p>
</li>
<li><p>程序代码区：存放函数体的二进制代码</p>
</li>
</ul>
<p>&#8195;&#8195;可以想象，系统创建一个新的进程都进行以上的复杂内存分配工作，而进程结束后系统还得进行大量内存回收清理工作，如果系统有成千上万个进程创建、切换以及销毁，可想而知，非常消耗资源，”疲于奔命，顾不上其他重要请求“（这就是Apache服务器的并发性的劣势，看看Nginx有多强大）。所以多进程做并发业务，显然不是一个理想方案。</p>
<h5 id="6-2-线程"><a href="#6-2-线程" class="headerlink" title="6.2 线程"></a>6.2 线程</h5><p>&#8195;&#8195;关于进程的描述，其实很多文章可以找到相关讨论，这里以线程和进程的区别作为说明：</p>
<ul>
<li><p>本质区别：进程是操作系统资源分配（分配CPU、内存、网络）的基本单位，而线程是任务（进行某种代码逻辑）调度和执行的基本单位</p>
</li>
<li><p>资源占用区别：每个进程都有独立的代码和程序上下文环境，进程之间的切换消耗较大系统资源（投入大，代价较高）；这里顺便说明为何代价高？因为进程之间切换涉及到用户空间（用户态）和内核空间（内核态）的切换。一个进程里面可以有多个线程运行，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的消耗的是当前进程占有的资源，代价较小，但也不低。</p>
</li>
<li><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
</li>
<li><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
</li>
</ul>
<h5 id="6-3-协程"><a href="#6-3-协程" class="headerlink" title="6.3 协程"></a>6.3 协程</h5><p>&#8195;&#8195;终于谈到本章的主角：协程，英文coroutine，它比线程更加轻量，你可以这样认为：一个进程可以拥有多个线程一样，而一个线程也可以拥有多个协程。<br>==<strong>协程与进程的区别</strong>==：</p>
<ul>
<li>执行流的调度者不同，进程是内核调度，而协程是在用户态调度，也就是说进程的上下文是在内核态保存恢复的，而协程是在用户态保存恢复的，很显然用户态的代价更低</li>
<li>进程会被强占，而协程不会，也就是说协程如果不主动让出CPU，那么其他的协程，就没有执行的机会。</li>
<li>对内存的占用不同，实际上协程可以只需要4K的栈就足够了，而进程占用的内存要大的多</li>
<li>从操作系统的角度讲，多协程的程序是单进程，单协程</li>
</ul>
<p>==<strong>协程与线程的区别</strong>==<br>&#8195;&#8195;一个线程里面可以包含多个协程，线程之间需要上下文切换成本相对协程来说是比较高的，尤其在开启线程较多时，线程的切换更多的是靠操作系统来控制，而协程之间的切换和运行由用户程序代码自行控制或者类似gevent这种自动切换，因此协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），这将为用户可以设计出非常高性能的并发编程模式。如下图所示一个主线程负责使用gevent自动调度（自动切换运行）2个协程，大致逻辑如下：</p>
<ul>
<li>主线程（MainThread，也是根协程或者当前线程）创建（spawn）两个协程，只有有协程遇到IO event时候就把控制权交给当前线程，直到这个协程的IO event已经完成，主线程将控制权给这个协程。<br><img src="https://img-blog.csdnimg.cn/20191228112520473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="7、小结"><a href="#7、小结" class="headerlink" title="7、小结"></a>7、小结</h4>&#8195;&#8195;本文开启了Python的异步编程文章讨论篇章，算是比较进阶的内容，因为异步模式可让实际项目确实受益不少，在本博客之后有关异步的内容有：asyncio、文件描述符与IO多路复用。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/gevent/" rel="tag"># gevent</a>
              <a href="/blog/tags/%E5%8D%8F%E7%A8%8B/" rel="tag"># 协程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2019/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RDD%E5%BC%B9%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86/" rel="prev" title="深入理解RDD弹性分布式数据集">
      <i class="fa fa-chevron-left"></i> 深入理解RDD弹性分布式数据集
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/01/04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90asyncio%E4%B8%8E%E5%8D%8F%E7%A8%8B/" rel="next" title="深入解析asyncio与协程">
      深入解析asyncio与协程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81-yield-%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1、 yield 实现协程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-yield-%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 yield 同步执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAyield%E6%A8%A1%E6%8B%9Fconsumer%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 启动多个yield模拟consumer并发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E3%80%81greenlet%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%8F%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2 、greenlet实现的协程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E7%AE%80%E5%8D%95gevent%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 简单gevent协程例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-gevent-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 gevent 高并发测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-%E7%90%86%E8%A7%A3gevent%E7%9A%84monkey-patch-all"><span class="nav-number">2.3.</span> <span class="nav-text">2.3  理解gevent的monkey.patch_all()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-1-locals-%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.2.1 locals()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-2-gevent-%E6%9B%BF%E6%8D%A2%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.2.2 gevent 替换非阻塞的模块的思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81gevent-examples"><span class="nav-number">3.</span> <span class="nav-text">3、gevent examples</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%88%AC%E7%BD%91%E9%A1%B5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 使用协程高并发爬网页</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-gevent%E5%AE%9E%E7%8E%B0%E7%9A%84socket%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 gevent实现的socket高并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-gevent%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 gevent数据库操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-gevent-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 gevent 多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-gevent-%E5%85%B6%E4%BB%96examples"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 gevent 其他examples</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81greenlet-eventlet-gevent%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">4、greenlet&#x2F;eventlet&#x2F;gevent的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81gevent-%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">5、gevent 不适用的场合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">6、协程原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 进程与内存分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-%E5%8D%8F%E7%A8%8B"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 协程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">7、小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个非常专注技术总结与分享的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">577k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:44</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/pjax/pjax.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/blog/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
