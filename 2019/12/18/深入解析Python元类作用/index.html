<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&amp;#8195;&amp;#8195;python的元类使用场景一般在大型框架里面，例如Django的ORM框架、基于python实现的高级设计模式，元类的这部分内容相对晦涩，但也是作为python非常核心的知识点，通过解析其机制，有利于阅读和学习优秀中间件源代码的设计逻辑，在面向对象设计的重要性不言而喻。本博客后面的内容将会给出较为复杂的设计模式的文章，里面会出现较多的元类编程，因此有必要单独开一篇文章讨">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析Python元类作用">
<meta property="og:url" content="https://yield-bytes.github.io/2019/12/18/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Python%E5%85%83%E7%B1%BB%E4%BD%9C%E7%94%A8/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="&amp;#8195;&amp;#8195;python的元类使用场景一般在大型框架里面，例如Django的ORM框架、基于python实现的高级设计模式，元类的这部分内容相对晦涩，但也是作为python非常核心的知识点，通过解析其机制，有利于阅读和学习优秀中间件源代码的设计逻辑，在面向对象设计的重要性不言而喻。本博客后面的内容将会给出较为复杂的设计模式的文章，里面会出现较多的元类编程，因此有必要单独开一篇文章讨">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-18T11:39:36.000Z">
<meta property="article:modified_time" content="2020-02-03T07:04:18.000Z">
<meta property="article:tag" content="python元类">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yield-bytes.github.io/2019/12/18/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Python%E5%85%83%E7%B1%BB%E4%BD%9C%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入解析Python元类作用 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享与沉淀</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2019/12/18/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Python%E5%85%83%E7%B1%BB%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个非常专注技术总结与分享的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入解析Python元类作用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-18 19:39:36" itemprop="dateCreated datePublished" datetime="2019-12-18T19:39:36+08:00">2019-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 15:04:18" itemprop="dateModified" datetime="2020-02-03T15:04:18+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&#8195;&#8195;python的元类使用场景一般在大型框架里面，例如Django的ORM框架、基于python实现的高级设计模式，元类的这部分内容相对晦涩，但也是作为python非常核心的知识点，通过解析其机制，有利于阅读和学习优秀中间件源代码的设计逻辑，在面向对象设计的重要性不言而喻。本博客后面的内容将会给出较为复杂的设计模式的文章，里面会出现较多的元类编程，因此有必要单独开一篇文章讨论python元类，相关内容将参考Stack Overflow上一篇很受欢迎的关于python metaclasses的文章：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python">what-are-metaclasses-in-python</a></p>
<a id="more"></a>

<h4 id="1、python的class对象"><a href="#1、python的class对象" class="headerlink" title="1、python的class对象"></a>1、python的class对象</h4><h5 id="1-1-python的class也是一种object"><a href="#1-1-python的class也是一种object" class="headerlink" title="1.1 python的class也是一种object"></a>1.1 python的class也是一种object</h5><p>”在python的世界里，一切皆对象（object）“，这句话经常出现在很多python书籍中有关”面向对象或者类“文章里。如果你要深入python，首先面向对象的思维和面向对象的编程经历较为丰富。掌握对类的理解和运用，是理解元类的重要基础。<br>1.1 类即对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Foo(object):</span><br><span class="line">   ...:     pass</span><br><span class="line">   ...:</span><br><span class="line">In [2]: my_instance&#x3D;Foo()</span><br><span class="line">In [3]: print(my_instance)</span><br><span class="line">&lt;__main__.Foo object at 0x108561b00&gt;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个名为Foo的类，打印它的实例，可以看到该实例是一个Foo object 存放在内存地址：0x108561b00<br>这里只是说明Foo类的实例是object，怎么确认Foo是一个object呢？<br>两种方式可以回答：<br>方式一：在定义阶段：Foo(object)，Foo这个类继承object，所以Foo是object<br>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [8]: isinstance(Foo,object)</span><br><span class="line">Out[8]: True</span><br></pre></td></tr></table></figure>
<p>既然Foo是一个object，那么对于该object则可以扩展其功能：</p>
<ul>
<li><p>可赋值给变量</p>
</li>
<li><p>可被复制</p>
<ul>
<li>可添加属性</li>
<li>可将其当作函数参数传递</li>
<li>当然也可绑定新的类或者对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: NewFoo=Foo</span><br><span class="line">In [<span class="number">14</span>]: print(NewFoo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">In</span> [16]:</span> CloneFoo=copy.deepcopy(Foo)</span><br><span class="line">In [<span class="number">17</span>]: print(CloneFoo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">In</span> [20]:</span> Foo.new_attr=<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">In [<span class="number">21</span>]: Foo.new_attr</span><br><span class="line">Out[<span class="number">21</span>]: <span class="string">&#x27;bar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [22]: def myfunc(obj):</span></span><br><span class="line"><span class="string">    ...:     print(obj.__name__)</span></span><br><span class="line"><span class="string">    ...:</span></span><br><span class="line"><span class="string">In [23]: myfunc(Foo)</span></span><br><span class="line"><span class="string">Foo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [24]: class  NewFoo(object):</span></span><br><span class="line"><span class="string">    ...:     pass</span></span><br><span class="line"><span class="string">    ...:</span></span><br><span class="line"><span class="string">In [25]: Foo.x=NewFoo</span></span><br><span class="line"><span class="string">In [26]: Foo.x</span></span><br><span class="line"><span class="string">Out[26]: __main__.NewFoo</span></span><br></pre></td></tr></table></figure>
<p>总之，只要拿到一个object，你可以对其扩展任意你想得到效果</p>
</li>
</ul>
<h5 id="1-2-动态创建类"><a href="#1-2-动态创建类" class="headerlink" title="1.2 动态创建类"></a>1.2 动态创建类</h5><p>什么是动态创建类？只有运行这个程序后，通过判断给定参数来决定创建的是类A还是类B，而不是给程序写为固定生产类A。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: <span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">which</span>):</span></span><br><span class="line">    ...:     <span class="keyword">if</span> which ==<span class="string">&#x27;Foo&#x27;</span>:</span><br><span class="line">    ...:         <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...:             <span class="keyword">pass</span></span><br><span class="line">    ...:         <span class="keyword">return</span> Foo</span><br><span class="line">    ...:     <span class="keyword">elif</span> which == <span class="string">&#x27;Bar&#x27;</span>:</span><br><span class="line">    ...:         <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...:             <span class="keyword">pass</span></span><br><span class="line">    ...:         <span class="keyword">return</span> Bar</span><br><span class="line">    ...:</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: myclass=choose_class(<span class="string">&#x27;Bar&#x27;</span>)</span><br><span class="line">In [<span class="number">32</span>]: print(myclass.__name__)</span><br><span class="line">Bar</span><br></pre></td></tr></table></figure>
<p>前面提到，既然Foo创建一个实例就是一个对象，把这个逻辑放在Foo身上：既然（某某某）创建一个对象就是一个Foo类，这个某某某是什么？可以做什么？<br>这个某某某就是type这个内建函数（函数也是一个对象），用type也可以像上面一样动态的创建一个类，用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(要创建的类名，该类的所有父类名字组成的元组（若无父类，则为空元组），要创建该类需要用到入参：属性的字典)</span><br><span class="line">一般写成：</span><br><span class="line">type(class_name,class_bases,class_dict)</span><br></pre></td></tr></table></figure>
<p>经典方式一般如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    car=<span class="string">&#x27;Model 3&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=age</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;my name is &#123;&#125; and &#123;&#125; years old&#x27;</span>.<span class="built_in">format</span>(self.name,self.age))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用type函数动态创建以上Person类的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为Person继承object，所以type的第二个位置参数为(object,)，Person类有三个属性因此class_dict为&#123;&#x27;car&#x27;:car,&#x27;__init__&#x27;:__init__,&#x27;info&#x27;:info&#125;)</span></span><br><span class="line">car = <span class="string">&#x27;Model 3&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(self.name,self.age)</span><br><span class="line"></span><br><span class="line">Person = <span class="built_in">type</span>(<span class="string">&#x27;Person&#x27;</span>,(<span class="built_in">object</span>,),&#123;<span class="string">&#x27;car&#x27;</span>:car,<span class="string">&#x27;__init__&#x27;</span>:__init__,<span class="string">&#x27;info&#x27;</span>:info&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: Person.__dict__</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;car&#x27;</span>: <span class="string">&#x27;Model 3&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;__init__&#x27;</span>: &lt;function __main__.__init__(self, name, age)&gt;,</span><br><span class="line">              <span class="string">&#x27;info&#x27;</span>: &lt;function __main__.info(self)&gt;,</span><br><span class="line">              <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Person&#x27;</span> objects&gt;,</span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Person&#x27;</span> objects&gt;,</span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line">In [<span class="number">5</span>]: person = Person(<span class="string">&#x27;Watt&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: person</span><br><span class="line">Out[<span class="number">6</span>]: &lt;__main__.Person at <span class="number">0x10896f9e8</span>&gt;</span><br></pre></td></tr></table></figure>
<p>type创建完整Person类！本章内容主要通过类的创建，因此type这个函数并用其实现动态创建类，为元类这个话题做了铺垫，通过以上type创建的实例推出，python创建类必须要具备以下三个参数：</p>
<ul>
<li>1、类名class_name</li>
<li>2、继承关系class_bases</li>
<li>3、类的名称空间class_dict<br>这三个参数是揭开元类是如何改变类的秘密。</li>
</ul>
<h4 id="2-、Python的metaclass元类"><a href="#2-、Python的metaclass元类" class="headerlink" title="2 、Python的metaclass元类"></a>2 、Python的metaclass元类</h4><h5 id="2-1-认识type"><a href="#2-1-认识type" class="headerlink" title="2.1 认识type"></a>2.1 认识type</h5><p>前面的内容已经说明Python中的类也是对象，那么metaclass元类（元类自己也是对象）就是用来创建这些类的类，例如可以这样理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass &#x3D; MetaClass()    #元类创建了类</span><br><span class="line">MyObject &#x3D; MyClass()     #被元类创建的类后，用它创建了实例</span><br></pre></td></tr></table></figure>
<p>在上一节内容，type可创建MyClass类：<br><code>MyClass = type(&#39;MyClass&#39;, (), &#123;&#125;)</code><br>MyClass是type()这个特殊类的一个实例，只不过这个实例直接就是类。<br>以上的逻辑主要说明一件事：type这个特殊类，就是python的一个元类，type是Python在背后用来创建所有类的元类，这句话如何理解？<br>首先，还是那句熟悉的话：在python的世界里，一切皆对象（object），包括各类数据结构、函数、类以及元类，它们都来源于一个“创物者”，这个强大的创物者这就是type元类。<br>查看每种对象的<code>__class__</code>属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">55</span>]: num=<span class="number">10</span></span><br><span class="line">In [<span class="number">56</span>]: num.__class__</span><br><span class="line">Out[<span class="number">56</span>]: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: alist=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">In [<span class="number">59</span>]: alist.__class__</span><br><span class="line">Out[<span class="number">59</span>]: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    ...:     <span class="keyword">pass</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: foo.__class__</span><br><span class="line">Out[<span class="number">61</span>]: function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...:     <span class="keyword">pass</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: b=Bar()</span><br><span class="line">In [<span class="number">65</span>]: b.__class__</span><br><span class="line">Out[<span class="number">65</span>]: __main__.Bar</span><br></pre></td></tr></table></figure>
<p>说明每个对象都是某种类，<br>那么，一个<code>__class__</code>.<code>__class__</code>又是属于哪种类呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: num.__class__.__class__</span><br><span class="line">Out[<span class="number">69</span>]: <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: foo.__class__.__class__</span><br><span class="line">Out[<span class="number">70</span>]: <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: alist.__class__.__class__</span><br><span class="line">Out[<span class="number">71</span>]: <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: b.__class__.__class__</span><br><span class="line">Out[<span class="number">72</span>]: <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p>在继续往“创物者”方向靠近，发现最后都是type：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: foo.__class__.__class__.__class__</span><br><span class="line">Out[<span class="number">74</span>]: <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: foo.__class__.__class__.__class__.__class__</span><br><span class="line">Out[<span class="number">75</span>]: <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p>以上说明：python的各类数据结构、函数、类以及元类，它们都来源于一个“创物者”，这个强大的创物者这就是type元类。</p>
<h5 id="2-2-认识-metaclass-属性"><a href="#2-2-认识-metaclass-属性" class="headerlink" title="2.2 认识__metaclass__属性"></a>2.2 认识<code>__metaclass__属性</code></h5><p>在python的元类的设计中，通常会出现<code>__metaclass__</code>属性，一般用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span>   <span class="comment">#python2版本的写法</span></span><br><span class="line">    __metaclass__ = something…</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">metaclass=something</span>):</span>   <span class="comment">#python3版本的写法</span></span><br><span class="line">    __metaclass__ = something…</span><br></pre></td></tr></table></figure>
<p>当一个类的内部属性定义了<code>__metaclass__</code>属性，说明这个类将由某个元类来创建，当Foo类一旦被调用，因为设计类时可能有继承关系，因此会出现属性搜索过程：<br>1）Foo的定义里面有<code>__metaclass__</code>这个属性？如果有，解释器在内存中通过<code>something...</code>这个元类创建一个名字为Foo的类（对象）<br>2）如果在Foo的作用域内未找到<code>__metaclass__</code>属性，则继续在父类中寻找，若在父类找到，则用<code>something...</code>这个元类创建一个名字为Foo的类（对象）。<br>3）如果任何父类中都找不到<code>__metaclass__</code>属性，它就会在模块层次中去寻找<code>__metaclass__</code>，若找到，则用<code>something...</code>这个元类创建一个名字为Foo的类（对象）。<br>4）如果还是找不到<code>__metaclass__</code>,解释器最终使用内置的type来创建这个Foo类对象。</p>
<p>从上面过程可知，既然找到<code>something...</code>这个元类后它就可以创建类，说明它与type这个终极元类作用一样：都是用来创建类。<br>所以可推出：<code>__metaclass__</code>指向某个跟type功能相仿的元类———任何封装type的元类、继承type的子类、type本身</p>
<p>下面用元类实现的redis连接单例来感受下以上的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisMetaSingleton</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">cls,class_name,class_bases,class_dict</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;元类做初始化&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#super(RedisMetaSingleton, cls).__init__(class_name, class_bases, class_dict) python2写法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(class_name, class_bases, class_dict) <span class="comment"># python3写法</span></span><br><span class="line">        cls._instance =<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,host,port,db</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;call调用即完成类的实例化，用类的入参创建redis连接实例&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            <span class="comment"># cls._instance = super(RedisMetaSingleton, cls).__call__(host,port,db) python2写法</span></span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__call__(host,port,db)<span class="comment"># python3写法</span></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisSingleton</span>(<span class="params">metaclass=RedisMetaSingleton</span>):</span></span><br><span class="line">    <span class="string">&quot;redis操作专用类&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">__init__</span>(<span class="params">self,host,port,db</span>):</span></span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line">        self.db=db</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">self</span>):</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>测试其实例是否为单例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: r1=RedisSingleton(<span class="string">&#x27;182.0.0.10&#x27;</span>,<span class="string">&#x27;6379&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">In [<span class="number">38</span>]: r1</span><br><span class="line">Out[<span class="number">38</span>]: &lt;__main__.RedisSingleton at <span class="number">0x10fdc6080</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: r2=RedisSingleton(<span class="string">&#x27;182.0.0.10&#x27;</span>,<span class="string">&#x27;6379&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">In [<span class="number">40</span>]: r1 <span class="keyword">is</span> r2</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>将单例逻辑放在定义元类这里，其他redis常用方法则放在子类实现。此外，该测试用例需要注意的两点：<br>1）RedisMetaSingleton的<code>__init__</code>和<code>__call__</code>第一个参数为cls，表示元类要创建的”类对象“，因此用cls而不是self。元类至于类对象（mataclass==&gt;class object），就像类至于实例(class==&gt;instance)，反复理解该句。<br>2）<code>__init__(cls,class_name,class_bases,class_dict)</code>，第2个到4个参数，其实就是type元类创建类的所需参数：<br>type（类名，父类元组（若无父类，则为空元组），类属性或内部方法的字典）<br>3）由于RedisMetaSingleton继承type，那么super(RedisMetaSingleton, cls)经过搜索后，父类就是type，因此<br>A: <code>super(RedisMetaSingleton, cls).__init__(class_name, class_bases, class_dict)</code>的初始化就等价于<br><code>type.__init__(class_name, class_bases, class_dict)</code>的初始化<br>B:<code>super(RedisMetaSingleton, cls).__call__(host,port,db)</code>创建类对象就等价于<code>type.__call__(host,port,db)创建类对象</code><br>这就说明RedisSingleton指定由RedisMetaSingleton来创建，在RedisMetaSingleton内部最后交由<code>type.__init__</code>初始化，证明过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">119</span>]: <span class="class"><span class="keyword">class</span> <span class="title">RedisMetaSingleton</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">     ...:     <span class="string">&quot;&quot;&quot;在元类层面实现单例&quot;&quot;&quot;</span></span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">cls,class_name,class_bases,class_dict</span>):</span></span><br><span class="line">     ...:         <span class="built_in">super</span>(RedisMetaSingleton, cls).__init__(class_name, class_bases, class_dict)</span><br><span class="line">     ...:         print(<span class="string">&#x27;class_name:&#123;&#125; class_bases:&#123;&#125; class_dict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(class_name,class_bases,class_dict))</span><br><span class="line">     ...:         cls.cls_object =<span class="literal">None</span></span><br><span class="line">     ...:</span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls,host,port,db</span>):</span></span><br><span class="line">     ...:         <span class="keyword">if</span> <span class="keyword">not</span> cls.cls_object:</span><br><span class="line">     ...:             cls.cls_object = <span class="built_in">super</span>(RedisMetaSingleton, cls).__call__(host,port,db)</span><br><span class="line">     ...:         <span class="keyword">return</span> cls.cls_object</span><br><span class="line">     ...:</span><br><span class="line">     ...: <span class="class"><span class="keyword">class</span> <span class="title">RedisSingleton</span>(<span class="params">metaclass=RedisMetaSingleton</span>):</span></span><br><span class="line">     ...:     <span class="string">&quot;redis操作专用类&quot;</span></span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span>  <span class="title">__init__</span>(<span class="params">self,host,port,db</span>):</span></span><br><span class="line">     ...:         self.host=host</span><br><span class="line">     ...:         self.port=port</span><br><span class="line">     ...:         self.db=db</span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">conn</span>(<span class="params">self</span>):</span></span><br><span class="line">     ...:         <span class="keyword">pass</span></span><br><span class="line">     ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当以上代码在ipython解释器敲下去后，解释器对RedisMetaSingleton做了<code>__init__</code>初始化工作，故可得到以下打印信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_name:RedisSingleton  # 类名</span><br><span class="line">class_bases:() # 父类元组</span><br><span class="line">class_dict:&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;RedisSingleton&#39;, &#39;__doc__&#39;: &#39;redis操作专用类&#39;, &#39;__init__&#39;: &lt;function RedisSingleton.__init__ at 0x10ffa0158&gt;, &#39;conn&#39;: &lt;function RedisSingleton.conn at 0x10ffa00d0&gt;&#125; # 要创建类的所有属性字典</span><br></pre></td></tr></table></figure>
<p>这三个参数就是type创建类的所需的参数:<br><code>type（类名，父类元组（若无父类，则为空元组），类属性或内部方法的字典）</code></p>
<p>以上内容略显复杂：归结起来，只要一个普通类指定需要元类创建，那么最终一定是由type这个终极元类来创建。</p>
<h5 id="2-3-自定义元类"><a href="#2-3-自定义元类" class="headerlink" title="2.3 自定义元类"></a>2.3 自定义元类</h5><p>对元类的构建和原理有一定认识后，那么可通过元类定制普通类，真正站在创物者的上帝视野来创建普通类。<br>现在有这样一个需求，要求创建的普通类的属性满足以下条件：<br>对于开头不是<code>__</code>的属性，都要大写，例如get_name(self)，在元类创建该普通类后都会被改为GET_NAME(self)<br>开头为<code>__</code>的属性，大小写保持不变。<br>从type创建普通类的“公式“可知：type（class_name,class_bases,class_dict）,class_dict就是放置了普通类属性或内部方法的字典），故只需要对其修改后，再重新传入type即可实现，需要基于type的<code>__new__</code>方法实现，type当然有<code>__new__</code>方法，因为type是元类，也是类。（元类必然有<code>__new__</code>方法，它创建的普通类例如Person、RedisConn才有这个内建的<code>__new__</code>方法。）<br>具体实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># 在这里，被创建的对象是类，因此第一个参数为cls，而不是类实例化的self，且需重写__new__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, class_name,class_bases,class_dict</span>):</span></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> class_dict.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line">        <span class="comment"># 用uppercase_attr替换了原class_dict，再传入到type，由type创建类，实现了自定义创建类的目标      </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(class_name,class_bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>考虑到<code>return type(class_name,class_bases, uppercase_attr)</code>的写法不是pythone的OOP的写法（不够高级、抽象），因此又转化为以下OOP写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># 在这里，被创建的对象是类，因此第一个参数为cls，而不是实例self，且需重写__new__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, class_name,class_bases,class_dict</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> class_dict.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr  = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)</span><br><span class="line">        <span class="comment"># 用uppercase_attr替换了原class_dict，再传入type，由type创建类，实现了自定义创建类的目标      </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,class_name,class_bases, uppercase_attr)</span><br></pre></td></tr></table></figure>
<p>以上OOP风格在知名的python框架中到处可见！此外，我们知道通过super(UpperAttrMetaclass,cls)可以搜索到父类type，因此开发者会习惯写成以下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, class_name,class_bases,class_dict</span>):</span></span><br><span class="line">        attrs = ((name, value) <span class="keyword">for</span> name, value <span class="keyword">in</span> class_dict.items() <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>))</span><br><span class="line">        uppercase_attr  = <span class="built_in">dict</span>((name.upper(), value) <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs)  </span><br><span class="line">        <span class="comment"># return super(UpperAttrMetaclass,cls).__new__(cls,class_name,class_bases, uppercase_attr)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,class_name,class_bases, uppercase_attr) <span class="comment"># python3的写法</span></span><br></pre></td></tr></table></figure>
<p>定义一个普通类测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">124</span>]: <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">metaclass=UpperAttrMetaclass</span>):</span></span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">     ...:         self.name=name</span><br><span class="line">     ...:         self.age=age</span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">     ...:         print(<span class="string">&#x27;name is:&#x27;</span>,self.name)</span><br><span class="line">     ...:     <span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">self</span>):</span></span><br><span class="line">     ...:         print(<span class="string">&#x27;age is:&#x27;</span>,self.age)</span><br><span class="line">     ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: Person.__dict__</span><br><span class="line">Out[<span class="number">125</span>]:</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;GET_NAME&#x27;</span>: &lt;function __main__.Person.get_name(self)&gt;,</span><br><span class="line">              <span class="string">&#x27;GET_AGE&#x27;</span>: &lt;function __main__.Person.get_age(self)&gt;,</span><br><span class="line">              <span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Person&#x27;</span> objects&gt;,</span><br><span class="line">              <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Person&#x27;</span> objects&gt;,</span><br><span class="line">              <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>当普通类Person定义后，解释器已经用元类UpperAttrMetaclass创建了Person普通类，其get_name和get_age方法名都被改为大写：GET_NAME和GET_AGE，其他双下划线的的方法名字保持不变。</p>
<p>此外，metaclass不局限于类的调用，也可以在任何对象内部调用，例如函数内部调用，例如以下一个模块upper_attr_by_func.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span>(<span class="params">class_name,class_bases,class_dict</span>):</span></span><br><span class="line">    uppercase_attr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, val <span class="keyword">in</span> class_dict.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>):</span><br><span class="line">            uppercase_attr[name.upper()] = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(class_name,class_bases,class_dict)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr  <span class="comment"># 该元类只能作用在本模块的所有类，对其他模块a.py、b.py无影响。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">metaclass=UpperAttrMetaclass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;name is:&#x27;</span>,self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;age is:&#x27;</span>,self.age)</span><br></pre></td></tr></table></figure>
<p>但需要注意的是：这种方式，元类的作用域将受到限制，仅能影响本模块upper_attr_by_func.py的所有类，对其他模块的类不产生作用。</p>
<p>综上，可总结元类定制普通类的创建一般如下过程：</p>
<ul>
<li><p>拦截一个普通类，一般在会使用<code>__new__，__init__ 和 __call__</code>，这些方法的内部可以放入对普通类进行不同定制的代码逻辑，其中：<br>A、<code>__new__</code>和<code>__init__</code>方法用于控制类的行为<br>B、 <code>__call__</code>方法用于控制类实例化的行为（</p>
</li>
<li><p>修改普通类，一般是指修改type(class_name,class_bases,class_dict）里面的三个参数，尤其对class_dict修改频繁，例如要求class_dict里面的必须要有<code>__doc__</code>属性，甚至针对父类元组class_bases来操作其继承关系。</p>
</li>
<li><p>通过<code>return super().__new__(cls,class_name,custom_bases, custom_class_dict)</code>创建并返回普通类</p>
</li>
</ul>
<p>元类一般用于复杂的框架上改变类的行为，对于普通简单的类，还有其他两种手段用来改变类：</p>
<ul>
<li>monkey patching</li>
<li>类装饰器<br>按Stack Overflow上的”建议“：<br>如果需要改变类，99%的情况下使用这两种方法，但其实98%的情况你根本不需要改变类。所以你看到很多较为简单的python轮子，一般是几个普通类就可以完成，根本无需动用元类来构建普通类。</li>
</ul>
<h4 id="3、元类定制普通类的示例——myORM"><a href="#3、元类定制普通类的示例——myORM" class="headerlink" title="3、元类定制普通类的示例——myORM"></a>3、元类定制普通类的示例——myORM</h4><p>本节内容参考了廖雪峰的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072">文章</a>，但其文章有很多关键的语句并无做更细致的说明，本节内容会在重要的元类实现逻辑上给出更详细的文字说明。<br>这里将实现一个轻量ORM——myORM：<br>在架构层面（不面向用户）</p>
<ul>
<li>架构定义了一个元类ModelMetaClass，用于拦截和修改普通类User定义阶段的class_dict属性字典，并用改造后的class_dict传入type来创建普通类User对象。</li>
<li>架构定义了一个Model类，用于把字段属性名和字段值封装在拼接的SQL语句，主要负责与数据库的增删查改。</li>
<li>架构定义了一个基本字段类Field：包含字段名和字段类型</li>
</ul>
<p>在用户层面（面向用户，用户可自行定义各种模型）</p>
<ul>
<li>用户定义一个整数字段类IntField，用于存放整型类型数据，例如id号，age</li>
<li>用户定义一个字符串字段类CharField，用于存放字符类型数据，例如name，email</li>
<li>创建一个User模型的一条行记录</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaClass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    例如定义User普通类,如下：</span></span><br><span class="line"><span class="string">    class User(Model):</span></span><br><span class="line"><span class="string">        id=IntField(&#x27;user_id&#x27;)</span></span><br><span class="line"><span class="string">        name=CharField(&#x27;user_name&#x27;)</span></span><br><span class="line"><span class="string">        email=CharField(&#x27;email&#x27;)</span></span><br><span class="line"><span class="string">        password=CharField(&#x27;password&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    那么元类ModelMetaClass捕获到的属性字典为： </span></span><br><span class="line"><span class="string">    class_dict=&#123;</span></span><br><span class="line"><span class="string">        &#x27;__module__&#x27;: &#x27;__main__&#x27;, </span></span><br><span class="line"><span class="string">        &#x27;__qualname__&#x27;: &#x27;User&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;id&#x27;:IntField&lt;user_id,bigint&gt;,</span></span><br><span class="line"><span class="string">        &#x27;name&#x27;:CharField&lt;&#x27;user_name&#x27;,varchar(100)&gt;,</span></span><br><span class="line"><span class="string">        &#x27;email&#x27;:CharField&lt;&#x27;email&#x27;,varchar(100)),</span></span><br><span class="line"><span class="string">        &#x27;password&#x27;:CharField&lt;&#x27;password&#x27;,varchar(100)&gt;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,class_name,class_bases,class_dict</span>):</span></span><br><span class="line">        <span class="keyword">if</span> class_name == <span class="string">&quot;Model&quot;</span>:</span><br><span class="line">            <span class="comment"># 如果创建的普通类为Model，不修改该类，直接创建即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,class_name,class_bases,class_dict)</span><br><span class="line">        print(<span class="string">&#x27;在ModelMetaClass元类捕获到普通类的属性字典:\n&#x27;</span>,class_dict)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用于存放字段类型的属性</span></span><br><span class="line">        fields_dict=<span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> attr_name,attr <span class="keyword">in</span> class_dict.items():</span><br><span class="line">            <span class="comment"># 因为普通类属性字典还有__doc__,__qualname__等属性，因此要过滤出属于Field类型属性</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(attr,Field):</span><br><span class="line">                <span class="comment"># 打印结果：attr_name is &quot;id&quot;,field object is &quot;&lt;class &#x27;__main__.IntField&#x27;&gt;&quot;等字段信息</span></span><br><span class="line">                print(<span class="string">&#x27;attr_name is &quot;&#123;&#125;&quot;,field object is &quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(attr_name,<span class="built_in">type</span>(attr)))</span><br><span class="line">                fields_dict[attr_name]=attr</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> field_name <span class="keyword">in</span> fields_dict.keys():</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            把Field类型的属性在原属性字典剔除：</span></span><br><span class="line"><span class="string">            u=User(name=&#x27;Wott&#x27;)</span></span><br><span class="line"><span class="string">            print(u.name)# 打印结果Wott</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            若不在原字典删除，那么u.name的值为：CharField&lt;email,varchar(100)&gt;</span></span><br><span class="line"><span class="string">            这个值是元类创建User类的属性值，它会覆盖了值为&#x27;Wott&#x27;的u.name实例属性，显然不符合实际情况。</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            class_dict.pop(field_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在原属性字典里增加一个私有属性（字典类型），这个私有属性保存了要创建字段的信息</span></span><br><span class="line">        class_dict[<span class="string">&#x27;__fields_dict__&#x27;</span>]=fields_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取自定义模型中，指定Meta信息的数据库表名 </span></span><br><span class="line"><span class="string">        class User(Model):</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">            class Meta:</span></span><br><span class="line"><span class="string">                db_table=USER_T</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        attr_meta=class_dict.get(<span class="string">&#x27;Meta&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        print(<span class="string">&#x27;User模型定义的Meta属性:&#x27;</span>,attr_meta) <span class="comment"># Meta: &lt;class &#x27;__main__.User.Meta&#x27;&gt;</span></span><br><span class="line">        meta_table_name=<span class="built_in">getattr</span>(attr_meta,<span class="string">&#x27;db_table&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">        print(<span class="string">&#x27;User模型在Meta指定的数据库表名为：&#x27;</span>,meta_table_name) <span class="comment"># User模型在Meta指定的数据库表名为：： USER_T</span></span><br><span class="line">        <span class="keyword">if</span> attr_meta <span class="keyword">and</span> meta_table_name:</span><br><span class="line">                table=meta_table_name</span><br><span class="line">                <span class="keyword">del</span> class_dict[<span class="string">&#x27;Meta&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                table=class_name <span class="comment"># 若User模型没指定Meta中的数据库表名，则默认用User模型类名作为数据库表名</span></span><br><span class="line">        class_dict[<span class="string">&#x27;__table_name__&#x27;</span>]=table </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把原Meta属性变成私有属性，这样创建出来的类更具OOP风格</span></span><br><span class="line">        class_dict[<span class="string">&#x27;__Meta__&#x27;</span>]=attr_meta</span><br><span class="line">        <span class="comment"># 以上完成对普通User模型的属性字典改造后，再重新把它传入到type，从而元类ModelMetaClass完成拦截=&gt;定制=&gt;创建普通类的过程。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls,class_name,class_bases,class_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params"><span class="built_in">dict</span>,metaclass=ModelMetaClass</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1、Model类继承dict，目的是为了满足ORM中使用字典赋值和取值的方式例如</span></span><br><span class="line"><span class="string">    创建u=User(id=1,name=&#x27;Wott&#x27;,email=&#x27;11@11.com&#x27;,password=&#x27;1213&#x27;)</span></span><br><span class="line"><span class="string">	2、Model内部通过拼接普通类的字段属性信息，封装了原生sql语句，例如save(),filter(),update()等方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,attr_name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重写内建getattr方法，可实现类似u.name这种点号获取属性值得方式,用起来更具ORM风格</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[attr_name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Model object has no attribute &#123;&#125;&quot;</span>.<span class="built_in">format</span>(attr_name))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self,col_name,col_value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重写setattr方法，可实现类似u.name=&quot;Foo&quot;这种通过点号设置属性值的方式，用起来更具ORM风格</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self[col_name]=col_value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 字段名列表</span></span><br><span class="line">        column_name_list=[]</span><br><span class="line">        place_holder_list=[]</span><br><span class="line">        <span class="comment"># 字段值列表</span></span><br><span class="line">        column_value_list=[]</span><br><span class="line">        fields_dict=self.__fields_dict__</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 存放字段的字典，key就是字段名，放在字段名列表，value就是字段值，放在字段值列表，两个列表用于拼接sql语句</span></span><br><span class="line">        <span class="keyword">for</span> attr_name,attr <span class="keyword">in</span> fields_dict.items():</span><br><span class="line">            <span class="comment"># 打印为：attr_name==&gt;id,attr==&gt;&lt;class &#x27;__main__.IntField&#x27;&gt;,attr.col_name==&gt;user_id</span></span><br><span class="line">            column_name_list.append(attr.col_name)</span><br><span class="line">            place_holder_list.append(<span class="string">&#x27;%s&#x27;</span>)</span><br><span class="line">            print(self) <span class="comment"># Model Dict:&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Foo&#x27;, &#x27;email&#x27;: &#x27;11@11.com&#x27;, &#x27;password&#x27;: &#x27;Pa33Wood&#x27;&#125; </span></span><br><span class="line">            column_value_list.append(self[attr_name])</span><br><span class="line">            <span class="comment"># 或者column_value_list.append(getattr(self,attr_name))</span></span><br><span class="line"></span><br><span class="line">            sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table_name__, <span class="string">&#x27;,&#x27;</span>.join(column_name_list), <span class="string">&#x27;,&#x27;</span>.join(place_holder_list))</span><br><span class="line">        print(<span class="string">&#x27;SQL语句:&#x27;</span>,sql)</span><br><span class="line">        print(<span class="string">&#x27;SQL的入参值列表:&#x27;</span>,column_value_list)</span><br><span class="line">            <span class="comment"># 连接mysql数据库后，使用cur.execute(sql,column_value_list)即可存入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Model type:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">super</span>().__str__())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,col_name,col_type</span>):</span></span><br><span class="line">        self.col_name=col_name <span class="comment"># 字段名</span></span><br><span class="line">        self.col_type=col_type <span class="comment"># 字段类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        例如将会打印以下格式：</span></span><br><span class="line"><span class="string">        &#x27;id&#x27;: IntField&lt;user_id,bigint&gt;等</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125;&lt;&#123;&#125;,&#123;&#125;&gt;&quot;</span>.<span class="built_in">format</span>(self.__class__.__name__,self.col_name,self.col_type)</span><br><span class="line">    </span><br><span class="line">    __repr__=__str__</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharField</span>(<span class="params">Field</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义字符型字段,默认可变字符类型长度为100</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, col_name, max_length=<span class="number">100</span></span>):</span></span><br><span class="line">        varchar_type=<span class="string">&quot;varchar(&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(max_length)</span><br><span class="line">        <span class="built_in">super</span>().__init__(col_name, varchar_type)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntField</span>(<span class="params">Field</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    定义整型字段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, col_name, col_type=<span class="string">&quot;bigint&quot;</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(col_name, col_type)</span><br></pre></td></tr></table></figure>
<p>ModelMetaClass负责顶层设计（改造），用户创建所有的普通类如User、Article、Department等，都会被该元类重设设计（改造它们的class_dict）后再创建出这些普通类。</p>
<p>用户定义了一个User模型，有四个字段，并指定创建为表名为USER_T</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="built_in">id</span>=IntField(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    name=CharField(<span class="string">&#x27;user_name&#x27;</span>)</span><br><span class="line">    email=CharField(<span class="string">&#x27;email&#x27;</span>,max_length=<span class="number">200</span>)</span><br><span class="line">    password=CharField(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        自定义数据库表名，这里虽然Meta定义为类，</span></span><br><span class="line"><span class="string">        但在元类ModelMetaClass的视角来看，它是一个属性，放在class_dict里面</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        db_table=<span class="string">&#x27;USER_T&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当用户定义完以上的普通类User后，Python解释器首先在当前类User的定义中查找metaclass，显然当前上下文环境没有找到，则继续在父类Model中查找metaclass，发现Model定义了metaclass=ModelMetaClass，故直接交由ModelMetaclass来创建该普通的User类。</p>
<p>用户创建了User实例并尝试向db插入该条数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u=User(<span class="built_in">id</span>=<span class="number">1</span>,name=<span class="string">&#x27;Wott&#x27;</span>,email=<span class="string">&#x27;11@11.com&#x27;</span>,password=<span class="string">&#x27;1213&#x27;</span>) <span class="comment"># Model继承dict，因此Model子类User当然可用字典创建方式来创建实例</span></span><br><span class="line">u[<span class="string">&#x27;name&#x27;</span>]=<span class="string">&#x27;Foo&#x27;</span><span class="comment"># Model继承dict，因此Model子类User当然可使用字典方式赋值</span></span><br><span class="line">u.password=<span class="string">&#x27;Pa33Wood&#x27;</span><span class="comment"># Model内部定义__setattr__方法，故可用点号给属性赋值</span></span><br><span class="line">print(u.email) <span class="comment"># Model内部定义__getattr__方法，故可用点号取属性值</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>

<p>以上代码各个位置上的print输出结果如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第一句print输出：</span><br><span class="line">在ModelMetaClass元类捕获到普通类的属性字典:</span><br><span class="line"> &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;User&#x27;, &#x27;id&#x27;: IntField&lt;user_id,bigint&gt;, &#x27;name&#x27;: CharField&lt;user_name,varchar(100)&gt;, &#x27;email&#x27;: CharField&lt;email,varchar(200)&gt;, &#x27;password&#x27;: CharField&lt;password,varchar(100)&gt;, &#x27;Meta&#x27;: &lt;class &#x27;__main__.User.Meta&#x27;&gt;&#125;</span><br><span class="line"></span><br><span class="line">第二句print输出：</span><br><span class="line">attr_name is &quot;id&quot;,field object is &quot;&lt;class &#x27;__main__.IntField&#x27;&gt;&quot;</span><br><span class="line">attr_name is &quot;name&quot;,field object is &quot;&lt;class &#x27;__main__.CharField&#x27;&gt;&quot;</span><br><span class="line">attr_name is &quot;email&quot;,field object is &quot;&lt;class &#x27;__main__.CharField&#x27;&gt;&quot;</span><br><span class="line">attr_name is &quot;password&quot;,field object is &quot;&lt;class &#x27;__main__.CharField&#x27;&gt;&quot;</span><br><span class="line"></span><br><span class="line">第三句print输出：</span><br><span class="line">User模型定义的Meta属性: &lt;class &#x27;__main__.User.Meta&#x27;&gt;</span><br><span class="line"></span><br><span class="line">第四句print输出：</span><br><span class="line">User模型在Meta指定的数据库表名为： USER_T</span><br><span class="line"></span><br><span class="line">第五句print输出：</span><br><span class="line">11@11.com</span><br><span class="line"></span><br><span class="line">第六句print输出：</span><br><span class="line">Model type:&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Foo&#x27;, &#x27;email&#x27;: &#x27;11@11.com&#x27;, &#x27;password&#x27;: &#x27;Pa33Wood&#x27;&#125;</span><br><span class="line">Model type:&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Foo&#x27;, &#x27;email&#x27;: &#x27;11@11.com&#x27;, &#x27;password&#x27;: &#x27;Pa33Wood&#x27;&#125;</span><br><span class="line">Model type:&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Foo&#x27;, &#x27;email&#x27;: &#x27;11@11.com&#x27;, &#x27;password&#x27;: &#x27;Pa33Wood&#x27;&#125;</span><br><span class="line">Model type:&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Foo&#x27;, &#x27;email&#x27;: &#x27;11@11.com&#x27;, &#x27;password&#x27;: &#x27;Pa33Wood&#x27;&#125;</span><br><span class="line"></span><br><span class="line">第七句print输出：</span><br><span class="line">SQL语句: insert into USER_T (user_id,user_name,email,password) values (%s,%s,%s,%s)</span><br><span class="line"></span><br><span class="line">第八句print输出：</span><br><span class="line">SQL的入参值列表: [1, &#x27;Foo&#x27;, &#x27;11@11.com&#x27;, &#x27;Pa33Wood&#x27;]</span><br></pre></td></tr></table></figure>



    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python%E5%85%83%E7%B1%BB/" rel="tag"># python元类</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/08/%E5%9F%BA%E4%BA%8EYARN%20HA%E9%9B%86%E7%BE%A4%E7%9A%84Spark%20HA%E9%9B%86%E7%BE%A4/" rel="prev" title="基于YARN HA集群的Spark HA集群">
      <i class="fa fa-chevron-left"></i> 基于YARN HA集群的Spark HA集群
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/20/%E5%9F%BA%E4%BA%8ESentinel%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8Redis/" rel="next" title="基于Sentinel模式部署高可用Redis">
      基于Sentinel模式部署高可用Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81python%E7%9A%84class%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">1、python的class对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-python%E7%9A%84class%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8Dobject"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 python的class也是一种object</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 动态创建类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E3%80%81Python%E7%9A%84metaclass%E5%85%83%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">2 、Python的metaclass元类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E8%AE%A4%E8%AF%86type"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 认识type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E8%AE%A4%E8%AF%86-metaclass-%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 认识__metaclass__属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 自定义元类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%85%83%E7%B1%BB%E5%AE%9A%E5%88%B6%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94myORM"><span class="nav-number">3.</span> <span class="nav-text">3、元类定制普通类的示例——myORM</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个非常专注技术总结与分享的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">577k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:44</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
