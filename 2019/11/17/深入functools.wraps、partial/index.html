<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&amp;#8195;&amp;#8195;在装饰器的定义中，经常引用functools.wraps，本篇文章将深入其内部源码，由于该方法的定义中，还引入其他重要的函数或者类，因此根据其调用链，对每个函数或者方法或者类进行单独分析，所以文章的结构大致如下： 第一部分内容：根据其调用链：functools.wraps——&gt;partial——&gt;update_wrapperfunctools.wraps需要">
<meta property="og:type" content="article">
<meta property="og:title" content="深入functools.wraps、partial">
<meta property="og:url" content="https://yield-bytes.github.io/2019/11/17/%E6%B7%B1%E5%85%A5functools.wraps%E3%80%81partial/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="&amp;#8195;&amp;#8195;在装饰器的定义中，经常引用functools.wraps，本篇文章将深入其内部源码，由于该方法的定义中，还引入其他重要的函数或者类，因此根据其调用链，对每个函数或者方法或者类进行单独分析，所以文章的结构大致如下： 第一部分内容：根据其调用链：functools.wraps——&gt;partial——&gt;update_wrapperfunctools.wraps需要">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-17T14:04:06.000Z">
<meta property="article:modified_time" content="2020-11-21T16:59:29.860Z">
<meta property="article:tag" content="functool.wraps">
<meta property="article:tag" content="partial">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yield-bytes.github.io/2019/11/17/%E6%B7%B1%E5%85%A5functools.wraps%E3%80%81partial/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入functools.wraps、partial | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2019/11/17/%E6%B7%B1%E5%85%A5functools.wraps%E3%80%81partial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入functools.wraps、partial
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-17 22:04:06" itemprop="dateCreated datePublished" datetime="2019-11-17T22:04:06+08:00">2019-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 00:59:29" itemprop="dateModified" datetime="2020-11-22T00:59:29+08:00">2020-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&#8195;&#8195;在装饰器的定义中，经常引用functools.wraps，本篇文章将深入其内部源码，由于该方法的定义中，还引入其他重要的函数或者类，因此根据其调用链，对每个函数或者方法或者类进行单独分析，所以文章的结构大致如下：</p>
<h4 id="第一部分内容："><a href="#第一部分内容：" class="headerlink" title="第一部分内容："></a>第一部分内容：</h4><p>根据其调用链：functools.wraps——&gt;partial——&gt;update_wrapper<br>functools.wraps需要调用partial，因此需要解析partial的源码<br>partial调用了update_wrapper函数，因此需要解析update_wrapper的源码</p>
<a id="more"></a>
<h4 id="第二部分内容："><a href="#第二部分内容：" class="headerlink" title="第二部分内容："></a>第二部分内容：</h4><p>patial作为关键函数，在第三方库造轮子里，使用频率较高。这里以borax第三方库里面的fetch方法说明partial的使用场合。考虑到fetch还使用的python内建的attrgetter和itemgetter，故还对这两个类进行解析。<br>其调用链为：fetch—-&gt;partial/attrgetter/itemgetter</p>
<h4 id="第三部分内容："><a href="#第三部分内容：" class="headerlink" title="第三部分内容："></a>第三部分内容：</h4><p>在python的内建方法中，attrgetter/itemgetter类，里面用了<code>__slots__</code>方法，本文也给出关于该方法作用的内容</p>
<p>考虑到以上有多个知识点混合，本文采用倒叙方式，文章的内容组织如下</p>
<ul>
<li>1、python的魔法方法<code>__slots__</code>的作用</li>
<li>2、attrgetter/itemgetter类的解析</li>
<li>3、borax.fetch的用法</li>
<li>4、partial的解析和用法</li>
<li>5、update_wrapper的解析和用法</li>
<li>6、functools.wraps的解析和用法</li>
</ul>
<h3 id="1、python的魔法方法-slots-的作用"><a href="#1、python的魔法方法-slots-的作用" class="headerlink" title="1、python的魔法方法__slots__的作用"></a>1、python的魔法方法<code>__slots__</code>的作用</h3><p>首先看看attrgetter/itemgetter的源代码定义(这里仅给出方法名)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class attrgetter:</span><br><span class="line">    __slots__ &#x3D; (&#39;_attrs&#39;, &#39;_call&#39;)</span><br><span class="line">    def __init__(self, attr, *attrs):</span><br><span class="line">    def __call__(self, obj):</span><br><span class="line">    def __repr__(self):</span><br><span class="line">    def __reduce__(self):</span><br></pre></td></tr></table></figure><br>该类里面引用了<code>__slots__</code>方法，仅有两个私有属性：<code>(&#39;_attrs&#39;, &#39;_call&#39;)</code></p>
<p>对于attrgetter，其作用：</p>
<ul>
<li>给类指定一个固定大小的空间存放属性，用于极致减少对象的内存占用，例如当十几万个小类（数据类），对象占用内存利用率将更有效。</li>
<li>更快的属性访问速度</li>
<li>实例后限制绑定新属性</li>
</ul>
<p>为何<code>_slots_</code>方法有以上作用?</p>
<p>&#8195;&#8195;这是因为，在定义个对象时（定义类），Python默认用一个字典来保存一个该对象实例属性。然而，对于有着已知属性的小对象类来说（例如一个坐标点类，仅有几个属性即可），当创建几十万个这些实例时，将有几十万个这样的字典占用大量内存，因此可通过slots方法告诉Python不使用字典，使用一个元组作为这几个属性的存放位置，以节省每个小对象的存储空间。<br>==slots这里不建议使用列表，因为列表占用空间比元组大。==</p>
<h5 id="1-1、-slots方法保证实例不会创建-dict-方法"><a href="#1-1、-slots方法保证实例不会创建-dict-方法" class="headerlink" title="1.1、 slots方法保证实例不会创建__dict__方法"></a>1.1、 slots方法保证实例不会创建<code>__dict__</code>方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self._x=x</span><br><span class="line">        self._y=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Point&lt;&#123;0&#125;,&#123;1&#125;&gt;&#x27;</span>.<span class="built_in">format</span>(self._x,self._y)</span><br><span class="line"></span><br><span class="line">a=Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.__dict__)</span><br><span class="line">a.test=<span class="number">3</span></span><br><span class="line">print(a.test)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">Point&lt;<span class="number">1</span>,<span class="number">2</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;_x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;_y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入slot之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_x&#x27;</span>,<span class="string">&#x27;_y&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self._x=x</span><br><span class="line">        self._y=y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Point&lt;&#123;0&#125;,&#123;1&#125;&gt;&#x27;</span>.<span class="built_in">format</span>(self._x,self._y)</span><br><span class="line">a=Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">Point&lt;<span class="number">1</span>,<span class="number">2</span>&gt;</span><br><span class="line"><span class="comment">#AttributeError: &#x27;Point&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br><span class="line"><span class="comment">#可见实例没有使用dict字典存放属性</span></span><br></pre></td></tr></table></figure>
<p>不过需要注意的是：slots魔法方法定义的属性仅对当前类实例起作用，对继承的子类是无效的</p>
<h5 id="1-2、为何列表占用空间比元组大？"><a href="#1-2、为何列表占用空间比元组大？" class="headerlink" title="1.2、为何列表占用空间比元组大？"></a>1.2、为何列表占用空间比元组大？</h5><ul>
<li>==内存占用有区别==</li>
</ul>
<p>首先列表和元组最重要的区别就是，列表是动态的、可变的对象、可读可写，而元组是静态的、不可变的对象，可读不可写。</p>
<p>下面通过实例看看它们存储以及占用空间的区别</p>
<p>查看列表的内存占用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l=[]</span><br><span class="line">l.__sizeof__()</span><br><span class="line"><span class="comment"># 40</span></span><br></pre></td></tr></table></figure>
<p>加入4个字符，每个字符为8字节空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_obj=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">list_obj.__sizeof__()</span><br><span class="line"><span class="comment"># 结果为72字节=列表自身40+4个字符*8</span></span><br></pre></td></tr></table></figure>
<p>此外列表的空间是动态增加的，在数据结构与算法里，大家在设计列表这种数据结构应该知道，当调用append方法时，内部会判断当前列表预留空间是否满足用于存放新元素，若空间不足，会再动态申请新内存，申请的逻辑为：</p>
<p>（1）当原底层数组存满时，list类会自动请求一个空间为原列表两倍的新列表</p>
<p>（2）原列表的所有元素将被一次存入新列表里</p>
<p>（3）删除原列表，并初始化新列表</p>
<p>例如下面测试，原list_obj有4个字符元素，总计为72个字节，再加一个字符，是等于80个字节吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_obj.append(<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">list_obj.__sizeof__()</span><br><span class="line"><span class="comment"># 结果为104字节=列表自身42+原4个字符*8+新1个字符*8+原4个字符*8的新申请预留空间</span></span><br></pre></td></tr></table></figure>
<p>这里列表自身从40变为42字节，是因为增加了一个1索引。</p>
<p>查看元组的内存占用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=()</span><br><span class="line">t.__sizeof__()</span><br><span class="line"><span class="comment"># 24</span></span><br></pre></td></tr></table></figure>
<p>加入4个字符，每个字符为8字节空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple_obj=(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">tuple_obj.__sizeof__()</span><br><span class="line"><span class="comment"># 结果为56字节=元组自身24+4个字符*8</span></span><br></pre></td></tr></table></figure>
<p>可以看到，存储5个字符，列表用了72个字节，元组只用了56个字节。</p>
<ul>
<li>==对象创建时间有区别==</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">t1 = timeit.Timer(<span class="string">&#x27;list_obj=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#x27;</span>)</span><br><span class="line">t1.timeit()</span><br><span class="line"><span class="comment"># 0.0844487198985604</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = timeit.Timer(<span class="string">&#x27;tuple_obj=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)&#x27;</span>)</span><br><span class="line">t2.timeit()</span><br><span class="line"><span class="comment"># 0.01631815598959463</span></span><br></pre></td></tr></table></figure>
<p>因为列表数据结构初始化需要方法逻辑比元组负责，而且需要预占空间，可以看到它们之间创建时间差别大，列表创建时间是元组的5倍左右。</p>
<h3 id="2、attrgetter-itemgetter类的解析"><a href="#2、attrgetter-itemgetter类的解析" class="headerlink" title="2、attrgetter/itemgetter类的解析"></a>2、attrgetter/itemgetter类的解析</h3><h4 id="2-1-attrgetter的使用场景"><a href="#2-1-attrgetter的使用场景" class="headerlink" title="2.1 attrgetter的使用场景"></a>2.1 attrgetter的使用场景</h4><p>attrgetter主要用于快速获取对象的keys或者属性。<br>以下以数据类型为BlogItem对象为例，该数据对象有三个attribute，分别博客网址、作者、博客文章数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogItem</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, website, author, blog_nums</span>):</span></span><br><span class="line">        self.website = website</span><br><span class="line">        self.author = author</span><br><span class="line">        self.blog_nums = blog_nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(self.__class__.__name__,self.website)</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blog_object_list = \</span><br><span class="line">    [BlogItem(<span class="string">&quot;www.aoo.cn&quot;</span>, <span class="string">&#x27;aoo&#x27;</span>, <span class="number">10</span>),</span><br><span class="line">     BlogItem(<span class="string">&quot;www.boo.cn&quot;</span>, <span class="string">&#x27;boo&#x27;</span>, <span class="number">5</span>),</span><br><span class="line">     BlogItem(<span class="string">&quot;www.coo.cn&quot;</span>, <span class="string">&#x27;coo&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">     ]</span><br><span class="line">print(blog_object_list)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">[BlogItem:www.aoo.cn, BlogItem:www.boo.cn, BlogItem:www.coo.cn]</span><br></pre></td></tr></table></figure>
<p>现要获取每行数据对象的blog属性，并对其实施排序，通常会使用lambda表达式实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">sorted</span>(blog_object_list, key=<span class="keyword">lambda</span> item: item.blog_nums))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">[BlogItem:www.boo.cn, BlogItem:www.aoo.cn, BlogItem:www.coo.cn]</span><br></pre></td></tr></table></figure>
<p>有了attrgetter方法后，更方便调用获取对象的属性，例如下面的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">sorted</span>(blog_object_list,key=attrgetter(<span class="string">&#x27;blog_nums&#x27;</span>)))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">[BlogItem:www.boo.cn, BlogItem:www.aoo.cn, BlogItem:www.coo.cn]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以传入多个属性，按多个属性进行排序，例如这里先根据blog排序、再根据author排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="built_in">sorted</span>(blog_object_list,key=attrgetter(<span class="string">&#x27;blog_nums&#x27;</span>,<span class="string">&#x27;author&#x27;</span>)))</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">[BlogItem:www.boo.cn, BlogItem:www.aoo.cn, BlogItem:www.coo.cn]</span><br></pre></td></tr></table></figure>
<h4 id="2-2-attrgetter的内部实现："><a href="#2-2-attrgetter的内部实现：" class="headerlink" title="2.2 attrgetter的内部实现："></a>2.2 attrgetter的内部实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">attrgetter</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a callable object that fetches the given attribute(s) from its `.</span></span><br><span class="line"><span class="string">    After f = attrgetter(&#x27;name&#x27;), the call f(r) returns r.name.</span></span><br><span class="line"><span class="string">    After g = attrgetter(&#x27;name&#x27;, &#x27;date&#x27;), the call g(r) returns (r.name, r.date).</span></span><br><span class="line"><span class="string">    After h = attrgetter(&#x27;name.first&#x27;, &#x27;name.last&#x27;), the call h(r) returns (r.name.first, r.name.last).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_attrs&#x27;</span>, <span class="string">&#x27;_call&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attr, *attrs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(attr, <span class="built_in">str</span>):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">&#x27;attribute name must be a string&#x27;</span>)</span><br><span class="line">            self._attrs = (attr,)</span><br><span class="line">            names = attr.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">getattr</span>(obj, name)</span><br><span class="line">            self._call = func</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#  如果获取多个属性，使用map对每个属性实施attrgetter</span></span><br><span class="line">            self._attrs = (attr,) + attrs</span><br><span class="line">            getters = <span class="built_in">tuple</span>(<span class="built_in">map</span>(attrgetter, self._attrs))</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">tuple</span>(getter(obj) <span class="keyword">for</span> getter <span class="keyword">in</span> getters)</span><br><span class="line">            self._call = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._call(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s.%s(%s)&#x27;</span> % (self.__class__.__module__,</span><br><span class="line">                              self.__class__.__qualname__,</span><br><span class="line">                              <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">repr</span>, self._attrs)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__, self._attrs</span><br></pre></td></tr></table></figure>
<p>attrgetter在内部定义了一个闭包函数func，该函数其实就是getattr(obj, name)的功能。<br>attrgetter内有个特殊的魔法方法<code>__reduce__</code>，该方法用于pickle反序列化后可以找到该对象绑定的类及其入参，若要想对某对象进行pickle，那么该对象要定义<code>__reduce__</code>方法，否则在序列化时（使用pickle.load）无法持久化存储，查看其源码pickle.dumps可以看到相关逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reduce = <span class="built_in">getattr</span>(obj, <span class="string">&quot;__reduce_ex__&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> reduce <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    rv = reduce(self.proto)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 获取被处理的对象的__reduce__方法，若不存在提示无法pickle持久化（或者称为无法被序列化），所以attrgetter对象或者其实例是可以被序列化</span></span><br><span class="line">    reduce = <span class="built_in">getattr</span>(obj, <span class="string">&quot;__reduce__&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> reduce <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        rv = reduce()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> PicklingError(<span class="string">&quot;Can&#x27;t pickle %r object: %r&quot;</span> %</span><br><span class="line">                            (t.__name__, obj))</span><br></pre></td></tr></table></figure></p>
<p><code>attrgetter的doc文档说：f = attrgetter(&#39;name&#39;), the call f(r) returns r.name。
__call__方法是为了实现f(r）用法，等价于getattr(r, name)，用于获取给定对象的属性值</code>，</p>
<p>与attrgetter不同的是：getattr只能获取单个属性值而且getattr也是python工厂函数，在builtins.py内部定义；而attrgetter可以获取多个属性值，是对getattr的再次封装和加强，只不过它的封装逻辑写得还不错，即清晰易懂。<br>==对比getattr与attrgetter的区别==<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line"><span class="comment"># getattr用法</span></span><br><span class="line">r=R(<span class="string">&#x27;foo&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">getattr</span>(r,<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">foo</span><br><span class="line"><span class="comment"># attrgetter用法</span></span><br><span class="line">f=attrgetter(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(f(r))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure></p>
<p>这里给出<code>f=attrgetter(&#39;name&#39;)==&gt;f(r)==&gt;&#39;foo&#39;</code>的调用过程，有两种情况</p>
<p>A、只获取对象的一个属性<br><code>f=attrgetter(&#39;name&#39;)==&gt;f(r)==&gt;触发__call__==&gt;self._call(obj)，因为self._call = func==&gt;func(obj)，根据func的定义，就是返回getattr(obj, name)==&gt;getattr(r,&quot;name&quot;)==&gt;“foo”</code></p>
<p>B、获取对象两个属性以上的情况</p>
<p>例如attrgetter(‘name’，‘age’)，那么其传递过程为<br><code>f=attrgetter(&#39;name&#39;，‘age&#39;)==&gt;f(r)==&gt;触发__call__==&gt;self._call(obj)，因为self._call = func==&gt;func(obj)==&gt;因为要获取两个属性，故递归调用attrgetter： getters = tuple(map(attrgetter, self._attrs))==&gt;(attrgetter(&#39;name&#39;)，attrgetter(&#39;age&#39;))==&gt;对元组里面的元素按照步A的传递路线==&gt;(getattr(r,&quot;name&quot;),getattr(r,&quot;age&quot;))==&gt;(&#39;foo&#39;,10)</code></p>
<p>从上面的分析可知，attrgetter的实现有点绕了，所以python的闭包机制虽然可以基于原始函数上封装出具备更强功能的函数，但其代价就像符合函数，层层封装。<br>例如复合函数h，h=f(g(e(x)))，复合函数h作为加强版方法，通过封装f方法，f方法封装g方法，g方法封装e方法，从而使得h方法的功能比最初始e方法具备更强大的功能，但你需要一路往内部追踪，才知道h函数最里面的函数为e函数。</p>
<h4 id="2-3-itemgetter的使用场景"><a href="#2-3-itemgetter的使用场景" class="headerlink" title="2.3 itemgetter的使用场景"></a>2.3 itemgetter的使用场景</h4><p>attrgetter可以理解给定单个key或者多个key，返回这些key的值，而对应另外一个类itemgetter，它用来实现对数据对象在给定索引号后，返回索引号对应的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">r=[</span><br><span class="line">    (<span class="string">&quot;www.boo.cn&quot;</span>, <span class="string">&#x27;boo&#x27;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;www.aoo.cn&quot;</span>, <span class="string">&#x27;aoo&#x27;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;www.coo.cn&quot;</span>, <span class="string">&#x27;coo&#x27;</span>, <span class="number">15</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">f=itemgetter(<span class="number">1</span>)</span><br><span class="line">print(f(r))</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">(<span class="string">&#x27;www.aoo.cn&#x27;</span>, <span class="string">&#x27;aoo&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">f=itemgetter(<span class="number">0</span>，<span class="number">2</span>) <span class="comment"># 注意这里不是范围，而是索引0和索引2</span></span><br><span class="line">print(f(r))</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">((<span class="string">&#x27;www.boo.cn&#x27;</span>, <span class="string">&#x27;boo&#x27;</span>, <span class="number">20</span>), (<span class="string">&#x27;www.coo.cn&#x27;</span>, <span class="string">&#x27;coo&#x27;</span>, <span class="number">15</span>))</span><br></pre></td></tr></table></figure>
<p>其源代码也简单，实现跟attrgetter逻辑一直，attrgetter使用getter(obj，key)获取值，itemgetter使用obj[index]的方式获得值，但要求obj内部必须实现<code>__getitem__(self, item)</code>方法。</p>
<h4 id="2-4-itemgetter的源码分析"><a href="#2-4-itemgetter的源码分析" class="headerlink" title="2.4 itemgetter的源码分析"></a>2.4 itemgetter的源码分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">itemgetter</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return a callable object that fetches the given item(s) from its operand.</span></span><br><span class="line"><span class="string">    After f = itemgetter(2), the call f(r) returns r[2].</span></span><br><span class="line"><span class="string">    After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_items&#x27;</span>, <span class="string">&#x27;_call&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item, *items</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">            self._items = (item,)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">                <span class="comment"># 若只提供一个索引号，则直接按getitem的写法获取该对象的值</span></span><br><span class="line">                <span class="keyword">return</span> obj[item]</span><br><span class="line">            self._call = func</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._items = items = (item,) + items</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">obj</span>):</span></span><br><span class="line">                <span class="comment"># 若获取多个索引号，则遍历这些索引号，获取每个对象的值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">tuple</span>(obj[i] <span class="keyword">for</span> i <span class="keyword">in</span> items)</span><br><span class="line">            self._call = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._call(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s.%s(%s)&#x27;</span> % (self.__class__.__module__,</span><br><span class="line">                              self.__class__.__name__,</span><br><span class="line">                              <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">repr</span>, self._items)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__, self._items</span><br></pre></td></tr></table></figure>
<p>取值传递过程有两种情况</p>
<p>A、当给定1个索引号</p>
<p><code>f=itemgetter(1)==&gt;self._call(obj)==&gt;因为self._call = func，等价于func(obj)==&gt;根据func的定义，obj[item]==&gt;r[1]==&gt;也即是列表索引取值的方式，(&#39;www.aoo.cn&#39;, &#39;aoo&#39;, 10)</code></p>
<p>B、给定多个索引号</p>
<p><code>f=itemgetter(0,2)==&gt;self._call(obj)==&gt;因为self._call = func，等价于func(obj)==&gt;根据func的定义以及入参大于1 ==&gt;tuple(obj[i] for i in items)==&gt;(obj[0],obj[1])==&gt;(r[0],r[1])==&gt;((&#39;www.boo.cn&#39;, &#39;boo&#39;, 20), (&#39;www.coo.cn&#39;, &#39;coo&#39;, 15))</code></p>
<h3 id="3、broax-fetch的用法"><a href="#3、broax-fetch的用法" class="headerlink" title="3、broax.fetch的用法"></a>3、broax.fetch的用法</h3><p>borax是一个python第三库轻量库，里面有一些基本中国农历函数、choice、数据结构、设计模式以及fetch函数。它的doc</p>
<blockquote>
<p>Borax is a utils collections for python3 development, which contains<br>some common data structures and the implementation of design patterns</p>
<p>主要的module:</p>
<ul>
<li>borax.calendars : A Chinese lunar calendar package, which contains lunar,festivals, birthday.</li>
<li>borax.choices : choices a enhance module using class-style define for const choices.</li>
<li>borax.fetch : A function sets for fetch the values of some axises.</li>
<li>borax.structures : A useful data structure for dictionary/list/set .</li>
<li>borax.patterns : A implementation for the design patterns.</li>
</ul>
</blockquote>
<p>fetch函数功能：从数据序列中选择一个或多个字段的数据，它很好展示了partial函数的实际项目的用法。</p>
<blockquote>
<p>在这里插播之后会写一篇blog的通告：<br>fetch是从已有的数据序列中，根据指定key或者属性对应的记录行，而records库则是从各类关系型数据库取出数据记录行（当然可完成增删查改），发现records源代码清晰简单，但实现功能确如此强大，所以接下来会单独给出一篇blog用于解析records源码，records不到550行，封装逻辑通俗易懂。</p>
<p>records是kennethreitz的for Humans™系列的库，用于近乎易懂的方式操作数据库，kennethreitz是requests库的作者—<a target="_blank" rel="noopener" href="https://github.com/kennethreitz">github地址</a>），kennethreitz总能把底层较为繁琐的逻辑封装成易用的逻辑，其开源的项目的源代码具有不错的学习价值。</p>
</blockquote>
<h4 id="3-1-fetch模块的源码简析"><a href="#3-1-fetch模块的源码简析" class="headerlink" title="3.1  fetch模块的源码简析"></a>3.1  fetch模块的源码简析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="comment"># 当使用from fetch import * 时，通过__all__属性来限制import *的导出范围</span></span><br><span class="line">__all__ = [<span class="string">&#x27;fetch&#x27;</span>, <span class="string">&#x27;ifetch&#x27;</span>, <span class="string">&#x27;fetch_single&#x27;</span>, <span class="string">&#x27;ifetch_multiple&#x27;</span>, <span class="string">&#x27;ifetch_single&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">EMPTY = Empty()</span><br><span class="line"><span class="comment"># 以下iterable就是要处理的数据序列例如以下数据对象Person序列</span></span><br><span class="line"><span class="comment"># [Person(&#x27;aoo&#x27;,10&#x27;),Person(&#x27;boo&#x27;,21),....,Person(&#x27;coo&#x27;,13)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifetch_single</span>(<span class="params">iterable, key, default=EMPTY, getter=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    getter() g(item, key):pass</span></span><br><span class="line"><span class="string">    # 给定单个key或者属性或者索引号，用于获取数据序列对象的值，例如获取每个Person数据对象name的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getter</span>(<span class="params">item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> getter:</span><br><span class="line">            <span class="comment"># 这里就是第三库如何把partial引用到自己的代码实现里面的一个示例，这里留到后面章节给出其解释</span></span><br><span class="line">            custom_getter = partial(getter, key=key)</span><br><span class="line">            <span class="keyword">return</span> custom_getter(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 用了第2章节内容提到的attrgetter获取属性值</span></span><br><span class="line">                <span class="comment"># 其实就是return getattr(item,key)，即获取单个数据项key对应的值</span></span><br><span class="line">                attrgetter = operator.attrgetter(key)</span><br><span class="line">                <span class="keyword">return</span> attrgetter(item)</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 用了第2章节内容提到的itemgetter，给定索引号，获取值</span></span><br><span class="line">                <span class="comment"># 其实就是return item[key],即获取给定索引号的单个数据项对应的值           </span></span><br><span class="line">                itemgetter = operator.itemgetter(key)</span><br><span class="line">                <span class="keyword">return</span> itemgetter(item)</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">if</span> default <span class="keyword">is</span> <span class="keyword">not</span> EMPTY:</span><br><span class="line">                <span class="keyword">return</span> default</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Item %r has no attr or key for %r&#x27;</span> % (item, key))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(_getter, iterable)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_single</span>(<span class="params">iterable, key, default=EMPTY, getter=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 因为ifetch_single返回的map对象，因此需要list化后，才能得到整个列表数据值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(ifetch_single(iterable, key, default=default, getter=getter))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifetch_multiple</span>(<span class="params">iterable, *keys, defaults=<span class="literal">None</span>, getter=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 用于处理给定的key或者属性或者索引号的入参大于1个的情况，例如要获取每个Person数据对象的name属性的值、age属性的值、phone属性的值，所以有三个key：name、age、phone</span></span><br><span class="line">    defaults = defaults <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(keys) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 根据给定key的个数n，生成对应n个数据序列的迭代器，其实就是把要处理的数据序列变成迭代器后，并复制了多份,显然存在设计不合理的地方，拷贝多份数据，占用空间。</span></span><br><span class="line">        <span class="comment">#例如3个key对应生成3个迭代器 iters = (iterable,iterable,iterable)</span></span><br><span class="line">        iters = tee(iterable, <span class="built_in">len</span>(keys))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        iters = (iterable,)</span><br><span class="line">  <span class="comment">#结果为：[ifetch_single(data_list,&#x27;name&#x27;),ifetch_single(data_list,&#x27;age&#x27;),ifetch_single(data_list,&#x27;phone&#x27;)]    </span></span><br><span class="line">    iters = [ifetch_single(it, key, default=defaults.get(key, EMPTY), getter=getter) <span class="keyword">for</span> it, key <span class="keyword">in</span> <span class="built_in">zip</span>(iters, keys)]</span><br><span class="line">    <span class="keyword">return</span> iters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifetch</span>(<span class="params">iterable, key, *keys, default=EMPTY, defaults=<span class="literal">None</span>, getter=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 该函数就是通过判断需要获取1个属性还是多个属性来决定调用ifetch_single还是ifetch_multiple</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(keys) &gt; <span class="number">0</span>:</span><br><span class="line">        keys = (key,) + keys</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">list</span>, ifetch_multiple(iterable, *keys, defaults=defaults, getter=getter))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> ifetch_single(iterable, key, default=default, getter=getter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">iterable, key, *keys, default=EMPTY, defaults=<span class="literal">None</span>, getter=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 这个fetch其实多此一举，可以直接在ifetch返回处加入list方法即可。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(ifetch(iterable, key, *keys, default=default, defaults=defaults, getter=getter))</span><br></pre></td></tr></table></figure>
<h4 id="3-2-fetch的使用示例"><a href="#3-2-fetch的使用示例" class="headerlink" title="3.2 fetch的使用示例"></a>3.2 fetch的使用示例</h4><p>示例1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data_list = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;aro&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>,<span class="string">&#x27;phone&#x27;</span>:<span class="number">131</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bro&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">13</span>,<span class="string">&#x27;phone&#x27;</span>:<span class="number">132</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;cro&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">15</span>,<span class="string">&#x27;phone&#x27;</span>:<span class="number">143</span>&#125;,</span><br><span class="line">]</span><br><span class="line">result = fetch(data_list,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment">#[&#x27;aro&#x27;,&#x27;bro&#x27;,&#x27;cro&#x27;]</span></span><br><span class="line"></span><br><span class="line">result = fetch(data_list,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment">#[[&#x27;aro&#x27;,&#x27;bro&#x27;,&#x27;cro&#x27;],[10,13,15]]</span></span><br></pre></td></tr></table></figure><br>当了解fetch里面的调用了itemgetter的内部逻辑后，其实就是字典的取值：data[‘name’]，data[‘age’]</p>
<p>示例2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">data_list=[</span><br><span class="line">	R(<span class="string">&#x27;aro&#x27;</span>,<span class="number">10</span>),</span><br><span class="line">	R(<span class="string">&#x27;bro&#x27;</span>,<span class="number">12</span>),</span><br><span class="line">	R(<span class="string">&#x27;cro&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">]</span><br><span class="line">print(fetch(data_list,<span class="string">&#x27;name&#x27;</span>))      </span><br><span class="line"><span class="comment">#[&#x27;aro&#x27;, &#x27;bro&#x27;, &#x27;cro&#x27;]    </span></span><br></pre></td></tr></table></figure><br>当了解fetch里面的调用了attrgetter的内部逻辑后，其实就是使用内建方法getattr获取对象属性的值：[getattr(data1,’name’),getattr(data2,’name’),getattr(data3,’name’)]</p>
<p>示例3<br>自定义getter，这里用到了partial<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name, age, phone</span>):</span></span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self._data = &#123;<span class="string">&#x27;name&#x27;</span>: name, <span class="string">&#x27;age&#x27;</span>: age, <span class="string">&#x27;phone&#x27;</span>: phone&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._data.get(key)</span><br><span class="line">data_item = [</span><br><span class="line">    Person(<span class="number">1001</span>,<span class="string">&#x27;Aerk&#x27;</span>, <span class="number">22</span>, <span class="number">141</span>),</span><br><span class="line">    Person(<span class="number">1002</span>, <span class="string">&#x27;Berk&#x27;</span>, <span class="number">25</span>, <span class="number">151</span>),</span><br><span class="line">    Person(<span class="number">1003</span>, <span class="string">&#x27;Derk&#x27;</span>, <span class="number">21</span>, <span class="number">181</span>)</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_getter</span>(<span class="params">item,key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item.get(key)</span><br><span class="line">values = fetch(data_item, <span class="string">&#x27;name&#x27;</span>, getter=my_getter)</span><br><span class="line">print(values)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment"># [&#x27;Aerk&#x27;, &#x27;Berk&#x27;, &#x27;Derk&#x27;]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4、本文核心内容"><a href="#4、本文核心内容" class="headerlink" title="4、本文核心内容"></a>4、本文核心内容</h3><p>经过前面3个章节多个知识点的铺垫后，再来看本章节内容，则会更容易理解。本节内容对应前言第一部分：<br>wrap装饰器的调用过程：functools.wraps——&gt;partial——&gt;update_wrapper<br>先看看functools.wraps的示例。</p>
<h4 id="4-1-login-require的装饰器例子"><a href="#4-1-login-require的装饰器例子" class="headerlink" title="4.1 login_require的装饰器例子"></a>4.1 login_require的装饰器例子</h4><p>在Django的app开发中，一般会使用装饰器鉴权，大致如下结构<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 未使用functools.wraps</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrap</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于对外部的request做是否已经登录请求鉴权&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_wrap</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_require</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_blog_list</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取blog列表的function&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line">print(get_blog_list.__doc__)</span><br><span class="line">print(get_blog_list.__name__)</span><br><span class="line">print(get_blog_list.__qualname__)</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  用于对外部的request做是否已经登录请求鉴权</span></span><br><span class="line"><span class="comment"># inner_wrap</span></span><br><span class="line"><span class="comment"># login_require.&lt;locals&gt;.inner_wrap</span></span><br></pre></td></tr></table></figure><br>这里显然不符合需求，get<em>blog<em>list的<code>__doc__</code>、<code>__name__</code>、<code>__qualname__</code>被改成login<em>require里面闭包函数inner<em>wrap对应属性的值<br>这里如何保证被装饰函数get<em>blog<em>list的属性值不被改动呢？加入functools.wraps(func)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrap</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于对外部的request做是否已经登录请求鉴权&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_wrap</span><br><span class="line">print(get_blog_list.__doc__)</span><br><span class="line">print(get_blog_list.__name__)</span><br><span class="line">print(get_blog_list.__qualname__)</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取blog列表的function</span><br><span class="line">get_blog_list</span><br><span class="line">get_blog_list</span><br></pre></td></tr></table></figure><br>这次，get_blog_list的`__doc</em></em><code>、</code>__name</em></em><code>、</code>__qualname</em></em>`属性保持不变。</p>
<p>不使用functools.wraps(func)，也可以实现get_blog_list被装饰后，其属性值保持不变，通过setattr处理即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrap</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于对外部的request做是否已经登录请求鉴权&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    inner_wrap.__doc__=func.__doc__</span><br><span class="line">    inner_wrap.__name__=func.__name__</span><br><span class="line">    inner_wrap.__qualname__=func.__qualname__</span><br><span class="line">    <span class="keyword">return</span> inner_wrap</span><br><span class="line">    </span><br><span class="line"><span class="comment">#或者使用setattr设置属性值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_wrap</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;用于对外部的request做是否已经登录请求鉴权&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__doc__&#x27;</span>,func.__doc__)</span><br><span class="line">    <span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__name__&#x27;</span>,func.__name__)</span><br><span class="line">    <span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__qualname__&#x27;</span>,func.__qualname__)</span><br><span class="line">    <span class="keyword">return</span> inner_wrap</span><br><span class="line">print(get_blog_list.__doc__)</span><br><span class="line">print(get_blog_list.__name__)</span><br><span class="line">print(get_blog_list.__qualname__)    </span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取blog列表的function</span><br><span class="line">get_blog_list</span><br><span class="line">get_blog_list</span><br></pre></td></tr></table></figure><br>update_wrapper正是使用上述setter方式实现对原函数被装饰后，新函数属性和原函数属性和保持一致。<br>但在软件工程中，这种写法是过程式设计，初级的写法，无法被重用，因此需要使用更优雅的方式将这些逻辑封装打包，对外可以重用。</p>
<h4 id="4-2-functools-wraps的定义"><a href="#4-2-functools-wraps的定义" class="headerlink" title="4.2 functools.wraps的定义"></a>4.2 functools.wraps的定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wraps</span>(<span class="params">wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">          assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">          updated = WRAPPER_UPDATES</span>):</span></span><br><span class="line">    <span class="keyword">return</span> partial(update_wrapper, wrapped=wrapped,</span><br><span class="line">                   assigned=assigned, updated=updated)</span><br></pre></td></tr></table></figure>
<p>wraps里面调用partial，partial里面调用update_wrapper，应用在get_blog_list也就是：partial(update_wrapper, wrapped=get_blog_list)<br>接下来，先看看update_wrapper到底实现的什么功能</p>
<h4 id="4-3-update-wrapper的源码分析"><a href="#4-3-update-wrapper的源码分析" class="headerlink" title="4.3 update_wrapper的源码分析"></a>4.3 update_wrapper的源码分析</h4><p>以login_require的装饰器例子，wrapper就是inner_wrap函数，而wrapped则是get_blog_list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WRAPPER_ASSIGNMENTS = (<span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>,<span class="string">&#x27;__annotations__&#x27;</span>)</span><br><span class="line">WRAPPER_UPDATES = (<span class="string">&#x27;__dict__&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_wrapper</span>(<span class="params">wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                   wrapped,</span></span></span><br><span class="line"><span class="function"><span class="params">                   assigned = WRAPPER_ASSIGNMENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                   updated = WRAPPER_UPDATES</span>):</span></span><br><span class="line">                   </span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> assigned:</span><br><span class="line">        <span class="comment"># 将原函数指定的5个属性（__name__、__doc__等）更新到（注册到/覆盖到）新函数，使得原函数被装饰后，指定的5个属性也保不变。</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取原函数的属性值</span></span><br><span class="line">            value = <span class="built_in">getattr</span>(wrapped, attr)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将原函数的属性值更新到相应的新函数属性中</span></span><br><span class="line">            <span class="built_in">setattr</span>(wrapper, attr, value)</span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> updated:</span><br><span class="line">        <span class="comment"># 原函数的__dict__属性更新到（注册到/覆盖到）新函数的__dict__属性，从而实现原函数被装饰后其__dict__属性保持不变。</span></span><br><span class="line">        <span class="built_in">getattr</span>(wrapper, attr).update(<span class="built_in">getattr</span>(wrapped, attr, &#123;&#125;))</span><br><span class="line">    wrapper.__wrapped__ = wrapped</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><br>所以update_wrapper设计简约，实现了4.1章节内容所提如下内容的功能<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__doc__&#x27;</span>,func.__doc__)</span><br><span class="line"><span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__name__&#x27;</span>,func.__name__)</span><br><span class="line"><span class="built_in">setattr</span>(inner_wrap,<span class="string">&#x27;__qualname__&#x27;</span>,func.__qualname__)</span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-partial的源码分析"><a href="#4-3-partial的源码分析" class="headerlink" title="4.3 partial的源码分析"></a>4.3 partial的源码分析</h4><p>文章到了这里，对partial的了解将会更加深入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span>(<span class="params">func, *args, **keywords</span>):</span></span><br><span class="line">    <span class="comment">#对于login_require的装饰器例子，这里的func参数就是update_wrapper，args参数为空为:keywords就是wrapped=get_blog_list被装饰函数,assigned = WRAPPER_ASSIGNMENTS,updated = WRAPPER_UPDATES</span></span><br><span class="line">    <span class="comment"># 因为update_wrapper没有`func`属性，所以跳过这部分处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(func, <span class="string">&#x27;func&#x27;</span>):</span><br><span class="line">        args = func.args + args</span><br><span class="line">        tmpkw = func.keywords.copy()</span><br><span class="line">        tmpkw.update(keywords)</span><br><span class="line">        keywords = tmpkw</span><br><span class="line">        <span class="keyword">del</span> tmpkw</span><br><span class="line">        func = func.func</span><br><span class="line"></span><br><span class="line"><span class="comment">#   这里newfunc是整个partial设计为最巧妙的地方！！！乃至functools.wraps里面设计最为巧妙的环节。将新加入的位置参数和关键字参数追加到func里</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span>(<span class="params">*fargs, **fkeywords</span>):</span></span><br><span class="line">        <span class="comment">#wrapped=get_blog_list被装饰函数,assigned = WRAPPER_ASSIGNMENTS,updated = WRAPPER_UPDATES拷贝到newkeywords</span></span><br><span class="line">        newkeywords = keywords.copy()</span><br><span class="line">        newkeywords.update(fkeywords)</span><br><span class="line">        <span class="comment"># 对于login_require例子，这里fkeywords为空</span></span><br><span class="line">        <span class="keyword">return</span> func(*(args + fargs), **newkeywords)</span><br><span class="line"></span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure><br>当使用以下写法时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.wraps(<span class="params">func</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span></span></span><br></pre></td></tr></table></figure><br>就会触发partial调用newfunc，而newfunc被定义Wie函数，是可以被<code>__call__</code>的，它返回func(<em>(args + fargs), *</em>newkeywords)，func就是update_wrapper函数，args为空参数，fargs就是inner_wrapper函数，newkeywords就是wrapped=get_blog_list被装饰函数,assigned = WRAPPER_ASSIGNMENTS,updated = WRAPPER_UPDATES<br>所以以下这一小段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.wraps(<span class="params">func</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span></span></span><br></pre></td></tr></table></figure></p>
<p>就是转换为以下语句的调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update_wrapper(wrapper=inner_wrapper,wrapped=get_blog_list,assigned = WRAPPER_ASSIGNMENTS,updated = WRAPPER_UPDATES)</span><br></pre></td></tr></table></figure></p>
<p>4.3章节已经详细指出update<em>wrapper的作用：<br> 将原函数get<em>blog<em>list指定的5个属性（`<em>_name</em></em><code>、</code>__doc</em></em>`等）更新到（注册到/覆盖到）新函数inner_wrapper，使得原函数被装饰后，指定的5个属性也保不变。<br>这就是functools.wraps(func)的内部基于partial的实现逻辑</p>
<h4 id="4-4-再论partial"><a href="#4-4-再论partial" class="headerlink" title="4.4 再论partial"></a>4.4 再论partial</h4><p>partical的官方说明：</p>
<blockquote>
<p>functools.partial(func, <em>args, *</em>keywords)<br>Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. </p>
</blockquote>
<p>从英文的解释来看（不建议翻译为中文，直接理解英文更加准确），partial不应该翻译成“偏函数”，partial词意中：有不完整的意思，翻译成“待补全外部参数”的类函数对象貌似更贴切，<br>以下面例子说明<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y,z=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"><span class="comment"># 先给定1个位置参数和1个关键字参数，对于add函数，参数是不完整的，需要待后面补全多一个外部位置参数    </span></span><br><span class="line">add_15=partial(add,<span class="number">5</span>,z=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#这里add_15如果直接调用，会提示缺少一个位置参数，因此对于add_15，3就是待补全外部参数，</span></span><br><span class="line">print(add_15(<span class="number">3</span>)) <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure><br>以上的实际执行过程如下：<br>partial返回func(<em>(args + fargs), **newkeywords)，这里的func为add函数，args为(5,10)两个位置参数，3为后面补全的参数，就是fargs的值，newkeywords定义为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newkeywords = keywords.copy()</span><br><span class="line">newkeywords.update(fkeywords)</span><br></pre></td></tr></table></figure><br>add的z=10，就是keywords，fkeywords为空，因此newkeywords为{‘z’:10}<br>所以有以下等价链<br>`partial(add,5,z=10)&lt;===&gt;func(</em>(args + fargs), <em>*newkeywords)&lt;===&gt;add(</em>((5,)+(3,)),z=10)&lt;===&gt;add(5,3,z=10)`</p>
<p>从上面分析可以看出，paritial最大的用处就是基于某个原函数和原函数参数基础上生成一个”待补全外部参数新函数“，提供给该新函数的入参个数比原函数少了，得到高效简洁地调用指定函数，例如新函数add_15只需要提供1个参数即可，而原函数add需要提供3个参数。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/functool-wraps/" rel="tag"># functool.wraps</a>
              <a href="/tags/partial/" rel="tag"># partial</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/14/%E6%9E%84%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8Hive%20HA%E5%92%8C%E6%95%B4%E5%90%88HBase%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="构建高可用Hive HA和整合HBase开发环境（一）">
      <i class="fa fa-chevron-left"></i> 构建高可用Hive HA和整合HBase开发环境（一）
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/17/Pandas%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" rel="next" title="Pandas数据预处理的常用函数">
      Pandas数据预处理的常用函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">第一部分内容：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">第二部分内容：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">第三部分内容：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81python%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95-slots-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">1、python的魔法方法__slots__的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E3%80%81-slots%E6%96%B9%E6%B3%95%E4%BF%9D%E8%AF%81%E5%AE%9E%E4%BE%8B%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA-dict-%E6%96%B9%E6%B3%95"><span class="nav-number">0.1.</span> <span class="nav-text">1.1、 slots方法保证实例不会创建__dict__方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2%E3%80%81%E4%B8%BA%E4%BD%95%E5%88%97%E8%A1%A8%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E6%AF%94%E5%85%83%E7%BB%84%E5%A4%A7%EF%BC%9F"><span class="nav-number">0.2.</span> <span class="nav-text">1.2、为何列表占用空间比元组大？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81attrgetter-itemgetter%E7%B1%BB%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="nav-number"></span> <span class="nav-text">2、attrgetter&#x2F;itemgetter类的解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-attrgetter%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">2.1 attrgetter的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-attrgetter%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">2.2 attrgetter的内部实现：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-itemgetter%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">2.3 itemgetter的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-itemgetter%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">2.4 itemgetter的源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81broax-fetch%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">3、broax.fetch的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-fetch%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">3.1  fetch模块的源码简析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-fetch%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">3.2 fetch的使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%9C%AC%E6%96%87%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="nav-number"></span> <span class="nav-text">4、本文核心内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-login-require%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BE%8B%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">4.1 login_require的装饰器例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-functools-wraps%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">4.2 functools.wraps的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-update-wrapper%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">4.3 update_wrapper的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-partial%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">4.3 partial的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E5%86%8D%E8%AE%BApartial"><span class="nav-number">5.</span> <span class="nav-text">4.4 再论partial</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
