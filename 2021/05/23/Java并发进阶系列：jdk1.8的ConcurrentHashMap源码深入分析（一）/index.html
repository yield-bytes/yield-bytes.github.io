<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言虽然jdk1.7的CHM能够解决非阻塞高并发的读写情况，但它仍然不够理想，例如写并发度受限于Segment数组初始大小，一旦创建就无法再扩容并发度；如果key非常多且分布不均匀，例如都落在同一个Segment位置上，相当于多个线程竞争同一把“全局锁”，CHM“仿佛”退化为HashTable。此外，因为CHM的Segment上使用jdk1.7的HashMap，它的性能显然没有jdk1.8的Has">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（一）">
<meta property="og:url" content="https://yield-bytes.github.io/2021/05/23/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="前言虽然jdk1.7的CHM能够解决非阻塞高并发的读写情况，但它仍然不够理想，例如写并发度受限于Segment数组初始大小，一旦创建就无法再扩容并发度；如果key非常多且分布不均匀，例如都落在同一个Segment位置上，相当于多个线程竞争同一把“全局锁”，CHM“仿佛”退化为HashTable。此外，因为CHM的Segment上使用jdk1.7的HashMap，它的性能显然没有jdk1.8的Has">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ef0e55b37d5744cbb7f036ca5a19c6ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6455b8ed077d45548a4901bae17c44a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/dad538c261234249972fd48d844615ae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2021-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-09T13:49:23.637Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/ef0e55b37d5744cbb7f036ca5a19c6ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="https://yield-bytes.github.io/2021/05/23/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（一） | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/05/23/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-23T00:00:00+08:00">2021-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 21:49:23" itemprop="dateModified" datetime="2022-05-09T21:49:23+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然jdk1.7的CHM能够解决非阻塞高并发的读写情况，但它仍然不够理想，例如写并发度受限于Segment数组初始大小，一旦创建就无法再扩容并发度；如果key非常多且分布不均匀，例如都落在同一个Segment位置上，相当于多个线程竞争同一把“全局锁”，CHM“仿佛”退化为HashTable。此外，因为CHM的Segment上使用jdk1.7的HashMap，它的性能显然没有jdk1.8的HashMap强，jdk1.7resize扩容处理时只能单线程完成扩容操作，jdk1.7计算size方法可能要对每个Segment加阻塞锁，基于以上jdk1.7的CHM缺点，Doug Lea重新设计新版本的CHM，其源代码行数总共6312行，性能确实高了，但代价是代码逻辑的复杂度要高出很多。</p>
<p>理解本文所有源码分析以及相关技术都需要读者已经掌握1.8/1.7HashMap、1.7 CHM、Unsafe、CAS这些进阶知识，否则难以消化相关知识，可以提前阅读本博客相关文章：</p>
<p>（以下“CHM”表示ConcurrentHashMap简写）</p>
<h4 id="数据结构图示"><a href="#数据结构图示" class="headerlink" title="数据结构图示"></a>数据结构图示</h4><p>分为普通状态下（非扩容期间）和扩容期间</p>
<p>（1）CHM非扩容时，也即普通正常状态下的内部数据结构图：</p>
<p>可以看到跟jdk1.8的HashMap数据结构不同的地方：CHM用了一个称为TreeBin的节点作为桶位头节点，不是HashMap的TreeNode:<br><img src="https://img-blog.csdnimg.cn/ef0e55b37d5744cbb7f036ca5a19c6ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）CHM正在扩容时的内部数据结构图：</p>
<p>  可以看到正在扩容时的内部节点结构，数组尾部的一些桶位头节点放入了ForwardingNode节点。</p>
<a id="more"></a>
<p>  <img src="https://img-blog.csdnimg.cn/6455b8ed077d45548a4901bae17c44a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其实还有一个情况，以上两张图也没有展示出来：当CHM调用computeIfAbsent或者compute方法来插入系节点时，会在桶位上放置一个ReservationNode用于占位操作，本博客也有关于相关深度分析的文章</p>
<h4 id="重要成员变量说明"><a href="#重要成员变量说明" class="headerlink" title="重要成员变量说明"></a>重要成员变量说明</h4><h5 id="CHM重要常量"><a href="#CHM重要常量" class="headerlink" title="CHM重要常量"></a>CHM重要常量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"><span class="comment">// CHM数组长度最大值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHM数组初始化默认长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非最大2的整次幂数组长度：最大值-8。适用于toArray及其相关方法的场合</span></span><br><span class="line"><span class="comment">   * The largest possible (non-power of two) array size.</span></span><br><span class="line"><span class="comment">   * Needed by toArray and related methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为了兼容jdk1.7版本的CHM，在这里也给出相关成员变量的</span></span><br><span class="line"><span class="comment">   * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment">   * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于本文重点讨论fullAddCount，与扩容相关的常量在扩容文章给出。</span></span><br></pre></td></tr></table></figure>
<h5 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   HashMap的底层数组，注意它被volatile语义修饰:让table数组符合happen-before的规则，第一次put才会被初始化，长度为2的整数幂。</span></span><br><span class="line"><span class="comment">   * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下4个字段需要结合每小节内容去理解才能掌握其设计含义</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">   * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">   * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  设计最精妙的变量之一，对它实施位运算可以实现对CHM多种操作的控制</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 理解fullAddCount方法实现后才能明白此变量的意义。Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 理解fullAddCount方法实现后才能明白此变量的意义。Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>关于spread方法、tableSizeFor方法、comparableClassFor方法、compareComparables方法可以参考jdk1.8的HashMap，本文不再赘述。</p>
<p>put方法最适合作为源码分析入口，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;foo3&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>put方法内部调用的是putVal方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于CHM来说，put一个key到桶桶上会有以下几种情况：<br>1、table为空  2、桶位为空  3、桶位是一条冲突链 4、桶位是一个treeBin节点  5、桶位是一个<code>ForwardingNode</code>节点（表示有其他线程正在扩容） 6、桶位是一个<code>ReservationNode</code>节点：表示有其他线程正在调用computeIfAbsent或者compute方法来插入在该桶位插入节点，注意同一桶位的同一时刻，5和6是不会同时发生在，两个情况都是表达插入节点的逻辑。</p>
<p>因此put主体逻辑设计主要分为以下7个步骤：</p>
<p>1、如果tab为空，那么进行table初始化，该方法里面使用自旋+CAS让线程自己竞争初始化权</p>
<p>2、如果key所定位的桶位头节点f为空节点，线程使用CAS竞争将key节点插入到该桶位中</p>
<p>3、如果key所定位的桶位头节点hash为-1，也即表示该桶位的节点是个fwd节点，说明当前CHM正在扩容，那么当前put线程遇到这个节点会让去帮助扩容线程。</p>
<p>4、若不是以上1~3三种情况，那么先使用synchronized锁在该桶位，如果该桶位上一条冲突链，遍历该链插入key，如果该桶位上是一个treeBin，说明桶位已经是一棵红黑树，则按红黑树插入节点方法来插入key</p>
<p>5、判断key插入的链表长度是否大于等于8，来决定是否需要树化</p>
<p>6、将CHM的节点总数size加1（采用并发计数器累加）</p>
<p>7、判断节点总数是否达到扩容阈值而进行扩容</p>
<p>本文重点分析1-6的设计，第7点是扩容逻辑，由于扩容逻辑相对复杂、内容丰富，需要单独起一篇文章研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">      	<span class="comment">// f是key所定位的first头节点，fh：first头节点的Hash值，n:当前table数组长度，i：key定位到的桶位下标 </span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 1、如果tab为空，那么进行table初始化，initTable方法里面使用自旋+CAS让线程去竞争初始化权</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">      	<span class="comment">// 2、如果key所定位的桶位头节点f为空节点，线程使用CAS竞争将key节点插入到该桶位中，如果成功插入，则退出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 3、如果key所定位的桶位头节点hash为-1，说明当前CHM正在扩容，也即表示该桶位已被其他扩容线程迁移完数据，那么当前线程要进入扩容去帮助CHM扩容，注意不是帮助此桶位扩容！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">          	<span class="comment">// 4、若不是以上1~3三种情况，那么先使用synchronized锁在该桶位first头节点，从这里开始看出jdk1.8的CHM锁粒度比1.7要小，锁对象就是桶位本身</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">            <span class="comment">// 再次确认当前first头节点有没变更过，如果f已被改变，则回到for循环，重新按1-4流程再来一次</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            <span class="comment">// 4.1 如果当前桶位是一条冲突链表，遍历冲突链，并对binCount进行计数，如果存在key则覆盖，否则使用尾插法将key节点插入到链表尾部，此逻辑跟jdk1.8的类似</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      	<span class="comment">// 对冲突链表长度进行计数，用于树化判断</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          	<span class="comment">//来到链表尾部，尾插法</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  	<span class="comment">// 4.2 如果当前桶位头节点是一个TreeBin节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                      	<span class="comment">// 这里binCount是从2开始，解释参考本博客的ThreeBin读写锁机制分析的文章</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 判断冲突链表长度是否需要树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 5、将CHM的节数总数size加1（采用并发计数器累加）</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对jdk1.8 HashMap有深入研究的话，其实CHM的put本身设计逻辑并不难理解，而最复杂且精妙的设计反而是put方面里面的辅助方法：initTable方法、helpTransfer方法、transfer方法、addCount方法、fullAddCount方法，每一个方法无不体现JUC并发代码的精巧设计。</p>
<p>在前面的“CHM重要常量”，特意将以下三个变量放在此来说明它们的作用，分别代表三种节点的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;<span class="comment">// ForwardingNode（扩容期间需要用到）的哈希值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>;<span class="comment">// TreeBin节点（树化需要用到）的哈希值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>;<span class="comment">// ReservationNode节点（在computeIfAbsent、compute方法需要到）</span></span><br></pre></td></tr></table></figure>
<p>在put一个节点需要判断当前桶位节点类型，其中用到以下逻辑，其中只要头节点的哈希值fh&gt;=0，我们就可以认为它是一条链表（或者单节点），所以可以使用遍历方式去put入key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">		<span class="comment">// 4.1 如果当前桶位是一条冲突链表，遍历冲突链，并对binCount进行计数，如果存在key则覆盖，否则使用尾插法将key节点插入到链表尾部，此逻辑跟jdk1.8的类似</span></span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">// 对冲突链表长度进行计数，用于树化判断</span></span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 4.2 若头节点哈希值小于0，要么是fwd节点要么是ThreeBin节点</span></span><br><span class="line">   	    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<p>如果头节点哈希值小于0也即：-1，-2，-3，它们代表第三种类型节点，因此还需要进一步判断f节点是否为TreeBin节点，因此有</p>
<p><code>if (f instanceof TreeBin)</code>， 为何不设计为: <code>if(fh==TREEBIN)</code>，个人认为：</p>
<p>纯粹是为了源代码的可读性，因为我们put一个key到桶位前，更关心关心的是key所在桶位的“节点”是什么类型，当开发者看到<code>if (f instanceof TreeBin)</code>，自然就会理解为：如果当前桶位头节点是一个TreeBin节点。</p>
<p>而如果写成<code>if(fh==TREEBIN)</code>， 显然就没上面的理解来得更加“人性化、可读性高”</p>
<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><p>在重要成员变量里面，有一个叫sizeCtl的东西，在这里才能很好理解的它的作用:</p>
<p>initTable总体设计逻辑：例如线程A使用自旋+CAS去竞争table初始化权，CAS成功，则sizeCtl值会被改为-1表示“已成功抢到锁”，其他线程看到sizeCtl=-1就不再争抢初始化权而是让出cpu时间片。线程A接着完成new table初始化操作，并将sizeCtl设为当前table的扩容阈值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">  	<span class="comment">// 1、如果当前线程遇到table不为空，说明已经被其他线程完成了table初始化，直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 2、如果当前线程遇到sizeCtl=-1，说明其他线程早于当前线程将sc设为-1并正在table初始化，那么当前线程只能放弃初始化权</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">    <span class="comment">// 3、当前线程成功将sizeCtl用cas改为-1，表是：“我在对table正在初始化中”，注意SIZECTL是offset内存偏移地址，区别于sizeCtl</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 当前线程CAS成功后，再次判断tab是否为空，保证“以下操作仅由当前线程来初始化”的语义</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 4、创建新table</span></span><br><span class="line">                    <span class="comment">// sc已经是-1，因此这里的n将采用DEFAULT_CAPACITY，值为16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                  	<span class="comment">// 创建新的节点数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                  	table = tab = nt;</span><br><span class="line">                  	<span class="comment">// 计算新表扩容阈值，这里使用位计算，原理不变，还是newTable.length*0.75,</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//=&gt; n-n/4=&gt;n(1-0.25)=&gt;n*0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              	<span class="comment">// 保证初始化后，sizeCtl一定是新数组的扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><p>首先回想jdk1.8 HashMap的put方法：插入key后，对size自增1，如果size超过阈值则对HashMap底层table进行2倍扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// .......</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么addCount方法也是类似的设计思想：</p>
<p>先对size加1，然后根据size节点总数判断是否需要扩容。</p>
<p>但这里最复杂的地方在于：多线程并发情况下，如何正确实现对size原子加1？addCount及其内部的fullAddCount方法可以完成此任务，代价是：程序设计相对复杂（设计思路十分精巧，值得在日常项目引入），设计原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/dad538c261234249972fd48d844615ae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>当线程竞争不激烈情况下，通过自旋+cas对baseCount进行加1计数</p>
<p>当线程竞争十分激烈的情况下，有一部分线程很幸运能够抢到cas权力成功对baseCount加1，而剩下对baseCount加1cas失败的线程，它们就会创建一个CounterCells计数的数组，然后线程给对应自己的桶位Cell对象进行cas加1操作，这样一来就实现了“线程分流”，减少竞争。</p>
<p>最后统计总数时，将baseCount和CounterCells数组每个桶位的计数值累加起来，就是size的大小。该原理对应的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">// baseCount加上每一个桶位的value，最后就是总数sum</span></span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外一个有类似功能的类，专门设计给高并发计数的场景：LongAdder类（java.util.concurrent.atomic.LongAdder），它比AtomicLong原子计数器性能更强，本博客也给出相关性能测试。</p>
</blockquote>
<p>addCount骨架代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">  	<span class="comment">// 1、使用baseCount以及 CounterCell数组完成并发环境下的加1计数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x))&#123;...&#125;</span><br><span class="line">  	<span class="comment">// 2、判断CHM是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>)&#123;...&#125; </span><br></pre></td></tr></table></figure>
<p>完整源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 调用addCount(1L, binCount)，因此以下的入参x是1，check是binCount，</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	CounterCell是一个简单的内部类，它有一个value属性，用于被线程CAS加值操作</span></span><br><span class="line"><span class="comment">      	static final class CounterCell &#123;</span></span><br><span class="line"><span class="comment">        				volatile long value;</span></span><br><span class="line"><span class="comment">        				CounterCell(long x) &#123; value = x; &#125;</span></span><br><span class="line"><span class="comment">    		&#125;</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">      	<span class="comment">// as:存放如上图所示的CounterCell数组的临时变量，不同线程会对其不同段进行cas加1操作</span></span><br><span class="line">        <span class="comment">// b:baseCount变量</span></span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line"> <span class="comment">// 判断条件1:若counterCells数组不是空，说明已经有其他线程创建了它，也说明此刻出现线程竞争</span></span><br><span class="line"> <span class="comment">// 判断条件2: 当前线程对baseCount进行CAS加1操作失败，说明有其他线程竞争着baseCount，也说明此刻出现线程竞争</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"><span class="comment">// a变量：CounterCell数组某个桶位（也称某个段），v变量：CounterCell计数器里面value变量，m变量：CounterCell数组长度</span></span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">   <span class="comment">// uncontended线程之间有无激烈竞争标志，true：表示线程之间竞争还不激烈，false：表示线程之间竞争很激烈</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>; </span><br><span class="line">          	<span class="comment">// 注意这里4个判断条件</span></span><br><span class="line"><span class="comment">// 判断条件1：该条件执行是因为第1个if走的是判断条件2，说明多个线程在竞争cas操作baseCount，但是还没线程去创建CounterCell数组，那么当前线程可用fullAddCount完成加1操作。</span></span><br><span class="line"><span class="comment">// 判断条件2：该条件执行是因为第1个if走的是判断条件1，你想想，能调用length属性说明as是非空对象，也即as = counterCells) != null，但还未放入cell对象，此时as.length=0或者as.length-1&lt;0</span></span><br><span class="line"><span class="comment">// 判断条件3：该条件执行是因为第1个if走的是判断条件1，当前线程通过hash定位到counterCells数组对应桶位为空，说明当前线程接下来将可以在桶位上对CounterCell的value进行加1操作，将交由fullAddCount完成。</span></span><br><span class="line"><span class="comment">// 判断条件4： 当线程对它所在的桶位cas加1操作失败，说明已经有多个线程正在激烈竞争counterCells数组，接下来需要对counterCells数组扩容来分散（降低）线程竞争，将交由fullAddCount完成</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 线程定位到CounterCell数组的hash方法：ThreadLocalRandom.getProbe() &amp; m</span></span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"><span class="comment">// 多个线程同时竞争修改baseCount时，竞争失败的线程会执行fullAddCount，把x的值插入到counterCell数组对应的单元value里面。从这里也可以立即看出uncontended=false真实含义：表示当前多线程并发计数竞争激烈</span></span><br><span class="line"><span class="comment">// fullAddCount(1,uncontended=false),该方法能保证完成加1操作             </span></span><br><span class="line">                 fullAddCount(x, uncontended);</span><br><span class="line">              	<span class="comment">// 如果执行流执行到这里，说明fullAddCount已经完成加1操作，可以返回。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果check（binCount）&lt;=1,显然不需要扩容，可直接return结束</span></span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount(); <span class="comment">// 计算CHM的总节点数量，以便之后用s &gt;= (long)(sc = sizeCtl) 判断是否需要扩容</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h4><p>在源码中,第2500行，有一片代码段称为“Counter support”，作者指出它是用于分布式计数，fullAddCount方法改编自LongAdder and Striped64</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>fullAddCount方法的设计和实现是复杂且有精妙的，主要分为三个逻辑：</p>
<p>1、如果CounterCell数组不为空且数组里面已经有Cell对象，说明CounterCell数组已经被其他线程完成了创建，那么当前线程自然无需再创建它，而是尝试在当前下线程对应的空桶位放入Cell(1),相当于对value加1操作（如果桶位已有Cell对象，就使用cas对其加1计数）</p>
<p>2、在条件1不满足情况下，此时CounterCell数组为空表示还未被创建，那么当前线程把cellsBusy状态改为1（相当于加锁），并把CounterCell数组创建好，默认长度2，创建好后顺便在对应的桶位放入Cell(1)</p>
<p>3、桶位Cell加1操作失败、又没抢到CounterCell数组的创建权，总不能白跑一趟，因此到了这一步当前线程顺便再尝试对baseCount加1，若cas成功就可以直接break。</p>
<p>以上三个分支逻辑对应以下骨架代码：主分支1、主分支2、主分支3，其中主分支1的逻辑设计是最复杂的，它包含6个次分支：1.1到1.6。</p>
<p>这里一定要有一个基本常识：首先，线程的每次循环，只能执行3个主分支中的其中1个。另外一个基本常识：如果线程进入到主分支1，那么在1.1到1.6总共6个次分支中，线程也只能进入其中一个分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;   <span class="comment">// 主分支1，对应以上第1点</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.1</span></span><br><span class="line">        <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">        <span class="comment">// 1.2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">          wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1.3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 1.4</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">          collide = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 1.5</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">          collide = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1.6</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 完成CounterCell数组容量2倍扩容</span></span><br><span class="line">          collide = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;   &#125;   </span><br><span class="line">        <span class="comment">// 为当前线程生成新的hash值，用于下一次遍历，（希望它可以定位到另外一个桶位）</span></span><br><span class="line">        h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主分支2，对应以上第2点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cellsBusy==<span class="number">0</span> &amp;&amp; counterCells==as &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>))&#123;&#125;</span><br><span class="line">    <span class="comment">// 主分支3，对应以上第3点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲解完整源码之前，先了解cellsBusy“锁”的设计理论，cellsBusy本身只是一个volatile变量，而cellsBusy+CAS就可以用无锁方式实现“加锁功能”，线程就是用这种“轻锁机制”去完成CounterCell数组创建、将Cell对象放入桶位、CounterCell数组扩容，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 尝试“加锁”：若为true就相当于加锁成功，但该锁机制很轻量！</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// ② 临界区代码：完成CounterCell数组创建或者将Cell对象放入桶位或者CounterCell数组扩容</span></span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// ③ 释放“锁”</span></span><br><span class="line">     cellsBusy == <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>完整源码解析，以下for(;;)循环内部逻辑按前面提到的三个主分支进行分段解析，这是因为太多if和else if条件，需要分段解析才比较清晰其内部设计逻辑</p>
<h5 id="fullAddCount主分支1"><a href="#fullAddCount主分支1" class="headerlink" title="fullAddCount主分支1"></a>fullAddCount主分支1</h5><p>线程从addCount首次进入到fullAddCount时，假设先进入到分支1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// fullAddCount(x=1, uncontended=false)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h; </span><br><span class="line"> <span class="comment">// 如果当前线程hash值为0，则强制进行线程hash初始化处理，这里为何直接用Random方法呢？因为从ThreadLocalRandom字面也可以看出，这里是每个线程生成自己用的随机数，可以理解高并发下每个线程都有自己的随机数。</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// collide：表示线程定位到的Cell桶位是否有冲突，显然当CounterCell数组最后一个桶位都不空，说明已经出现线程操作数组冲突</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="comment">// as:CounterCell数组的临时变量，a：线程定位到桶位上的Cell对象，n: CounterCell数组的长度，v：桶位上的Cell对象的value属性       </span></span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 分支1、如果CounterCell数组已经被其他线程创建，接下来当前线程尝试占据桶位来完成加1的任务</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">// 1.1 线程所在的CounterCell桶位为空，有机会将Cell对象放入到桶位上</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 1.1.2 若cellsBusy未被加锁，则当前线程先创建一个Cell对象，准备放入桶位</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// 这里的x也就入参1，表示加1</span></span><br><span class="line">      <span class="comment">// 1.1.3 线程再次检查cellsBusy未被其他线程加锁且当前线程对cellsBusy加锁成功，那么接下来当前线程就可以尝试将Cell放入桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">// 1.1.4 Cell是否创建的标识，显然程序执行到这，Cell对象还未放入桶位</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">      <span class="comment">// cellsBusy标识锁并不是用于锁CounterCell数组本身，而是数组的某个桶位，CounterCell数组此时可能被线程扩容更改过，因此需要重新检查</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">      <span class="comment">// 如果counterCells数组还是一开始的那个数组且已被创建，这时当前线程可以放心将Cell对象放入线程hash定位到对应桶位，并将创建标识created置为true</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 当前线程操作完桶位放入cell对象后，释放cellsBusy锁</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">      <span class="comment">// 上面的CounterCell(1)能放入桶位，当然线程完成加1计数任务，可直接返回</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 源代码注释：Slot is now non-empty，说明线程未能成功将Cell(1)对象放在桶位，则再次回到for循环                        </span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">      <span class="comment">//  代码执行到这里时，说明分支1.1.2 的cellsBusy被其他线程加锁，自己没抢到更改权，此时先不认为是冲突，使用新hash值 h = ThreadLocalRandom.advanceProbe(h) 回到for循环重试</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 执行流下一条语句是执行h = ThreadLocalRandom.advanceProbe(h) 然后回到for循环，而不继续执行1.2次分支，这里很容易误解。</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure>
<h5 id="次分支1-2的设计目的："><a href="#次分支1-2的设计目的：" class="headerlink" title="次分支1.2的设计目的："></a>次分支1.2的设计目的：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1.2  // fullAddCount(long x=1, boolean wasUncontended=false)  </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br></pre></td></tr></table></figure>
<p>当前线程第1次遇到CounterCell数组不为空的情况下，且线程定位到的桶位不是空，并不急着安排线程对桶位上Cell对象进行cas加1计数。由于addCount方法调用fullAddCount入参wasUncontended时被设为false，因此线程会进入分支1.2，此时wasUncontended设为true表示当前线程暂时还没有遇到竞争，更新hash值（<code>h = ThreadLocalRandom.advanceProbe(h)</code>），再直接回到for进行第2次遍历重试。</p>
<font color=red>如果第2次遍历时，线程所定位的桶位又不为空，由于wasUncontended是true,因此会跳过次分支1.2，来到分支1.3：既然第2次定位到桶位又是不空，那么可以尝试去对桶位上Cell对象直接cas加1操作</font>

<blockquote>
<p>这里为何设计2次遍历？ 因为CounterCell首次被创建时容量为2，也即有<code>rs[0]</code>,<code>rs[1]</code>两个空桶位，假设线程第1次定位到<code>rs[0]</code>不为空（此时不能认为存在线程竞争导致的，只是<code>rs[0]</code>里面已经有Cell对象，这也是wasUncontende设为true的原因）接下来当然是再换线程的hash看看能不能定位到rs[1]桶位，如果恰好定位到rsp[1]是空桶位，那么线程就可以放入Cell对象。如果2次重试线程定位到的桶位都不为空，线程第3次遍历重试就会进入下文的次分支1.3（当然换完hash值也有可能又定位到rs[0]桶位）</p>
</blockquote>
<h5 id="次分支1-3的设计目的："><a href="#次分支1-3的设计目的：" class="headerlink" title="次分支1.3的设计目的："></a>次分支1.3的设计目的：</h5><p>如果第2次遍历时，线程所定位的桶位又不为空，由于wasUncontended是true，因此会跳过次分支1.2，尝试去对桶位上Cell对象直接cas加1操作，如果加1成功，线程就可以退出for循环了，如果失败就来到次分支1.4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 1.3</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h5 id="次分支1-5以及1-6的设计目的："><a href="#次分支1-5以及1-6的设计目的：" class="headerlink" title="次分支1.5以及1.6的设计目的："></a>次分支1.5以及1.6的设计目的：</h5><p>不妨先考察次分支1.4两个条件都不成立时的执行流：</p>
<p>这时线程就会跳过分支1.4去执行次分支1.5（因为collide默认为false，此时线程会进入分支1.5），将collide设为true，更新hash值，再直接回到for进行第3次遍历：</p>
<font color=green>**实际含义为：我（当前线程）第1次循环定位桶位不为空，第2次循环定位桶位也不为空，且对桶位上Cell对象cas加1失败，说明出现了明显线程竞争，那么第3次循环重试我就选择去扩容CounterCell数组**</font>

<font color=red>此时线程进行第3次循环时，因为collide已经在上一轮设为true，所以线程在第3次重试时会跳过次分支1.5，来到次分支1.6代码区，此时线程会将CounterCell数组做2倍扩容，然后将collide设为false，表示：既然都扩容了，说明有新空桶位可供操作，线程间的冲突得以解决，当前线程只需直接continue回到for重试，也即源码注释提到的： Retry with expanded table</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1.4</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">            collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"><span class="comment">// 1.5</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">            collide = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 1.6 占有cellsBusy锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                    <span class="comment">// 两倍扩容</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                        rs[i] = as[i];</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 冲突得以解决</span></span><br><span class="line">            collide = <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 扩容后肯定有空桶位，当然可直接回到for循环重试 </span></span><br><span class="line">          	<span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="次分支1-4的设计目的（最难理解的次分支）"><a href="#次分支1-4的设计目的（最难理解的次分支）" class="headerlink" title="次分支1.4的设计目的（最难理解的次分支）"></a>次分支1.4的设计目的（最难理解的次分支）</h5><p>该分支必须结合分支1.5和分支1.6的设计意义来理解：</p>
<p>分支1.6说明：线程一旦遇到明显的冲突，也即多次for循环定位到桶位不为空且对非空桶位的Cell对象cas加1失败（collide=true），那它会执行分支1.6逻辑：对CounterCell数组进行2倍扩容。那么会不会出现这样的情况：<font color=red>如果不断有后续更多线程也遭遇“冲突”，那么就有线程会无休止对CounterCell数组进行2倍扩容，有无停止扩容的条件</font>？</p>
<p>当然是有的，这就是次分支1.4的设计目的：防止CounterCell数组无限被扩容，如何实现？</p>
<p>次分支1.4有2个判断条件：</p>
<p>先看条件2：n &gt;= NCPU，也即CounterCell数组长度达到cpu个数时，就将collide 改为false，更新hash值，再直接回到for重试</p>
<p>而分支1.5、1.6逻辑都被会跳过不执行，下一次循环如果又来到分支1.4，因为n &gt;= NCPU成立，所以分支1.5、1.6逻辑再次被跳过不执行，之后的循环也类似处理。</p>
<p>所以：CounterCell数组停止的条件是，只要它的长度达到cpu个数，当前线程就不会再执行次分支1.6扩容的代码，而是从分支1.4将collide改为false，然后直接回到for循环、</p>
<h5 id="当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢"><a href="#当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢" class="headerlink" title="当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢"></a><font color=red>当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢</font></h5><p>显然，当CounterCell数组不再扩容时，那么空桶位很快会被线程们放满Cell对象，也即CounterCell数组数组没有空桶位，之后线程是这么执行的：</p>
<p>次分支1.1 <code>if ((a = as[(n - 1) &amp; h]) == null)</code>不再成立，所以会跳到次分支1.2，由于wasUncontended早已被设为true（请回去看次分支1.2的设计目的），次分支1.2也会被跳过，线程继续来到次分支1.3，此时线程会使用cas对Cell对象加1操作，若加成功就可以break，否则就来到次分支1.4，因为n=&gt;NCPU一直为true，将collide改为false，更新hash值，再直接回到for重试。</p>
<p><font color=red>简单总结：当CounterCell数组不再扩容时，且没有空桶位时，这些更新线程其实就会简化成以下的执行逻辑</font>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;  </span><br><span class="line">  	<span class="comment">// 当前线程使用cas对Cell对象加1操作，加成功就结束循环！，否则更新hash值重试</span></span><br><span class="line">		<span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">  	<span class="comment">// 更新当前线程hash值，以便下一次重试能够定位不同于本次的桶位</span></span><br><span class="line">        h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上简化代码可以看出，线程一定能在某个时刻在对应桶位的Cell对象上加1成功，然后退出循环，这也是fullAddCOunt设计真实目的：保证每个线程进入到fullAddCount到离开fullAddCount之前一定能够cas加1成功</p>
<p>此时，我们再来考察次分支1.4的条件1：</p>
<p>有了条件2的铺垫，其他条件1很好理解：counterCells != as，表明恰好有其他线程正在扩容CounterCell数组（导致as指向新的CounterCells数组对象），接下来可能在扩容后的CounterCell数组有更多的空桶位，那么当前线程就没必要去竞争扩容了，只需将collide 改为false，更新自己hash值，然后直接回到for循环重试看看能否运气好拿到新的空桶位。</p>
<h5 id="fullAddCount主分支2："><a href="#fullAddCount主分支2：" class="headerlink" title="fullAddCount主分支2："></a>fullAddCount主分支2：</h5><p>若CounterCell数组为空时（还未被创建），也即fullAddCount的主分支1会被跳过，当前线程会进入主分支2代码区，那么当前线程把cellsBusy状态改为1（相当于加锁），创建好一个默认长度为2的CounterCell数组，并顺便在对应的桶位放入Cell(1)完成加1计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">           U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line"><span class="comment">// 再次确认counterCells数组没有被其他线程改动过，如果被改动过，那么就跳过初始化并释放cellsBusy“锁”</span></span><br><span class="line">          <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line"><span class="comment">//  CounterCell数组就是在这里首次被创建</span></span><br><span class="line">              CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// h&amp;1结果：要么0要么1，也即将Cell(1)对象放在两个空桶位rs[0]、rs[1]中的任一个</span></span><br><span class="line">              rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">              counterCells = rs;</span><br><span class="line">              init = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 既然当前线程已经完成创建CounterCell数组，当然可以释放cellsBusy锁</span></span><br><span class="line">          cellsBusy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//当前线程完成CounterCell数组初始化后，因为在创建期间就完成Cell(1)加1计数，故可直接break退出。</span></span><br><span class="line">      <span class="keyword">if</span> (init)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="fullAddCount主分支3："><a href="#fullAddCount主分支3：" class="headerlink" title="fullAddCount主分支3："></a>fullAddCount主分支3：</h5><p> 主分支3：线程执行fullAddCount的主分支1桶位Cell加1操作失败，接着执行fullAddCount主分支2时又没抢到CounterCell数组的创建权，</p>
<p>那么当前线程总不能白跑一趟，因此到了这一步当前线程顺便尝试对baseCount做加加1计数（或者加x计数，x代表正负数都可以），若成功就退出，失败就回到for循环重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：从三个主分支的设计来看，主分支1无疑是最复杂的，因为判断多，条件多，理解起来象比较绕，需要用全局、逆向思维去分析，最好是先找到一个容易理解的分支，然后根据这个分支的实际含义来顺藤摸瓜再找到其他分支的实际含义</p>
<h5 id="从for循环退出的条件也可理解fullAddCount的内在设计逻辑"><a href="#从for循环退出的条件也可理解fullAddCount的内在设计逻辑" class="headerlink" title="从for循环退出的条件也可理解fullAddCount的内在设计逻辑"></a>从for循环退出的条件也可理解fullAddCount的内在设计逻辑</h5><p>有以上详细的源码解释后，考察线程for自旋退出的条件（成功计数加1的条件），其实就是对应前面提到的3个主分支。</p>
<p>1、第2552行，主分支1-次分支1.1，当前线程对应的桶位为null然后成功放入Cell对象时可退出for自旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>2、第2561行，主分支1-次分支1.3，进入CounterCell数组的操作逻辑，当前线程对非空桶位的Cell对象，使用CAS加1成功时可退出for自旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>3、第2597行，主分支2：当前线程创建默认长度2的CounterCell数组并选其中一个桶位放入Cell对象后可退出for自旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>4、第2600行，主分支3：当前线程以上尝试三种逻辑都失败时，总不能白跑一趟，再尝试去CAS对baseCount加1，成功时可退出for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br></pre></td></tr></table></figure>
<p>关于addcount完成计数加1后的CHM扩容逻辑分析，则单独在另外一篇博客给出，因为它的设计相对复杂，需要分析的内容较多。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/16/AQS%E6%A0%B8%E5%BF%83%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" rel="prev" title="Java高级主题：AQS核心源代码实现之共享模式的深入解析">
      <i class="fa fa-chevron-left"></i> Java高级主题：AQS核心源代码实现之共享模式的深入解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/19/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="next" title="Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（二）">
      Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA"><span class="nav-number">2.</span> <span class="nav-text">数据结构图示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">3.</span> <span class="nav-text">重要成员变量说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CHM%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8F"><span class="nav-number">3.1.</span> <span class="nav-text">CHM重要常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">重要成员变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initTable%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">initTable方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addCount%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">addCount方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fullAddCount%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">fullAddCount方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#fullAddCount%E4%B8%BB%E5%88%86%E6%94%AF1"><span class="nav-number">7.1.</span> <span class="nav-text">fullAddCount主分支1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A1%E5%88%86%E6%94%AF1-2%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">次分支1.2的设计目的：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A1%E5%88%86%E6%94%AF1-3%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="nav-number">7.3.</span> <span class="nav-text">次分支1.3的设计目的：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A1%E5%88%86%E6%94%AF1-5%E4%BB%A5%E5%8F%8A1-6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="nav-number">7.4.</span> <span class="nav-text">次分支1.5以及1.6的设计目的：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A1%E5%88%86%E6%94%AF1-4%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%88%E6%9C%80%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84%E6%AC%A1%E5%88%86%E6%94%AF%EF%BC%89"><span class="nav-number">7.5.</span> <span class="nav-text">次分支1.4的设计目的（最难理解的次分支）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%93CounterCell%E6%95%B0%E7%BB%84%E4%B8%8D%E5%86%8D%E6%89%A9%E5%AE%B9%E6%97%B6%EF%BC%8C%E8%BF%99%E4%BA%9B%E7%BA%BF%E7%A8%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E5%91%A2"><span class="nav-number">7.6.</span> <span class="nav-text">当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fullAddCount%E4%B8%BB%E5%88%86%E6%94%AF2%EF%BC%9A"><span class="nav-number">7.7.</span> <span class="nav-text">fullAddCount主分支2：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fullAddCount%E4%B8%BB%E5%88%86%E6%94%AF3%EF%BC%9A"><span class="nav-number">7.8.</span> <span class="nav-text">fullAddCount主分支3：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8Efor%E5%BE%AA%E7%8E%AF%E9%80%80%E5%87%BA%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B9%9F%E5%8F%AF%E7%90%86%E8%A7%A3fullAddCount%E7%9A%84%E5%86%85%E5%9C%A8%E8%AE%BE%E8%AE%A1%E9%80%BB%E8%BE%91"><span class="nav-number">7.9.</span> <span class="nav-text">从for循环退出的条件也可理解fullAddCount的内在设计逻辑</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
