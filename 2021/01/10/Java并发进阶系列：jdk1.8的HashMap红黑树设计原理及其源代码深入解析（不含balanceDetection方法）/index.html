<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在前面的《jdk1.8的HashMap源码分析》文章已经给出HashMap中数组+链表这一部分的内容，本篇文章将剩余的HashMap里面红黑树及其相关操作源码进行解析，内容较多，因此单独放在一篇文章进行讨论。 一、背景知识由于红黑树的插入、删除、扩容等操作相对复杂，因此建议先熟悉基本数据结构，例如二叉树、二叉搜索树及其关于它的查找、插入、删除操作、2-3节点树等。 本人假定看此文章的同学已经具备基">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：jdk1.8的HashMap红黑树设计原理及其源代码深入解析（不含balanceDetection方法）">
<meta property="og:url" content="https://yield-bytes.github.io/2021/01/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%90%ABbalanceDetection%E6%96%B9%E6%B3%95%EF%BC%89/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="在前面的《jdk1.8的HashMap源码分析》文章已经给出HashMap中数组+链表这一部分的内容，本篇文章将剩余的HashMap里面红黑树及其相关操作源码进行解析，内容较多，因此单独放在一篇文章进行讨论。 一、背景知识由于红黑树的插入、删除、扩容等操作相对复杂，因此建议先熟悉基本数据结构，例如二叉树、二叉搜索树及其关于它的查找、插入、删除操作、2-3节点树等。 本人假定看此文章的同学已经具备基">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/fabede1ed258deaa04d711f102d7b5bf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/28b15aac87162581e219cdc209754eea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/d221fc3aeb424debba9902bae4108be4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ca3c07cdf2c39a892f1f5d7a963772ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e10573191d904780f357d27bb40f70d4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/915d8acd26548da06e143a1a1814b12c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/423ded2b57d297bcd3a967ff4cf195ed.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4f07194c5e2e87cd6a3f1118a26ad236.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/fea7d8c802188ee3cd437720c5904ce3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ac2c930fa74c03ecf6dc7f3f4d6bf9bb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c503af25e3b52b74c0c0f43f441b4e0c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/dce014937aa2a390228cae4925884c50.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9b72bfae51723b12ae98034499d85d40.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/31bbd7b93dcdca32b0ae88f59b7caf21.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6e18ec36bf50014d068c07184a8ce632.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/23275e61977d3bea50a9790eaa85c7a5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c8a1a0adc6378f53c0c46d28ad4f274e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/0e8f76faf016539b015df70ce12d956f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/8cdb7771f30780b8432ee826e08545f3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4d1bb2e9977277e4ebcdacc804c16113.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/48c991c7e1bc5f96b2db3be75f604474.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6108e396d348e071561774e0b20a8319.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/dc9dbd03e88dfcbaf47c23f222121aaa.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c0a0c62bf109100aae0af626d0ff3eab.png">
<meta property="article:published_time" content="2021-01-09T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-09T13:40:37.651Z">
<meta property="article:tag" content="Java高级主题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/fabede1ed258deaa04d711f102d7b5bf.png">

<link rel="canonical" href="https://yield-bytes.github.io/2021/01/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%90%ABbalanceDetection%E6%96%B9%E6%B3%95%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：jdk1.8的HashMap红黑树设计原理及其源代码深入解析（不含balanceDetection方法） | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/01/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%90%ABbalanceDetection%E6%96%B9%E6%B3%95%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：jdk1.8的HashMap红黑树设计原理及其源代码深入解析（不含balanceDetection方法）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-10T00:00:00+08:00">2021-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 21:40:37" itemprop="dateModified" datetime="2022-05-09T21:40:37+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在前面的《jdk1.8的HashMap源码分析》文章已经给出HashMap中数组+链表这一部分的内容，本篇文章将剩余的HashMap里面红黑树及其相关操作源码进行解析，内容较多，因此单独放在一篇文章进行讨论。</p>
<h4 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h4><p>由于红黑树的插入、删除、扩容等操作相对复杂，因此建议先熟悉基本数据结构，例如二叉树、二叉搜索树及其关于它的查找、插入、删除操作、2-3节点树等。</p>
<p>本人假定看此文章的同学已经具备基本的数据结构知识，因此，关于红黑树的背景知识，这里不再累赘。</p>
<p>冷知识：红黑树为什么叫红黑？节点为什么被标记为红色和黑色， 可以改为蓝黄树、绿蓝树等吗？</p>
<blockquote>
<p>首先红黑树第一版在1972年由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Rudolf Bayer/3014716">Rudolf Bayer</a>发明，当时的学名是平衡二叉B树（symmetric binary B-trees），还不是被称为Red Black Trees。后来平衡二叉B树在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为现在版本的红黑树，他们之所以称之为“红黑”树，因为他们在研究这种树型数据结构过程中，需要在草稿纸上作图，用的恰是红色笔和黑色笔，红黑笔非常方便给相关节点标记颜色以便可视化设计相关逻辑，因此“红黑树”的红黑来源于此。</p>
</blockquote>
<h4 id="二、红黑树性质："><a href="#二、红黑树性质：" class="headerlink" title="二、红黑树性质："></a>二、红黑树性质：</h4><p>以下5个性质结合基于序列3，7，11，15，19，23，27，31，35，构成的一棵红黑树进行理解（这里给出的是有序序列，其实即使原序列是无序的， 被重构成为红黑树后，在红黑树也会形成二叉树搜索树的有序序列）</p>
<ul>
<li>1、树上的所有节点都被标记颜色，节点可以被标记位黑色，也可以被标记为红色，</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fabede1ed258deaa04d711f102d7b5bf.png" alt="32"></p>
<ul>
<li><p>2、root根节点必须被标记为黑色</p>
</li>
<li><p>3、所有的叶子节点都被标记为黑色，而且是NIL节点（需要注意：在JDK1.8的HashMap中，没有NIL命名的节点，也不是所谓的用null来表示NIL节点，在分析原理上可以将其当做虚构的null节点来对待，不影响结构，在平常作图中，NIL叶子节点可以忽略，在这里只是为了说明红黑树有NIL这种设计，因此在图中显式画出）</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/28b15aac87162581e219cdc209754eea.png" alt="33"></p>
<ul>
<li>4、每个被标记为红色的节点，它的两子节点一定都是黑色</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d221fc3aeb424debba9902bae4108be4.png" alt="35"></p>
<p>第4点也可以推出这样的结论：两个红节点一定不会直接相连，也即：红色节点与红色节点不能直接连接，或者说，红色节点的父节点及其子节点都不能是红色节点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ca3c07cdf2c39a892f1f5d7a963772ea.png" alt="36"></p>
<ul>
<li>5、任一节点到每个叶子结点的路径都包含数量相等的黑色节点，俗称：黑色平衡或者黑高，BlackHeight，如 下图的5条路径，每条路径经过黑色节点数都是2，NIL节点不作为黑色节点计数。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e10573191d904780f357d27bb40f70d4.png" alt="37"></p>
<a id="more"></a>
<p>以上5条特点也是红黑树的构成规则</p>
<p>优势：<br>（1）自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍，解决了二叉查找树容易不平衡的缺陷（在某些情况下会退化成一个线性结构），提高了读取性能（树越平衡，读取性能就越好）。<br>（2）虽然AVL树具有更高的读取性能（因为平衡性更好），但是当插入或删除节点时，AVL树要复杂很多，红黑树在插入或删除节点方面具有更高的效率。</p>
<p>在什么情况下需要变色，在什么情况下需要旋转？<br>在红黑二叉树中插入节点或删除节点后，如果破坏了红黑树的规则（也就是上述的特性），则需要对修改后的红黑树进行调整，使其重新符合红黑树的规则。首先是变色（往往需要多次变色，一次改变一个节点的颜色），当变色无法使得当前红黑树平衡时，就使用左旋或者右旋，旋转一次之后，然后再继续多次变色，如此反复循环，直到修改后的红黑树重新符合规则。</p>
<h4 id="三、为何要对红黑树进行变色、左旋、右旋操作？"><a href="#三、为何要对红黑树进行变色、左旋、右旋操作？" class="headerlink" title="三、为何要对红黑树进行变色、左旋、右旋操作？"></a>三、为何要对红黑树进行变色、左旋、右旋操作？</h4><p>1）首先若要生成一棵符合红黑树特点的红黑树，那么必然需要插入一定的节点（插入过程就包含了变色、左旋、右旋操作），从而构成一棵“固化平衡”的红黑树，如果已经构成这颗红黑树不再对其插入新节点或者删除节点，则无需再对其进行各种方式的调整。</p>
<p>2）对于一棵已经存在的红黑树，若要对其再插入新节点或者删除节点操作，那么这些操作可能会破坏红黑树的平衡约束，导致插入节点或者删除节点之后的“红黑树”不是一棵“平衡”的红黑树，那么怎么办？</p>
<p>这么办：根据红黑树的特点，<font color=red>需要额外设计一些补充操作来使得插入节点或删除节点之后的“不正常红黑树”变成正常的、平衡的红黑树，发明者经过研究，其实这些额外的操作无非就三种：变色、左旋、右旋</font></p>
<p>3）为何会有变色（颜色改变）操作？</p>
<p>举个特殊例子，对于序列3，7，11，15，19，23，27，31，35当插入首个节点3时。</p>
<p>如下图所示：</p>
<p>（需要明确的的一点是：红黑树的待插入节点必须先标记位红色。）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/915d8acd26548da06e143a1a1814b12c.png" alt="39"></p>
<p>这张图会让体现出：红黑树的平衡维护在视觉上好像也需要这样的变色操作。</p>
<p>4）为何会左旋操作？</p>
<p>在这里暂且不深入论证左旋操作，看下面的图简要说明：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/423ded2b57d297bcd3a967ff4cf195ed.png" alt="40"></p>
<p>可能有人会问，为何在最后需要将3节点黑色变成红色？可以保持红色吗？</p>
<p>将黑3改为红3，本质是为了这颗树看起来更加平衡，而且是黑色平衡，同时在未来的不断插入、删除节点条件下形成的红黑树也会持续保持“优良传统”的树平衡，</p>
<p>若节点3改为红色，在之后不断插入节点、不断调整红黑树结构的条件下最终得到的树将不是一棵符合红黑树特点的树，那么这个“无名树”也无法实现像红黑树的所有性能。</p>
<p>5）为何会右旋操作？</p>
<p>插入3节点，若不进行右旋，树的重心会偏向左边，看起来不平衡，通过右旋，树看起来平衡多了（其实是防止树结构变成长链表形状）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4f07194c5e2e87cd6a3f1118a26ad236.png" alt="41"></p>
<p>正是对一棵树建立“变色、左旋、右旋”的约束机制，使得该树结构符合我们期望的性能。</p>
<h4 id="四、红黑树左旋、右旋完整操作"><a href="#四、红黑树左旋、右旋完整操作" class="headerlink" title="四、红黑树左旋、右旋完整操作"></a>四、红黑树左旋、右旋完整操作</h4><p>第三节的内容则给出相对节点的结构，有助于理解红黑树是通过不断变色、左旋、右旋操作，以维持自身树的平衡，最终实现高效的查询、插入、和删除性能，因此掌握红黑树的5点特点对于红黑树所有操作才能真正理解。</p>
<p>在解释完整左旋和右旋操作前，先做以下基本约定，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fea7d8c802188ee3cd437720c5904ce3.png" alt="43">             </p>
<p>以下约定是从l节点、r节点的视角来看其他位置节点的角色，l：left的缩写，r：right的缩写</p>
<ul>
<li>pp节点：l节点、r节点的祖父节点（Grand parent node）</li>
<li>p节点：l节点、r节点的父节点（parent node）</li>
<li>l节点：p节点的左节点（或左子节点）</li>
<li>r节点：p节点的右节点（或右子节点）</li>
<li>ll节点：l节点的左子节点 </li>
<li>lr节点：l节点右子节点 </li>
<li>rl节点：r节点左子节点 </li>
<li>rl节点：r节点右子节点 </li>
</ul>
<h5 id="4-1-理解左旋"><a href="#4-1-理解左旋" class="headerlink" title="4.1 理解左旋"></a>4.1 理解左旋</h5><p>以下的左旋图示，就像有这样拟人化操作：</p>
<p>将r节点“提起来”放在p节点所在位置，将r的左子节点rl“剪下来”。将p节点“挂在”r节点左子节点位置。</p>
<p>前面被“剪枝”的rl节点“挂到”p节点的右子节点位置——可以这样节点理解为：拿多的一侧“补给”少的一侧，以使得树两边“重量”相对接近，从而构成比上一次更加平衡的红黑树结构。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ac2c930fa74c03ecf6dc7f3f4d6bf9bb.png" alt="42"></p>
<p>为何这样的操作是“可行的”的，首先红黑树本身具有二叉搜索树的一些特征：</p>
<p>左子树上所有结点的值均小于等于它的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/根结点/9795570">根结点</a>的值（若左子树不空时）</p>
<p>右子树上所有结点的值均大于等于它的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/根结点/9795570">根结点</a>的值（若右子树不空时）</p>
<p>从上图也可以观察出（只考察pp、p、r、rl节点），左旋前后四个节点排序保持不变：</p>
<p>左旋前：这四个节点值的大小排序为p&lt;=rl&lt;=r&lt;=pp`</p>
<p>左旋后：这四个节点值的大小排序为p&lt;=rl&lt;=r&lt;=pp`</p>
<p>或者有可以采用投影法——从上方垂直投影到下方的方法进行考察：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c503af25e3b52b74c0c0f43f441b4e0c.png" alt="44"></p>
<p>上图清晰说明左旋操作节点值排序不变，另外一个更为重要的收益则是：左旋操作竟然可以让树的两边更加平衡</p>
<p>左旋、右旋源码做的事情无非以下三类：</p>
<p>p节点下来后要和下方rl建立关系</p>
<p>r节点上去后要和上方pp建立关系</p>
<p>再把r节点和p节点建立关系，从而实现完整的关系链</p>
<p>源码解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在插入节点代码片段引用了左旋、右旋操作 root = rotateLeft(root, x = xp); </span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">  					<span class="comment">/*</span></span><br><span class="line"><span class="comment">  					r=p.right;</span></span><br><span class="line"><span class="comment">  					if(p !=null &amp;&amp; r !=null)&#123;</span></span><br><span class="line"><span class="comment">  					    </span></span><br><span class="line"><span class="comment">  					    1) p与rl建立关系：p的右节点r的左子节点rl变成p的右节点</span></span><br><span class="line"><span class="comment">  							p.right=r.left;</span></span><br><span class="line"><span class="comment">  							rl=r.left;</span></span><br><span class="line"><span class="comment">  							if(rl!=null) </span></span><br><span class="line"><span class="comment">  									rl.parent=p;</span></span><br><span class="line"><span class="comment">  							2) r与pp建立关系： p节点的父节点pp为空的情况，说明p本来就是根节点，旋转后，r变成根节点，若p原来是pp的左节点，则r取代p后也要保持左节点位置</span></span><br><span class="line"><span class="comment">  							// rl = p.right = r.left 看不懂？ 其实是这种表达式：a=b=1,也即a=1,b=1</span></span><br><span class="line"><span class="comment">  							r.parent=p.parent</span></span><br><span class="line"><span class="comment">  							pp=p.parent</span></span><br><span class="line"><span class="comment">  							if(pp ==null) </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                	root=r;</span></span><br><span class="line"><span class="comment">                	root.red=false;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">               </span></span><br><span class="line"><span class="comment">                if (pp.left=p) pp.left=r</span></span><br><span class="line"><span class="comment">  							else  pp.right=r</span></span><br><span class="line"><span class="comment">  							3)r与p建立关系：p作为r的左节点，r作为p的父节点</span></span><br><span class="line"><span class="comment">  								r.left=p</span></span><br><span class="line"><span class="comment">  								p.parent=r;</span></span><br><span class="line"><span class="comment">  					</span></span><br><span class="line"><span class="comment">  					&#125;</span></span><br><span class="line"><span class="comment">  					*/</span></span><br><span class="line">  					</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">              	<span class="comment">// 此类连续赋值变量写法一定要自行拆开多个，否则不容易理解代码逻辑</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 如果p节点为空说明现在是空树，直接返回root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">  				<span class="comment">// 返回根节点  因为根节点在旋转的过程中可能会改变 就需要返回改变后的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-2-理解右旋"><a href="#4-2-理解右旋" class="headerlink" title="4.2 理解右旋"></a>4.2 理解右旋</h5><p><strong>右旋：以某个点（h）旋转，旋转点(h)左节点的右子节点变为旋转点的左节点，旋转点之前的左节点变为父节点</strong></p>
<p>右旋的工作机制其实跟左旋一样，只不过方向相反，如下图所示，文字说明以及源码分析则不再累赘。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dce014937aa2a390228cae4925884c50.png" alt="45"></p>
<h4 id="五、插入红黑树节点"><a href="#五、插入红黑树节点" class="headerlink" title="五、插入红黑树节点"></a>五、插入红黑树节点</h4><h5 id="5-1-插入总体思路设计"><a href="#5-1-插入总体思路设计" class="headerlink" title="5.1 插入总体思路设计"></a>5.1 插入总体思路设计</h5><p>在解析插入红黑树节点及其自平衡处理前，先从put源码快速回忆HashMap插入一个元素过程：如下面注释的4种插入情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value,...</span></span></span><br><span class="line"><span class="function"><span class="params">				//......</span></span></span><br><span class="line"><span class="function"><span class="params">        //<span class="number">1</span>、如果key定位到空的桶位上，则直接在桶位放入该新节点           </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>)</span> &amp; hash]) </span>== <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2、如果插入的key刚好与桶位节点（头节点）的key相同，不做插入操作，在后面更新value即可</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">         <span class="comment">//3、如果插入的key与p哈希碰撞（当然key不等于p.key），且桶位节点p为红黑树节点，那么需要使用putTreeVal将key新节点插入到红黑树里面，这里是本节重点分析内容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//4、如果桶位上p是一条冲突链，进行冲突链插入、树化等操作</span></span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                      <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                              treeifyBin(tab, hash);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">         <span class="comment">//....</span></span><br></pre></td></tr></table></figure>
<p>对应第3种插入情况，插入的为红黑树节点，再来看看putTreeVal的内部主要3个逻辑：</p>
<p>1）待插入key节点恰好能在红黑树里面找到则返回该节点，否则进入2）步骤</p>
<p>2）待插入key节点不在红黑树里面，就需要找到合适的父节点p，再将key节点插入父节点p的左边或者右边</p>
<p>3) 红黑树新增key节点后需要对红黑树做自平衡操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">     <span class="comment">// 1) 遍历红黑树，找与待插入key相等的节点</span></span><br><span class="line">     	<span class="keyword">boolean</span> searched = <span class="keyword">false</span>;<span class="comment">//这个searched为true时表示待插入key节点能在红黑树里找到</span></span><br><span class="line">     	TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">           <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">               dir = -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">               dir = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 找与待插入key相等的节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line"> <span class="comment">// .......</span></span><br><span class="line">                   <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                       ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                       <span class="keyword">return</span> q;</span><br><span class="line">               &#125;</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">      <span class="comment">// 2) 如果1)前面未找到，说明该key为新节点，需要在红黑树里面找正确的位置父节点xp，在父节点xp左边或者右边新增一个该节点，双向链表也要同时新增该节点。</span></span><br><span class="line">           TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">           <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line"><span class="comment">// 此操作非常容易被忽略：由于红黑树还本身也是一条双向链表，当红黑树新增节点时，双向链表也要新增对应的新节点</span></span><br><span class="line">               TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">               <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                   xp.left = x; </span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   xp.right = x;</span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line">     <span class="comment">// 3) 收尾工作：代码执行到这里，说明已经在红黑树插入了新节点， 需对红黑树做平衡操作,moveRootToFront在后面的小节给出</span></span><br><span class="line">               moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap在put一个节点恰好put到红黑树里面的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(key,value)-&gt;putval-&gt;putTreeVal-&gt;balanceInsertion-&gt;moveRootToFront</span><br></pre></td></tr></table></figure>
<p>插入节点<code>putTreeVal</code>源码并不难理解，复杂的是后面的平衡处理：<code>balanceInsertion</code></p>
<h5 id="5-2-平衡操作的设计解析"><a href="#5-2-平衡操作的设计解析" class="headerlink" title="5.2  平衡操作的设计解析"></a>5.2  平衡操作的设计解析</h5><p>在第三节提到红黑树平衡操作就是“变色、左旋、右旋”，其实在<code>balanceInsertion</code>内部实现也可以看出这些关键字：</p>
<p><code>x.red = false</code>、<code>rotateLeft</code>、<code>rotateRight</code>，当然对应下面的问题：</p>
<p>插入节点后，在什么情况下需要变色？</p>
<p>插入节点后，在什么情况下需要左旋？</p>
<p>插入节点后，在什么情况下需要右旋？</p>
<p>插入节点后，在什么情况下需要进行以上多种组合操作？</p>
<p>当然，每种平衡处理都是基于这样的前提：</p>
<p>1、对于<code>balanceInsertion(root, x)</code>入参root引用，拿到这个root节点，说明就拿到了一棵红黑树，因此对root为根结点的红黑树施加平衡调整</p>
<p>2、对于<code>balanceInsertion(root, x)</code>入参x引用，这个节点x已经在<code>balanceInsertion</code>执行前完成了位置插入，一定要记着：节点x的位置插入，不是在<code>`balanceInsertion</code>里面完成！</p>
<p>为了能将原理分析和源码分析的节点标识一一对应，这里做了如下约定：</p>
<p>示意图的节点标识来源于源码balanceInsertion里面的临时TreeNode类型的引用：<code>TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr</code></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b72bfae51723b12ae98034499d85d40.png" alt="47"></p>
<p>x节点：新插入的节点，在<code>balanceInsertion</code>调用前，x已经完成了插入。</p>
<p>xp节点：插入节点x的父节点</p>
<p>xpp节点：插入节点x的祖父节点</p>
<p>xppl节点（x的左变叔叔节点）：若xp节点位于xpp右边（此时xppr就是xp），那么xppl节点就是x节点的左边叔叔节点，</p>
<p>xppr节点（x的右边叔叔节点）：若xp节点位于xpp左边（此时xppl就是xp），那么xppr节点就是x节点的右边叔叔节点</p>
<h5 id="5-3-balanceInsertion图解-源码分析"><a href="#5-3-balanceInsertion图解-源码分析" class="headerlink" title="5.3 balanceInsertion图解+源码分析"></a>5.3 balanceInsertion图解+源码分析</h5><p>有了5.2的基础知识铺垫，则能很好理解按分类讨论的方式去分析每种情况的平衡操作</p>
<h6 id="5-3-1-若原root节点是null时"><a href="#5-3-1-若原root节点是null时" class="headerlink" title="5.3.1 若原root节点是null时"></a>5.3.1 若原root节点是null时</h6><p>原root节点是null时说明是空红黑树，因此插入节点x就作为root节点：<code>root=x</code>，从红黑树特点可知，<code>balanceInsertion(root, x)</code>里面会对x进行变色操作<code>x.red=false</code>,平衡调整结束，并返回x节点，同时它也是root节点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/31bbd7b93dcdca32b0ae88f59b7caf21.png" alt="46"></p>
<p>该情况对应的源码片段（仅对应第一次循环的情况）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>; <span class="comment">// 插入节点x默认是红色节点</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; <span class="comment">// 若root为空树，这里的for循环执行一次就退出</span></span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;  <span class="comment">// 首先x节点putVal插入位置，x.parent若为null，说明x节点当前位于root节点位置，那么x就要被作为root节点看待</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>; <span class="comment">// 因为x已经作为root节点，需将x节点变为黑色</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//......</span></span><br></pre></td></tr></table></figure>
<h6 id="5-3-2-若原红黑树已经存在x节点时"><a href="#5-3-2-若原红黑树已经存在x节点时" class="headerlink" title="5.3.2 若原红黑树已经存在x节点时"></a>5.3.2 若原红黑树已经存在x节点时</h6><p>由于x节点已经存在，不需要插入，只需更新value或者直接返回即可，由于情况简单，无需给出图示</p>
<p>但需要注意的是：在红黑树找到相同的key节点是在<code>putTreeVal</code>实现的，而更新value是在putVal实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在红黑树找到相同的key是在`putTreeVal`实现的</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; </span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 1）在红黑树找到相同的key的节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">            		<span class="comment">//......    </span></span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line"><span class="comment">//更新value是在`putVal`实现的</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">						<span class="comment">//......</span></span><br><span class="line">  					<span class="comment">//(TreeNode&lt;K,V&gt;)p的说明，在前面p是Node&lt;K,V&gt;类型的普通节点，需要将其转为TreeNode&lt;K,V&gt;类型，以进行红黑树节点相关方法的调用</span></span><br><span class="line">						e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//......   </span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="comment">// 2）在1)找到的相同key的红黑树节点e上，对e更新value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">            <span class="comment">//......  </span></span><br><span class="line">            &#125;      </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="5-3-3-若插入节点x的父节点xp是黑色或者父节点xp就是根节点"><a href="#5-3-3-若插入节点x的父节点xp是黑色或者父节点xp就是根节点" class="headerlink" title="5.3.3 若插入节点x的父节点xp是黑色或者父节点xp就是根节点"></a>5.3.3 若插入节点x的父节点xp是黑色或者父节点xp就是根节点</h6><p>1）因为插入节点x的父节点xp是黑色，所以可以直接插入x节点，而且x插入到xp左子节点位置或者右子节点位置，都不会影响原红黑树平衡，因此<code>balanceInsertion(root, x)</code>无需做平衡操作，直接返回root节点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6e18ec36bf50014d068c07184a8ce632.png" alt="48"></p>
<p>2）若父节点xp就是根节点，显然xp一定黑色，所以也可以直接插入x节点，而且x插入到xp左子节点位置或者右子节点位置，都不会影响原红黑树平衡，因此<code>balanceInsertion(root, x)</code>无需做平衡操作，直接返回root节点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23275e61977d3bea50a9790eaa85c7a5.png" alt="49"></p>
<p>对应的源码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">  							<span class="comment">//如果x的父节点xp为黑色(!xp.red)，或者xp就是根节点(xpp=null)，由于x已经在balanceInsertion调用前完成了插入因此在这里直接返回root节点就行，无需调整平衡。</span></span><br><span class="line">                <span class="comment">// 注意：对于刚接触红黑树插入操作的同学，在这里可能容易有这样的误解“父节点xp为黑色，或者xp就是根节点，故在此处执行可以安排插入x节点的操作”。然而源码在这里并没有插入节点代码，而是直接返回root节点，这容易让人混淆。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) </span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-3-4-插入节点x的父节点xp是红色，x的叔叔节点（xppl-xppr）是红色"><a href="#5-3-4-插入节点x的父节点xp是红色，x的叔叔节点（xppl-xppr）是红色" class="headerlink" title="5.3.4 插入节点x的父节点xp是红色，x的叔叔节点（xppl/xppr）是红色"></a>5.3.4 插入节点x的父节点xp是红色，x的叔叔节点（xppl/xppr）是红色</h6><p>由于插入节点x的父节点xp是黑色的情况已经讨论过，那么剩下需要处理父节点xp为红色的情况，当x的叔叔节（xppl/xppr）是红色，分为以下两种情况，但这两种情况都可以用同一段代码处理：</p>
<p>1）x的父节点xp和x的右边叔叔节点xppr同为红色的情况（此时xp其实也是xppl）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c8a1a0adc6378f53c0c46d28ad4f274e.png" alt="50"></p>
<p>2）x的父节点xp和x的左边叔叔节点xppl同为红色的情况（此时xp其实也是xppr）</p>
<p>此情况的图跟1）情况是对称的，这里不再给出。</p>
<p>从上图也可以看出，不管x节点位于xp节点的左边还是右边，以及xp节点位于xpp的左边还是右边，两种情况都可以用以下同一段代码处理（代码和上图紧密结合才能理解深刻）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">          <span class="comment">// 代码执行到这里，说明xp是红色，如果xp节点是xpp的左子节点（xp=xppl）</span></span><br><span class="line">					<span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="comment">// 插入节点x的右边叔叔节点非空且为红色</span></span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="keyword">false</span>; <span class="comment">// 叔叔节点变黑</span></span><br><span class="line">                        xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点xp变黑</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">// 祖父节点xpp变红</span></span><br><span class="line">                        x = xpp; <span class="comment">//祖父节点xpp变红后，可能与xpp父节点xppp同为红色，违反红黑树平衡，因此需要通过for循环继续往上处理平衡。</span></span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-3-5-插入节点x的父节点xp是红色，x的叔叔节（xppl-xppr）是黑树或者NIL节点"><a href="#5-3-5-插入节点x的父节点xp是红色，x的叔叔节（xppl-xppr）是黑树或者NIL节点" class="headerlink" title="5.3.5 插入节点x的父节点xp是红色，x的叔叔节（xppl/xppr）是黑树或者NIL节点"></a>5.3.5 插入节点x的父节点xp是红色，x的叔叔节（xppl/xppr）是黑树或者NIL节点</h6><p>由于插入节点x的父节点xp是黑色的情况已经讨论过，那么剩下需要处理父节点xp为红色的情况，当x的叔叔节点（xppl/xppr）是黑色或者NIL节点，可分为以下四种情况</p>
<p>1）“左右同红”（xp位于xpp的左边且x位于xp的右边）</p>
<p>2）“左左同红”（xp位于xpp的左边且x位于xp的左边）</p>
<p>3）“右左同红”（xp位于xpp的右边且x位于xp的左边）</p>
<p>4）“右右同红”（xp位于xpp的右边且x位于xp的右边）</p>
<font color=red>此外，插入节点x的父节点xp为红色，根据红黑树红红节点不能直接连接的特点，可以推出插入节点x的祖父节点xpp一定存在且为黑色</font>

<p>具体如下</p>
<p>1）“左右同红”（xp位于xpp的左边且x位于xp的右边）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e8f76faf016539b015df70ce12d956f.png" alt="51"></p>
<p><code>balanceInsertion</code>对应的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.......</span></span><br><span class="line">	<span class="comment">// 父节点xp在“左”</span></span><br><span class="line">         <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">     					<span class="comment">//......</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 在外层if给出xp是xpp.left的前提下，x是xp.right，也即“左右同红”</span></span><br><span class="line">                 <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">      							<span class="comment">// 以xp作为旋转点进行左旋，会变成“左左同红”情况，如上图所示。这里返回root节点是为后面的if继续处理“左左同红”提供入口					</span></span><br><span class="line">                   <span class="comment">// 左旋后，x已变成xp的父节点，xp则变成x的左子节点								</span></span><br><span class="line">                     root = rotateLeft(root, x = xp); </span><br><span class="line">                   <span class="comment">// 由于左旋后，xp位置已经发生改变，因此需要将xp和xpp指向x新的父节点和祖父节点</span></span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">               </span><br></pre></td></tr></table></figure>
<p>2）“左左同红”（xp位于xpp的左边且x位于xp的左边）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8cdb7771f30780b8432ee826e08545f3.png" alt="52"></p>
<p><code>balanceInsertion</code>对应的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line"><span class="comment">//.......           				</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 在外层if给出xp是xpp.left的前提下,x是xp.left（也即左左同红情况）</span></span><br><span class="line">              <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点xp变黑</span></span><br><span class="line">                  <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; </span><br><span class="line">                      xpp.red = <span class="keyword">true</span>; <span class="comment">// 祖父节点xpp变红</span></span><br><span class="line">               <span class="comment">// 以xpp作为旋转点进行右旋，以实现本次循环中xpp、xp、x构成的三层子树黑色节点平衡。</span></span><br><span class="line">                      root = rotateRight(root, xpp); </span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>3）“右左同红”（xp位于xpp的右边且x位于xp的左边）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4d1bb2e9977277e4ebcdacc804c16113.png" alt="59"></p>
<p><code>balanceInsertion</code>对应的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 					<span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">          <span class="comment">// 处理&quot;“左右同红”、“左左同红”情况</span></span><br><span class="line">          &#125;						</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//运行到这里，说明xp=xpp.right</span></span><br><span class="line">              <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">// 在xp=xpp.right的前提下，x是xp.left，也即（“右左同红”）</span></span><br><span class="line">   				<span class="comment">// 以xp作为旋转点进行右旋，会变成“右右同红”情况，如上图所示。这里返回root节点是为后面的if继续处理“右右同红”提供入口					</span></span><br><span class="line">          <span class="comment">// 右旋后，x已变成xp的父节点，xp则变成x的右子节点，如上图所示			                            </span></span><br><span class="line">                	root = rotateRight(root, x = xp);</span><br><span class="line">                  xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<p>4）“右右同红”（xp位于xpp的右边且x位于xp的右边）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/48c991c7e1bc5f96b2db3be75f604474.png" alt="54"></p>
<p><code>balanceInsertion</code>对应的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left))&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">// 处理&quot;“左右同红”、“左左同红”情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//运行到这里，说明xp=xpp.right，也即xp是xpp的右子节点，如上图所示              </span></span><br><span class="line">        <span class="comment">//......                  </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line"><span class="comment">// 处理&quot;“右左同红”情况</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// 在xp=xpp.right前提下，x=xp.right，也即x节点是xp的右子节点，对应“右右同红”情况</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>; <span class="comment">// 将xp节点变黑</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123; </span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//将xpp节点变红后，以xpp作为旋转点进行左旋，以实现本次循环中xpp、xp、x构成的三层子树黑色节点平衡。</span></span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<p>到此已完成<code>static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</code> 红黑树插入的所有情况平衡调整的源码分析，这部分内容相对核心，摸透了红黑树插入平衡的工作原理，才能有助于快速理解TreeNode内部其他方法的内部实现，具体见后面的章节</p>
<h4 id="六、关于链表树化的处理：同时理解treeifyBin、treeify、moveRootToFront方法"><a href="#六、关于链表树化的处理：同时理解treeifyBin、treeify、moveRootToFront方法" class="headerlink" title="六、关于链表树化的处理：同时理解treeifyBin、treeify、moveRootToFront方法"></a>六、关于链表树化的处理：同时理解treeifyBin、treeify、moveRootToFront方法</h4><p>在前面的一篇HasHMap源码解析的文章里，没有给出treeifyBin和treeify的源码解析，因为这两个方法重点是解决构建红黑树，因此适合放在本文且适合放在本节</p>
<p>分析思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(key,value)--&gt;putVal--&gt;单向冲突链达到树化阈值8--&gt;treeifyBin--&gt;table达到最小树化容量阈值64--&gt;单向冲突链转为双向冲突链--&gt;使用treeify基于双向冲突链构建一棵红黑树--&gt;moveRootToFront</span><br></pre></td></tr></table></figure>
<p>这里有一个很容易理解有误的地方：</p>
<p>很多HasHMap源码文章会跟你说——“若某个桶位上的冲突链节点数量达到8个，则调用treeifyBin方法将链表转换为红黑树”，其实这样的描述很容易误导人，而且漏了一个非常重要的信息。若想真正理解这个重要的信息，需从treeifyBin方法的实现开始着手理解：treeifyBin`方法有3个作用，见如下源码说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 作用1：虽然putVal出现冲突链节点达到8个，但如果table数组长度小于64，则选择扩容操作，而不是进行构建红黑树</span></span><br><span class="line">    <span class="comment">// MIN_TREEIFY_CAPACITY:冲突链转为红黑树的最小数组容量，默认64</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">    <span class="comment">// 作用2：如果putVal出现冲突链节点达到8个且table数组长度达到64，则先将单向链转为双向链，而且双向链的节点从Node类型转为TreeNode类型      </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              	<span class="comment">// 将Node类型节点转为TreeNode类型节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里可以看到使用TreeNode的prev和next构建一条双向链表，节点顺序和单向链表一样</span></span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 作用3：以双向链为基础构建一棵红黑树，hd是双向链表的头节点，也是原单向链表的头节点</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>显然<code>hd.treeify(tab)</code>才是真正构建红黑树的核心方法，下面是简略代码流程说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 1) 外循环每次从双向链表取出一个节点</span></span><br><span class="line">       <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">		<span class="comment">// .......</span></span><br><span class="line">			<span class="comment">// 2) 将1)取出的节点插入到以root为根节点的红黑树，插入的位置需要遍历树才能找到，因此内层有for循环</span></span><br><span class="line">               <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line">     <span class="comment">// 3) 插入节点后，对红黑树做平衡处理</span></span><br><span class="line">                       root = balanceInsertion(root, x);</span><br><span class="line">                 			<span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">     <span class="comment">// 4) 当双向链表的8个节点都构建好了红黑树之后，需要做以下操作：</span></span><br><span class="line">       moveRootToFront(tab, root);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>综合treeifyBin、treeify、moveRootToFront这三个方法的设计思想，下面以table桶位3上一条单向冲突链被树化为红黑树作为例子进行图解：</p>
<p>约定：table的长度大于等于64，按HashMap源码的hash方法和桶位的计算方法，可以推出，插入3、67、131、195、259、323、387、451这8个节点，将在桶位index=3上形成单向冲突链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBinIndex</span><span class="params">(Object key,<span class="keyword">int</span> tableSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash(key) &amp; (tableSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且单向冲突链表达到树化的条件，全过程如下图所示，务必认真读懂该图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6108e396d348e071561774e0b20a8319.png" alt="56"></p>
<p>从上图也可以看出，其实红黑树结构也包含了一条双向链表，TreeNode设计确实巧妙，moveRootToFront解释了为何HashMap1.8在红黑树处理中采用双向链表的本质原因！</p>
<p>注意：若没有上图或者前面的解析作为铺垫，对于moveRootToFront的Root容易产生以下误解：</p>
<p>将红黑树的根节点移到前面？这里是指移动到“什么”的前面？</p>
<p>将双向链表的根节点移动前面？双向链原根节点（头节点）不是一直都在前面了吗，为何还再次需要移动？</p>
<p>正确的理解情况参考上图：</p>
<p>插入节点后红黑树的根节点不一定是双向链表的根节点，为了保证桶位上头节点table[i]即是红黑树根节点，也是双向链表的头节点，需要在插入节点后，对双向链表执行moveRootToFront操作。</p>
<p>moveRootToFront操作在HashMap源码的以下三个地方出现：</p>
<p>1) treeify，构建完红黑树之后操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveRootToFront(tab, root);</span><br></pre></td></tr></table></figure>
<p>2) putTreeVal，插入一个节点后，可能触发红黑树平衡操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveRootToFront(tab, balanceInsertion(root, x));</span><br></pre></td></tr></table></figure>
<p>3) removeTreeNode，在红黑树上删除一个节点，可能触发红黑树平衡操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveRootToFront(tab, r);</span><br></pre></td></tr></table></figure>
<p>有以上“重磅设计原理”的铺垫后，下面关于treeifyBin、treeify、moveRootToFront具体源码的理解则能达到“水到渠成”效果。</p>
<p>（很多关于HashMap的红黑树源码文章会将treeifyBin、treeify、moveRootToFront三者割裂来分析，这会破坏关于红黑树全局设计原理的关联理解）</p>
<h6 id="6-1-treeifyBin"><a href="#6-1-treeifyBin" class="headerlink" title="6.1 treeifyBin"></a>6.1 treeifyBin</h6><p>putVal在单向链表尾部插入节点后，若该单向链表长度达到8，则调用treeifyBin方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dc9dbd03e88dfcbaf47c23f222121aaa.png" alt="58"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span>                         			<span class="comment">// ......</span></span></span><br><span class="line"><span class="function">												<span class="title">if</span> <span class="params">(binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function">                            <span class="title">treeifyBin</span><span class="params">(tab, hash)</span></span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  			<span class="comment">/*入参说明：</span></span><br><span class="line"><span class="comment">  			Node&lt;K,V&gt;[] tab：HashMap的数组，已经有数据</span></span><br><span class="line"><span class="comment">  			int hash：插入到单向链表尾部节点的hash值，（新插入节点的hash值）</span></span><br><span class="line"><span class="comment">  			*/</span></span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 构建双向链表的头节点head和尾部节点tail的临时引用</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 将单向链表的Node类型转为TreeNode类型</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">// 第一次循环时，tl指向肯定为null</span></span><br><span class="line">                    hd = p; <span class="comment">// 将第一次遍历的节点设为双向链表头节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="comment">// 新节点插入到双向链表尾部，并建立前后驱关系</span></span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p; <span class="comment">// 将tl引用指向双向链表新插入的尾部节点</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 遍历单向链表每个节点，直到e指向null，则完成将单向链表变成双向链表的调整</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)  <span class="comment">// 将双向链表的头部节点放在桶位上</span></span><br><span class="line">                hd.treeify(tab); <span class="comment">// 以桶位上的双向链表为基础构建红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-2-treeify"><a href="#6-2-treeify" class="headerlink" title="6.2 treeify"></a>6.2 treeify</h6><p>treeify被调用的时机：<code>putVal--&gt;treeifyBin--单向链表转双向链表hd--&gt; hd.treeify(tab);</code></p>
<p>设计思想</p>
<ul>
<li><p>1） 外层for循环：每次从双向链表取出一个节点x；内层循环：遍历红黑树找到x可以插入的位置并进行平衡调整。</p>
</li>
<li><p>2）外层for循环结束：说明双向链表的所有节点都被放到红黑树位置上，完成了构建红黑树。</p>
</li>
<li><p>3)  收尾工作：插入平衡调有左旋和右旋操作，<font color=red>这些可能操作可能让引起红黑树的root节点恰好没有位于双向链表的头部</font>，执行moveRootToFront(tab, root)，使得“红黑树的root节点恰好位于双向链表的头部”</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span>    </span></span><br><span class="line"><span class="function">		<span class="comment">// 桶位上的单向链表（冲突链）节点数量达到8，则调用treeifyBin</span></span></span><br><span class="line"><span class="function">		<span class="title">if</span> <span class="params">(binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span>  </span></span><br><span class="line"><span class="function">                      <span class="title">treeifyBin</span><span class="params">(tab, hash)</span></span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)  <span class="comment">// 将双向链表的头部节点放在桶位上</span></span><br><span class="line">                hd.treeify(tab); <span class="comment">// 以桶位上的双向链表为基础构建红黑树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正构建红黑树的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">  					<span class="comment">// 外层循环：第一次循环取出的节点，由hd.treeify(tab)可知，this节点就是双向链表的头节点hd</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 先保存当前处理节点的next节点，用于外层循环的下一次遍历</span></span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//外层循环第一次会执行此逻辑</span></span><br><span class="line">                  <span class="comment">// 首次建树，root肯定为空，直接将外层第一次取出的节点作为新建红黑树的root节点，并设为黑色</span></span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 树不为空时的处理流程，对应外层循环第二次以及以后的遍历</span></span><br><span class="line">                    K k = x.key; <span class="comment">// 来自双向链表的当前处理x节点的key</span></span><br><span class="line">                    <span class="keyword">int</span> h = x.hash; <span class="comment">// 来自双向链表的当前处理x节点的hash</span></span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">// 比较大小的Class泛型kc变量，临时变量</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">// 内层循环：遍历树以找到x合适的插入位置</span></span><br><span class="line">                  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">                  	假设当前遍历到树的节点p，比较待插入x节点和p节点的hash值，看谁大，</span></span><br><span class="line"><span class="comment">                  	若x小于等于p，x则插入到p节点左边位置；如果x大于p，x则插入到p节点右边位置。</span></span><br><span class="line"><span class="comment">                  	比较大小的思路：</span></span><br><span class="line"><span class="comment">                  	1）先用双方hash值比较，若hash相等，则调用用户自定义key的Comparable来比较</span></span><br><span class="line"><span class="comment">                  	2）以上方式实在无法将x和p比较大小，则使出终极大招：tieBreakOrder里面系统层面</span></span><br><span class="line"><span class="comment">                  	System.identityHashCode(a) &lt;= System.identityHashCode(b) ？</span></span><br><span class="line"><span class="comment">                  	*/</span></span><br><span class="line">                    <span class="comment">// 以下的源码不再一行一行给出，理解“比较大小的设计思想”后，即可明白。</span></span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) || <span class="comment">// 见后面小节分析</span></span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) <span class="comment">// 见后面小节分析</span></span><br><span class="line">                          <span class="comment">// tieBreak直接翻译为：平分决胜局。运行到这里，一定会分出x和p之间谁大。</span></span><br><span class="line">                            dir = tieBreakOrder(k, pk); </span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          	<span class="comment">// p作为x的父节点，且将x放在左子节点或者右子节点</span></span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            <span class="comment">// x节点插入完成后，进行红黑树平衡操作</span></span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 内层循环完成了本次节点的插入和红黑树平衡调整后，跳出循环，继续处理来自外层循环输送的双向链表下一个节点。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 运行到这里，说明双向链表的所有节点都被放到红黑树位置上，完成了构建红黑树。</span></span><br><span class="line">   					<span class="comment">// 使红黑树的root节点恰好位于双向链表的头部</span></span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-3-moveRootToFront"><a href="#6-3-moveRootToFront" class="headerlink" title="6.3 moveRootToFront"></a>6.3 moveRootToFront</h6><p>调用该方法说明双向链表里的某个节点一定是红黑树的root节点，若恰巧该红黑树root节点不是位于双向链表头部，则需将该root节点移到双向链表头部并调整其他节点（first、rp、rn）前后指向 ，如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c0a0c62bf109100aae0af626d0ff3eab.png" alt="57"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">						<span class="comment">//......</span></span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">  				  <span class="comment">/* 入参说明：</span></span><br><span class="line"><span class="comment">  				  Node&lt;K,V&gt;[] tab：HashMap的table数组，已经有数据</span></span><br><span class="line"><span class="comment">  				  TreeNode&lt;K,V&gt; root：某个桶位上红黑树的根节点</span></span><br><span class="line"><span class="comment">  				  */</span></span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">         		<span class="comment">// 若root为空或者table为空，则无需处理，若root不为空,外面传入的root节点一定是红黑树的根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	</span><br><span class="line">             <span class="comment">// 利用红黑树根节点的hash值定位桶位索引，从而找出双向链表的头节点</span></span><br><span class="line">                <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">             <span class="comment">// 这里tab[index]桶位取出的是双向链表的头节点，显然该头节点的hash值和红黑树root节点hash值相同,但两者的（key，value）不一定相同</span></span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; <span class="comment">// 注意first节点代表一条双向链表</span></span><br><span class="line">             <span class="comment">// 如果当前桶位上双向链表的头节点不是红黑树root节点，需将当前桶位设为红黑树root节点</span></span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                  	<span class="comment">// root为TreeNode类型，具有prev和next字段</span></span><br><span class="line">                    Node&lt;K,V&gt; rn; <span class="comment">// 红黑树root节点的next节点</span></span><br><span class="line">                    tab[index] = root; <span class="comment">// 将当前桶位设为红黑树root节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;<span class="comment">// 红黑树root节点的prev节点</span></span><br><span class="line">                  	<span class="comment">// rn为root节点的next节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">// 如果红黑树root节点不是位于原双向链表的尾部</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp; <span class="comment">// 将rn前驱指向红黑树root节点的prev节点</span></span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="keyword">null</span>) </span><br><span class="line">                        rp.next = rn; <span class="comment">// 将rp后驱指向红黑树root节点的next节点</span></span><br><span class="line">                  	<span class="comment">// 以上流程完成了将rp-root-rn 变成rp-rn链接</span></span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 若原双向链表的first节点不为空</span></span><br><span class="line">                        first.prev = root;  <span class="comment">// 原双向链表的first节点的前驱指向红黑树root节点</span></span><br><span class="line">                    root.next = first; <span class="comment">//将first双向链表挂在root节点后面</span></span><br><span class="line">                    root.prev = <span class="keyword">null</span>; <span class="comment">// 红黑树root节点此时成为双向链表头节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-4-本节接6-2的treeify内容：比较x节点和p节点大小"><a href="#6-4-本节接6-2的treeify内容：比较x节点和p节点大小" class="headerlink" title="6.4 本节接6.2的treeify内容：比较x节点和p节点大小"></a>6.4 本节接6.2的treeify内容：比较x节点和p节点大小</h6><p>从双向链表取出一个x节点，若插入红黑树合适位置，就需要遍历红黑树找到一个叶子节点p，看看x与p谁大：在“比较”这件事情上，用了三个方法：comparableClassFor、compareComparables、tieBreakOrder：</p>
<p>comparableClassFor、compareComparables的使用时基于用户自定义了key对象的Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;                        </span><br><span class="line">												<span class="comment">//......</span></span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  <span class="comment">// 这里k换成x.key更加直观，如果key未实现comparable的比较方法</span></span><br><span class="line">                                  (kc = comparableClassFor(x.key)) == <span class="keyword">null</span>) || </span><br><span class="line">                                 <span class="comment">// 这里k换成x.key、pk换成p.key更加直观</span></span><br><span class="line">                                  (dir = compareComparables(kc, x.key, p.key)) == <span class="number">0</span>) </span><br><span class="line">                          <span class="comment">// tieBreak直接翻译为：平分决胜局。运行到这里，一定会分出x和p之间谁大。</span></span><br><span class="line">                            dir = tieBreakOrder(k, pk); </span><br><span class="line">                    		<span class="comment">//......</span></span><br></pre></td></tr></table></figure>
<p>这里<code>comparableClassFor(Object x)</code> 入参x表示key，不是指代前面提到的双向链表取出的x节点。该方法用于取出key对象的“Class实例”用于后面的比较，若用户自定义key对象实现了Comparable接口后，key实例可用其内部的<code>compareTo</code>方法进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o1.compareTo(o2) <span class="comment">// </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compareTo返回值为int类型</span></span><br><span class="line"><span class="comment">若返回值为-1，说明o1小于o2</span></span><br><span class="line"><span class="comment">若返回值为0，说明o1等于o2</span></span><br><span class="line"><span class="comment">若返回值为1，说明o1大于o2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于comparableClassFor的理解最好使用具体的案例，如下所示：</p>
<p>建议自行跑一遍即可理解三个方法的工作过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        P p1=<span class="keyword">new</span> P(<span class="string">&quot;foo&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        P p2=<span class="keyword">new</span> P(<span class="string">&quot;bar&quot;</span>,<span class="number">20</span>);</span><br><span class="line">      </span><br><span class="line">        S s1=<span class="keyword">new</span> S(<span class="string">&quot;foo&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        S s2=<span class="keyword">new</span> S(<span class="string">&quot;bar&quot;</span>,<span class="number">20</span>);</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 可设置断点观察其内部的反射操作，kc1为P.class</span></span><br><span class="line">        Class&lt;?&gt; kc1=comparableClassFor(p1); </span><br><span class="line">        System.out.println(kc1==P.class); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dirP= compareComparables(kc1,p1,p2); <span class="comment">// 返回-10，说明p1小于p2</span></span><br><span class="line">        System.out.println(dirP);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 可设置断点观察其内部的反射操作,kc2为null，因为S类没有实现Comparable接口</span></span><br><span class="line">        Class&lt;?&gt; kc2=comparableClassFor(s1); </span><br><span class="line">        <span class="keyword">int</span> dirS= compareComparables(kc2,s1,s2); <span class="comment">// 返回0，无法比较s1和s2的大小</span></span><br><span class="line">        System.out.println(dirS);     </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> finalDir= tieBreakOrder(s1,s2); <span class="comment">// 返回-1，因此s1&lt;=s2</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1)); <span class="comment">// 460141958</span></span><br><span class="line">        System.out.println(System.identityHashCode(s2)); <span class="comment">// 1163157884</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 利用反射操作获取给定对象的Class实例kc，获取kc有何用？</span></span><br><span class="line">  	<span class="comment">// 获取到对象的kc就可以给到compareComparables使用,目的还是比较大小</span></span><br><span class="line">    <span class="comment">// dir = compareComparables(kc, x.key, p.key)) == 0</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="comment">// 如果x(上面的kc)实现Comparable接口，表示该类支持比较（排序）</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">          	<span class="comment">// 这里的Type是个高级货，参考后面的“Java的类型系统结构”</span></span><br><span class="line">            <span class="comment">// 如果是内建的String类型，由于String可直接比较，因此可直接return kc</span></span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">             <span class="comment">// 实现Comparable接口的自定义P类型会进入到此逻辑</span></span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                            ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                                    Comparable.class) &amp;&amp;</span><br><span class="line">                            (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 自定义的S类型因为没实现Comparable接口，因此kc为null</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若x对象为null或者两个对象的Class实例不同，两者无法比较，直接返回0</span></span><br><span class="line">       <span class="comment">// 否则说明k和x具有相同Class实例，且实现Comparable接口，可通过compareTo比较。</span></span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                        compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                    -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P类实现Comparable接口且覆写了compareTo方法：采用age字段比较。用该类观察comparableClassFor完整的反射操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">P</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">P</span> <span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(P o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// S类未实现Comparable，用它测试tieBreakOrder的比较效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">S</span> <span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于tieBreakOrder则很好理解：</p>
<p>1) 若a为空或者b为空，直接调用java的native方法<code>public static native int identityHashCode(Object x)</code>：System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</p>
<p>2) 若a和b都不为空，比较对象a以及对象b的全路径类名，这个<code>全路径类名</code>是String类型，当然可以比较。到了这里若a、b还相同，跟1)做法一样直接调用java的native方法达到最后的比较：</p>
<p><code>d=System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</code></p>
<p>Java的类型系统结构（需要结合泛型和反射知识）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type is the common superinterface for all types in the Java programming language. These include raw types, parameterized types, array types, type variables and primitive types.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">					  ┌────┐</span><br><span class="line">                        │Type         │</span><br><span class="line">                      └────┘</span><br><span class="line">                         ▲</span><br><span class="line">                         │</span><br><span class="line">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class="line">   │            │                  │               │</span><br><span class="line">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class="line">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class="line">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="七、其他TreeNode方法解析"><a href="#七、其他TreeNode方法解析" class="headerlink" title="七、其他TreeNode方法解析"></a>七、其他TreeNode方法解析</h4><p>关于`TreeNode()构造方法这里不再累赘，相对简单</p>
<h6 id="7-1-root-方法"><a href="#7-1-root-方法" class="headerlink" title="7.1 root()方法"></a>7.1 <code>root()</code>方法</h6><p>该方法较简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**给定任意位置的TreeNode，返回该TreeNode所在红黑树的根节点root</span></span><br><span class="line"><span class="comment"> * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>) <span class="comment">// 从当前节点this开始，不断向上溯源找父节点</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在<code>putTreeVal</code>源码有被使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在putVal里面：</span></span><br><span class="line"><span class="comment">// 遍历节点p调用putTreeVal方法，this表示p节点本身</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">  					<span class="comment">/*</span></span><br><span class="line"><span class="comment">  					这里的parent是指this的parent，也即上面的p节点的父节点</span></span><br><span class="line"><span class="comment">  					this=p</span></span><br><span class="line"><span class="comment">  					if(this.parent != null)&#123; // 如果p节点的父节点为为空，说明不是根结点，因此p节点调用root()方法找到根节点</span></span><br><span class="line"><span class="comment">  							root=root()</span></span><br><span class="line"><span class="comment">  					&#125;else&#123;</span></span><br><span class="line"><span class="comment">  							root=this  // // 如果p节点的父节点为为空，说明p节点就是根节点，直接返回p节点，也即this引用</span></span><br><span class="line"><span class="comment">  					&#125;</span></span><br><span class="line"><span class="comment">  					</span></span><br><span class="line"><span class="comment">  					*/</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">  					<span class="comment">// </span></span><br></pre></td></tr></table></figure>
<h6 id="7-2-find方法"><a href="#7-2-find方法" class="headerlink" title="7.2 find方法"></a>7.2 find方法</h6><p>find方法在getTreeNode和putTreeNode都有被调用的点，这里以getTreeNode方法说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">						<span class="comment">// ......</span></span><br><span class="line">      			<span class="comment">// (first = tab[(n - 1) &amp; hash]) != null)</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 如果桶位上的头节点恰好是TreeNode类型，那么需要进入红黑树遍历找出指定key的节点</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">						<span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calls find for root node.这里官方注释：由红黑树的头节点来调用getTreeNode</span></span><br><span class="line"><span class="comment">// 为何由root节点调用find方法：因为找插入节点或者找树节点，必须重根节点开始遍历</span></span><br><span class="line"><span class="comment">// 其实它也支持红黑树非root节点节点调用,但内部还是会找到root节点，再从root点解开始搜索</span></span><br><span class="line"><span class="comment">// (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">  					<span class="comment">// 如果调用该方法的节点不是根节点，使用root()找到根节点，再从根节点开始在全树范围找指定的key</span></span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>有了前面的被调用的场合，find方法其实是在执行普通的二叉搜索树查找过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getNode(hash,key)--&gt;getTreeNode(hash, key)--&gt;getTreeNode--&gt;root.find</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">     * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">     * comparing keys.</span></span><br><span class="line"><span class="comment">     给定一个hash值和key，从红黑树里面找到这个节点p，入口当然是从root节点开始：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// root.find(x.hash,x.key,null)</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//  对于getTreeNode方法调用find来说，这里this就是红黑树的根节点，或者当前处理节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">          </span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">			<span class="comment">// 1）小于则往p左边子树继续找，</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                p = pl;</span><br><span class="line">          <span class="comment">// 2）大于则在往p的右边子树继续找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">          <span class="comment">// 3) 若两者key相等则返回p节点,结束搜索</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">          <span class="comment">// 若能运行到这里，说明两者hash相等，key不同，此时若p的左子树为空，只能去p右子树继续找；同理，若p的右子树为空，只能去p左子树继续找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) </span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">         <span class="comment">// 若能运行到这里，说明两者hash相等，key不同，且p的左、右子树不空，则尝试调用用户自定义的Comparable接口并使用compareTo比较，根据返回的int值判断是进入左边还是右边子树继续找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">		<span class="comment">// 若能运行到这里，说明两者hash相等，key不同，且p的左、右子树不空，且自定义key对象没有实现Comparable接口（或者实现了Comparable接口但CompareTo方法无法比出大小），导致两者无法比出大小，因此不能二分查询了，只能穷举查找：先从p右边子树递归查找，直到右边子树找完都为空，那么再从左边子树全部节点查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 找遍红黑树都没找给定key的节点，返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="7-3-split方法（设计巧妙，作为重点理解的方法之一）"><a href="#7-3-split方法（设计巧妙，作为重点理解的方法之一）" class="headerlink" title="7.3 split方法（设计巧妙，作为重点理解的方法之一）"></a>7.3 split方法（设计巧妙，作为重点理解的方法之一）</h6><p>spit方法仅在一个地方使用，那就是在resize方法内部。spit方法设计也挺巧妙，值得借鉴！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()&#123;</span><br><span class="line"> 			<span class="comment">// .......</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      	<span class="comment">// 对红黑树进行扩容处理</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">                  &#125;    </span><br></pre></td></tr></table></figure>
<p>split的总体设计思想：</p>
<p>对于以下内容，需要理解“高位节点链表”和“低位节点链表”的含义，参考HashMap的resize源码分析。本节不再回顾相关内容，避免累赘。</p>
<p>低位节点特征满足：<code>(e.hash &amp; oldCap) == 0</code>（使用位运算才能看出端倪）</p>
<p>高位节点特征满足：<code>(e.hash &amp; oldCap) != 0</code>（使用位运算才能看出端倪）</p>
<p>1）若<code>table[i]</code>桶位上的红黑树，它所有的TreeNode节点恰好符合“低位节点”特征，那么在resize后，会构建一条“低位节点双向链表”；此外这棵红黑树root节点在新表的位置还是<code>i</code>，即<code>newTab[i]=root</code>，而且红黑树无需调整</p>
<p>2）若<code>table[i]</code>桶位上的红黑树，它所有的TreeNode节点恰好符合“高位节点”特征，那么在resize后，会构建一条“高位节点双向链表”；此外这棵红黑树root节点在新表的位置<code>i+oldCap</code>，即<code>newTab[i+oldCap]=root</code>，而且红黑树无需调整</p>
<p>3）若<code>table[i]</code>桶位上的红黑树它所有的TreeNode节点中，既有“高位节点”又有“低位节点”，这时spit方法真正起效了，此时红黑树会被spit成一条“低位节点双向链表”和一条“高位节点双向链表”</p>
<p>低位节点双向链表的头部节点位于<code>newTab[i]</code>上，若该链表长度大于6，将基于该双向链构建一棵红黑树；若长度&lt;=6，则将该双向链表变成单向链表</p>
<p>高位节点双向链表的头部节点位于<code>newTab[i+oldCap]</code>上，若该链表长度大于6，并基于该双向链构建一棵红黑树；若长度&lt;=6，则将该双向链表变成单向链表</p>
<p>再查看其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index: 桶位号，也是红黑树root节点所在的桶位位置，也是红黑树TreeNode用prev、next构成的双向链表头位置</span></span><br><span class="line"><span class="comment">bit:这里的bit是resize传入的旧表容量oldCap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 回顾resize调用点： ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的this其实红黑树的root节点</span></span><br><span class="line">  					TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// “低位节点双向链表”的头、尾指针</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  					<span class="comment">// “高位节点双向链表”的头、尾指针</span></span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">  					<span class="comment">//记录低、高位节点双向链表长度，以判断是否需要执行untreeify-&gt;双向变单向</span></span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">  					<span class="comment">// 由于红黑树TreeNode其实也有prev、next字段，遍历它原本的双向链表</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next; <span class="comment">// 保存next节点，用于驱动之后的循环</span></span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 遍历红黑树过程中，若当前节点e恰好是“低位特征节点”，则构建“低位节点双向链表”</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 个人更推荐使用treeifyBin里面构建双向链表的写法，更为直观</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;<span class="comment">//“低位节点双向链表”每加一个节点，lcc加1计数</span></span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// 遍历红黑树过程中，若当前节点e恰好是“高位特征节点”，则构建“高位节点双向链表”</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="comment">// 个人更推荐使用treeifyBin里面构建双向链表的写法，更为直观</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// “低位节点双向链表”长度&lt;= 树退化链的阈值6，则不再保持红黑树结构，直接转为单向链表</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                  	<span class="comment">//上面已经有一条低位双向链，若高位双向链表不为空，说明原红黑树被拆开两条双向链</span></span><br><span class="line">                  	<span class="comment">// 因此基于低位双向链构建一棵新红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  					<span class="comment">// 原理同上</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                  	<span class="comment">// 注意高位节点在新表的位置index+oldCap</span></span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map); </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="八、红黑树删除的设计过程"><a href="#八、红黑树删除的设计过程" class="headerlink" title="八、红黑树删除的设计过程"></a>八、红黑树删除的设计过程</h4><p>由于红黑树删除的设计相对复杂很多，因此单独在另外一篇文章进行解析</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" rel="tag"># Java高级主题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/22/%E5%88%A9%E7%94%A8pandas%E5%B0%86groupby%E5%88%86%E7%BB%84%E5%90%8E%E5%B0%86%E7%BB%84%E5%86%85%E5%A4%9A%E8%A1%8C%E4%B8%BA%E4%B8%80%E8%A1%8C/" rel="prev" title="利用pandas将分组后的组内多行归并为一行">
      <i class="fa fa-chevron-left"></i> 利用pandas将分组后的组内多行归并为一行
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/16/ArrayList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E7%9A%84%E7%AE%80%E8%A6%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/" rel="next" title="ArrayList数据结构设计原理的简要深入分析.md">
      ArrayList数据结构设计原理的简要深入分析.md <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">一、背景知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">二、红黑树性质：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%9B%E8%A1%8C%E5%8F%98%E8%89%B2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E5%8F%B3%E6%97%8B%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">三、为何要对红黑树进行变色、左旋、右旋操作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B%E3%80%81%E5%8F%B3%E6%97%8B%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">四、红黑树左旋、右旋完整操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-%E7%90%86%E8%A7%A3%E5%B7%A6%E6%97%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 理解左旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-%E7%90%86%E8%A7%A3%E5%8F%B3%E6%97%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 理解右旋</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%8F%92%E5%85%A5%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">五、插入红黑树节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-%E6%8F%92%E5%85%A5%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 插入总体思路设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90"><span class="nav-number">5.2.</span> <span class="nav-text">5.2  平衡操作的设计解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-balanceInsertion%E5%9B%BE%E8%A7%A3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 balanceInsertion图解+源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-1-%E8%8B%A5%E5%8E%9Froot%E8%8A%82%E7%82%B9%E6%98%AFnull%E6%97%B6"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 若原root节点是null时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-2-%E8%8B%A5%E5%8E%9F%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8x%E8%8A%82%E7%82%B9%E6%97%B6"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 若原红黑树已经存在x节点时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-3-%E8%8B%A5%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9x%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9xp%E6%98%AF%E9%BB%91%E8%89%B2%E6%88%96%E8%80%85%E7%88%B6%E8%8A%82%E7%82%B9xp%E5%B0%B1%E6%98%AF%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 若插入节点x的父节点xp是黑色或者父节点xp就是根节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-4-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9x%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9xp%E6%98%AF%E7%BA%A2%E8%89%B2%EF%BC%8Cx%E7%9A%84%E5%8F%94%E5%8F%94%E8%8A%82%E7%82%B9%EF%BC%88xppl-xppr%EF%BC%89%E6%98%AF%E7%BA%A2%E8%89%B2"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 插入节点x的父节点xp是红色，x的叔叔节点（xppl&#x2F;xppr）是红色</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-3-5-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9x%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9xp%E6%98%AF%E7%BA%A2%E8%89%B2%EF%BC%8Cx%E7%9A%84%E5%8F%94%E5%8F%94%E8%8A%82%EF%BC%88xppl-xppr%EF%BC%89%E6%98%AF%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85NIL%E8%8A%82%E7%82%B9"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 插入节点x的父节点xp是红色，x的叔叔节（xppl&#x2F;xppr）是黑树或者NIL节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E6%A0%91%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%9A%E5%90%8C%E6%97%B6%E7%90%86%E8%A7%A3treeifyBin%E3%80%81treeify%E3%80%81moveRootToFront%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">六、关于链表树化的处理：同时理解treeifyBin、treeify、moveRootToFront方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#6-1-treeifyBin"><span class="nav-number">6.0.1.</span> <span class="nav-text">6.1 treeifyBin</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-2-treeify"><span class="nav-number">6.0.2.</span> <span class="nav-text">6.2 treeify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-3-moveRootToFront"><span class="nav-number">6.0.3.</span> <span class="nav-text">6.3 moveRootToFront</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-%E6%9C%AC%E8%8A%82%E6%8E%A56-2%E7%9A%84treeify%E5%86%85%E5%AE%B9%EF%BC%9A%E6%AF%94%E8%BE%83x%E8%8A%82%E7%82%B9%E5%92%8Cp%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F"><span class="nav-number">6.0.4.</span> <span class="nav-text">6.4 本节接6.2的treeify内容：比较x节点和p节点大小</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96TreeNode%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">七、其他TreeNode方法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-root-%E6%96%B9%E6%B3%95"><span class="nav-number">7.0.1.</span> <span class="nav-text">7.1 root()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-2-find%E6%96%B9%E6%B3%95"><span class="nav-number">7.0.2.</span> <span class="nav-text">7.2 find方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-3-split%E6%96%B9%E6%B3%95%EF%BC%88%E8%AE%BE%E8%AE%A1%E5%B7%A7%E5%A6%99%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%87%8D%E7%82%B9%E7%90%86%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%B9%8B%E4%B8%80%EF%BC%89"><span class="nav-number">7.0.3.</span> <span class="nav-text">7.3 split方法（设计巧妙，作为重点理解的方法之一）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">八、红黑树删除的设计过程</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
