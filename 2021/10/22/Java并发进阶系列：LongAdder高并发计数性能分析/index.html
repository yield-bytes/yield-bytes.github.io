<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文基于本博客已发布的CHM文章中分析fullAddCount方法基础上，介绍LongAdder这个高并发计数性能，并通过与原子计数器AtomicLong进行比较，最后给出Striped64类相关分析（因其内部真正实现了高并发计数逻辑）。 为何需要介绍下LongAdder类？因为在fullAddCount方法的定义上，因为在CHM源代码上，Doug Lea有提到：fullAddCount的设计原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：LongAdder高并发计数性能分析">
<meta property="og:url" content="https://yield-bytes.github.io/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="本文基于本博客已发布的CHM文章中分析fullAddCount方法基础上，介绍LongAdder这个高并发计数性能，并通过与原子计数器AtomicLong进行比较，最后给出Striped64类相关分析（因其内部真正实现了高并发计数逻辑）。 为何需要介绍下LongAdder类？因为在fullAddCount方法的定义上，因为在CHM源代码上，Doug Lea有提到：fullAddCount的设计原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6c72a0eb2a7940a6a934d5cfe2633257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8addaedf6ca74783b40c1e63e963c062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5c320a9b9aa543d2aa19a0f41840f54c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2021-10-21T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-09T14:05:42.259Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/6c72a0eb2a7940a6a934d5cfe2633257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="https://yield-bytes.github.io/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：LongAdder高并发计数性能分析 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：LongAdder高并发计数性能分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-22T00:00:00+08:00">2021-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 22:05:42" itemprop="dateModified" datetime="2022-05-09T22:05:42+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文基于本博客已发布的CHM文章中分析fullAddCount方法基础上，介绍LongAdder这个高并发计数性能，并通过与原子计数器AtomicLong进行比较，最后给出Striped64类相关分析（因其内部真正实现了高并发计数逻辑）。</p>
<p>为何需要介绍下LongAdder类？<br>因为在fullAddCount方法的定义上，因为在CHM源代码上，Doug Lea有提到：fullAddCount的设计原理可通过LongAdder这个类得到相关解释：：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// 省略部分  ......</span></span><br></pre></td></tr></table></figure>
<h4 id="1、两种并发计数器的性能比较"><a href="#1、两种并发计数器的性能比较" class="headerlink" title="1、两种并发计数器的性能比较"></a>1、两种并发计数器的性能比较</h4><p>longAdderCost和atomicLongCost的目的：指定一定数量的线程并发执行该逻辑：每个线程计数从0增加到1000*1000</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] scales=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">128</span>,<span class="number">512</span>,<span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> loops=<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> scale : scales) &#123;</span><br><span class="line">            longAdderCost(scale,loops);</span><br><span class="line">            atomicLongCost(scale,loops);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">longAdderCost</span><span class="params">(<span class="keyword">int</span> threadNums,<span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdder longAdder=<span class="keyword">new</span> LongAdder();</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    longAdder.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;LongAdder：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicLongCost</span><span class="params">(<span class="keyword">int</span> threadNums,<span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong atomicLong=<span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">           Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                   atomicLong.incrementAndGet();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">           thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">           thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;AtomicLong：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LongAdder：线程数为<span class="number">1</span>,计算<span class="number">1000000</span>次,总用时205ms</span><br><span class="line">AtomicLong：线程数为<span class="number">1</span>,计算<span class="number">1000000</span>次,总用时17ms</span><br><span class="line">LongAdder：线程数为<span class="number">4</span>,计算<span class="number">1000000</span>次,总用时38ms</span><br><span class="line">AtomicLong：线程数为<span class="number">4</span>,计算<span class="number">1000000</span>次,总用时102ms</span><br><span class="line">LongAdder：线程数为<span class="number">16</span>,计算<span class="number">1000000</span>次,总用时64ms</span><br><span class="line">AtomicLong：线程数为<span class="number">16</span>,计算<span class="number">1000000</span>次,总用时351ms</span><br><span class="line">LongAdder：线程数为<span class="number">128</span>,计算<span class="number">1000000</span>次,总用时503ms</span><br><span class="line">AtomicLong：线程数为<span class="number">128</span>,计算<span class="number">1000000</span>次,总用时2833ms</span><br><span class="line">LongAdder：线程数为<span class="number">512</span>,计算<span class="number">1000000</span>次,总用时2092ms</span><br><span class="line">AtomicLong：线程数为<span class="number">512</span>,计算<span class="number">1000000</span>次,总用时12953ms</span><br><span class="line">LongAdder：线程数为<span class="number">1024</span>,计算<span class="number">1000000</span>次,总用时4007ms</span><br><span class="line">AtomicLong：线程数为<span class="number">1024</span>,计算<span class="number">1000000</span>次,总用时26639ms</span><br></pre></td></tr></table></figure>
<p>对以上数据进行作图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/6c72a0eb2a7940a6a934d5cfe2633257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以非常清楚看到两者存在性能差异：</p>
<p>（1）剔除单线程数据，LongAdder并发计数耗时最少，并且随着线程数量增加，并发计数耗时趋势相对稳定</p>
<p>（2）剔除单线程数据，AtomicLong并发计数耗时长，并且随着线程数量增加，并发计数性耗时基本呈指数上升趋势</p>
<h4 id="2、两者性能差异的原因分析"><a href="#2、两者性能差异的原因分析" class="headerlink" title="2、两者性能差异的原因分析"></a>2、两者性能差异的原因分析</h4><h5 id="2-1-单线程情况"><a href="#2-1-单线程情况" class="headerlink" title="2.1 单线程情况"></a>2.1 单线程情况</h5><p>首先对于单线程情况下，也即线程数量为1，因为LongAdder的increment方法里面调用add方法且在add方法内部需要做一些基本判断，这些代码的执行需要消耗一定时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adds the given value.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 相当于ConcurrentHashMap的AddCount方法的分支1逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">      Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">      <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">              !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            	<span class="comment">// 相当于ConcurrentHashMap的fullAddCount的逻辑</span></span><br><span class="line">              longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Equivalent to &#123;<span class="doctag">@code</span> add(1)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      add(<span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对比atomicLong.incrementAndGet()方法：该方法直接进行计数，代码执行流程显然比上面要快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此单线程情况下，从实际测试结果来看，AtomicLong肯定会比LongAdder快</p>
<h5 id="2-2-多线程并发计数情况"><a href="#2-2-多线程并发计数情况" class="headerlink" title="2.2 多线程并发计数情况"></a>2.2 多线程并发计数情况</h5><p>当线程数量开始增加时，LongAdder计数比AtomicLong快，要知道这两个都是使用lockness机制也即Unsafe的CAS去实现的，为何两者性能差距这么明显？</p>
<p>主要还是两者的设计思路导致的</p>
<p>（1）对于AtomicLong来说：incrementAndGet方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用的是getAndAddLong方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其设计相对简陋，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/8addaedf6ca74783b40c1e63e963c062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>while自旋+对offset进行CAS加delta值计数，也即当有1000个线程并发去incrementAndGet时，由于线程竞争激烈，导致每轮自旋只能有1个线程成功拿到本轮的CAS，那么最后效果：越多线程参与计数效率就越慢，因为竞争激烈时，可能有一部分线程一直竞争CAS都失败，它们占用cpu时间片不说，还未做“加1计数”的贡献。</p>
<p>打个通俗比喻：</p>
<p>有一个窗口放着一个小黑版，上面写着一个count，小黑板每次只让一个人对其加1计数，如果采用AtomicLong的“while自旋+CAS”设计，当有1000个人同时想在小黑板做加1计数时，每轮只能有一个人走到窗口前在小黑板加1，只要这个人还没写完，那么其他999个人就得一起不断来回走到窗口前看看能否抢到“小黑班写的权利”，显然这种“一起来回走动”浪费资源，效率也低。</p>
<p>（2）对于LongAdder来说：increment内部其实使用是相对高效的、能降低线程竞争的设计：longAccumulate，其实也是ConcurrentHashMap里面的fullAddCount方法，原理图在CHM的源代码已经给出，如下图所示<br><img src="https://img-blog.csdnimg.cn/5c320a9b9aa543d2aa19a0f41840f54c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>设计思想：</p>
<p>（1）当线程竞争不激烈情况下，通过自旋+cas对baseCount进行加1计数，这一阶段类似AtomicLong的计数逻辑</p>
<p>（2）当线程竞争十分激烈的情况下，有一部分线程很幸运能够抢到cas权力成功对baseCount加1，而剩下对baseCount加1cas失败的线程，它们就会创建一个CounterCells计数的数组，然后线程给对应自己的桶位Cell对象进行cas加1操作，这样一来就实现了“线程分流”，减少竞争。</p>
<p>亮点设计在于这个“CounterCells计数的数组”</p>
<p>打个通俗比喻（同上）：</p>
<p>当人数量少时，开1个窗口给他们在小黑板写</p>
<p>当人数量多，多开几个窗口，例如开8个窗口，每个窗口都放置一块小黑板，那么</p>
<p>每个窗口平均下来也就125个人在竞争，相比于之前1000个人激烈竞争1个窗口，</p>
<p>这个窗口最大数量跟cpu数量一致，能充分利用每个cpu core，显然性能就上来了。</p>
<p>其实两者的性能说明在LongAdder的源代码注释已给出：</p>
<blockquote>
<p>This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</p>
</blockquote>
<p>在线程竞争不激烈的写（更新）操作，两者性能类似。在线程竞争激烈情况下，也即线程并发高时，LongAdder拥有更高的throughput（一般指吞吐量，在这里可以理解为并发计数量），但代价是占用更多内存（上面的例子代价就是多开几个窗口）</p>
<p>LongAdder是典型的空间换时间的设计！</p>
<h4 id="3、Striped64类分析"><a href="#3、Striped64类分析" class="headerlink" title="3、Striped64类分析"></a>3、Striped64类分析</h4><p>考虑到CHM的fullAddCount源代码设计其实就是LongAdder里面的longAccumulate方法而该方法来自Striped64类，因此本文不再给出longAccumulate的源代码解析，具体可参考之前的文章：</p>
<p>关于LongAdder类，因为其源代码设计简单，也不再作为详细说明，本文重点讲解Striped64的设计:</p>
<p>LongAdder继承自Striped64</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Striped64继承自Number，源代码总共413行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-Cell内部类"><a href="#3-1-Cell内部类" class="headerlink" title="3.1 Cell内部类"></a>3.1 Cell内部类</h5><p>在线程对base cas发生激烈冲突时，线程通过创建Cell数据并对桶位上的Cell进行cas加值操作，可以看到其内部独立使用了Unsafe机制，并且定义了一个更新值的cas方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Padded variant of AtomicLong supporting only raw accesses plus CAS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * JVM intrinsics note: It would be possible to use a release-only</span></span><br><span class="line"><span class="comment"> * form of CAS here, if it were provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Striped64的Cell类对比CHM fullAddCount CounterCell计数类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-其他成员变量"><a href="#3-2-其他成员变量" class="headerlink" title="3.2 其他成员变量"></a>3.2 其他成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bound on table size */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of cells. When non-null, size is a power of 2.也即fullAddCount里面的CounterCell[]数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment"> * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> * 也即fullAddCount里面的baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment"> * 也即fullAddCount里面cellsBusy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package-private default constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Striped64() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CASes the base field.</span></span><br><span class="line"><span class="comment"> * 更新base的操作已经被独立封装成一个内部方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CASes the cellsBusy field from 0 to 1 to acquire lock.</span></span><br><span class="line"><span class="comment"> 对cellsBusy操作已经被独立封装成一个内部方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casCellsBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the probe value for the current thread.</span></span><br><span class="line"><span class="comment"> * Duplicated from ThreadLocalRandom because of packaging restrictions.</span></span><br><span class="line"><span class="comment"> * probe范围已探针，在这里，可以理解为与当前线程一一对应的随机值，也即键值对：（当前线程，线程对应的随机值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pseudo-randomly advances and records the given probe value for the</span></span><br><span class="line"><span class="comment"> * given thread.</span></span><br><span class="line"><span class="comment"> * Duplicated from ThreadLocalRandom because of packaging restrictions.</span></span><br><span class="line"><span class="comment"> * 当线程未能成功对桶位Cell进行CAS加值时，就给该线程换一个probe值，使得线程hash定位能够尽量定到不同的桶位上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">advanceProbe</span><span class="params">(<span class="keyword">int</span> probe)</span> </span>&#123;</span><br><span class="line">    probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">    probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">    probe ^= probe &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    UNSAFE.putInt(Thread.currentThread(), PROBE, probe); <span class="comment">// Unsafe操作对象是当前线程，更改的值为probe</span></span><br><span class="line">    <span class="keyword">return</span> probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这里为何这里键值对：（当前线程，线程对应的随机值）中线程对应的随机不是用<code>java.util.Random</code>生成？这是因为ThreadLocalRandom比Random更适合用在高并发情况，这里说的更适合是指“生成随机数性能更高而且与当前线程关联”，关键点为：ThreadLocalRandom，每个线程都有自己seed用于生成随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread(); <span class="comment">// 当前线程</span></span><br><span class="line">    UNSAFE.putLong(t, SEED, seed); <span class="comment">// 将当前的seed与当前线程关联起来</span></span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe); <span class="comment">// 将当前的probe与当前线程关联起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-longAccumulat"><a href="#3-3-longAccumulat" class="headerlink" title="3.3 longAccumulat"></a>3.3 longAccumulat</h5><p>longAccumulat设计跟CHM里面的fullAddCount设计一致，只不过这里多了参数： update function</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles cases of updates involving initialization, resizing,</span></span><br><span class="line"><span class="comment"> * creating new Cells, and/or contention. See above for</span></span><br><span class="line"><span class="comment"> * explanation. This method suffers the usual non-modularity</span></span><br><span class="line"><span class="comment"> * problems of optimistic retry code, relying on rechecked sets of</span></span><br><span class="line"><span class="comment"> * reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn the update function, or null for add (this convention</span></span><br><span class="line"><span class="comment"> * avoids the need for an extra field or function in LongAdder).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个 update function有什么用呢？如下：</p>
<p>例如定义个匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; 2 * x +1</span><br></pre></td></tr></table></figure>
<p>那么每次cas就可以不只是<code>cas(this，value1，value2)</code>这种形式，而是<code>cas(this，value1，fn(value2)</code>能对value2进一步处理后再给到cas放入主存中。</p>
<p>调用点1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"><span class="comment">// 当前线程对非空桶位Cell进行cas加值操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                     fn.applyAsLong(v, x))))</span><br></pre></td></tr></table></figure>
<p>调用点2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">// 当前线程又回到对base加值操作，若当前线程能在base身上加值成功就可以退出逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base：这里是说当前线程因为进入longAccumulate没能竞争到对Cell加值操作，如果代码能执行到这个分支，那么线程又回到base变量去竞争cas加值操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>与longAccumulat类似逻辑的是double类型的doubleAccumulate高并发计数方法，这里不再累赘。</p>
<p>个人认为Striped64类里面表达最重要信息之一是：源码内部的详细代码功能注释说明，本文不再一一翻译，所有详细的设计和逻辑都在CHM文章中fullAddCount章节给出非常详细的解析，因此你可以基于源码的理解来对照以下官方源码注释：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#x2F;*</span><br><span class="line">* 1、首先介绍Striped64类数据结构：底层是可原子写操作的table+base变量</span><br><span class="line">* This class maintains a lazily-initialized table of atomically</span><br><span class="line">* updated variables, plus an extra &quot;base&quot; field. The table size</span><br><span class="line">* is a power of two. Indexing uses masked per-thread hash codes.</span><br><span class="line">* Nearly all declarations in this class are package-private,</span><br><span class="line">* accessed directly by subclasses.</span><br><span class="line">*</span><br><span class="line">* 2、Cell类的设计说明</span><br><span class="line">* Table entries are of class Cell; a variant of AtomicLong padded</span><br><span class="line">* (via @sun.misc.Contended) to reduce cache contention. Padding</span><br><span class="line">* is overkill for most Atomics because they are usually</span><br><span class="line">* irregularly scattered in memory and thus don&#39;t interfere much</span><br><span class="line">* with each other. But Atomic objects residing in arrays will</span><br><span class="line">* tend to be placed adjacent to each other, and so will most</span><br><span class="line">* often share cache lines (with a huge negative performance</span><br><span class="line">* impact) without this precaution.</span><br><span class="line">*</span><br><span class="line">* 3、Cells[] 数组的设计目的</span><br><span class="line">* In part because Cells are relatively large, we avoid creating</span><br><span class="line">* them until they are needed.  When there is no contention, all</span><br><span class="line">* updates are made to the base field.  Upon first contention (a</span><br><span class="line">* failed CAS on base update), the table is initialized to size 2.</span><br><span class="line">* The table size is doubled upon further contention until</span><br><span class="line">* reaching the nearest power of two greater than or equal to the</span><br><span class="line">* number of CPUS. Table slots remain empty (null) until they are</span><br><span class="line">* needed.</span><br><span class="line">*</span><br><span class="line">* 4、设计cellsBusy锁的目的</span><br><span class="line">* A single spinlock (&quot;cellsBusy&quot;) is used for initializing and</span><br><span class="line">* resizing the table, as well as populating slots with new Cells.</span><br><span class="line">* There is no need for a blocking lock; when the lock is not</span><br><span class="line">* available, threads try other slots (or the base).  During these</span><br><span class="line">* retries, there is increased contention and reduced locality,</span><br><span class="line">* which is still better than alternatives.</span><br><span class="line">*</span><br><span class="line">* 5、Thread probe用于定位在Cells数组哪个桶位</span><br><span class="line">* The Thread probe fields maintained via ThreadLocalRandom serve</span><br><span class="line">* as per-thread hash codes. We let them remain uninitialized as</span><br><span class="line">* zero (if they come in this way) until they contend at slot</span><br><span class="line">* 0. They are then initialized to values that typically do not</span><br><span class="line">* often conflict with others.  Contention and&#x2F;or table collisions</span><br><span class="line">* are indicated by failed CASes when performing an update</span><br><span class="line">* operation. Upon a collision, if the table size is less than</span><br><span class="line">* the capacity, it is doubled in size unless some other thread</span><br><span class="line">* holds the lock. If a hashed slot is empty, and lock is</span><br><span class="line">* available, a new Cell is created. Otherwise, if the slot</span><br><span class="line">* exists, a CAS is tried.  Retries proceed by &quot;double hashing&quot;,</span><br><span class="line">* using a secondary hash (Marsaglia XorShift) to try to find a</span><br><span class="line">* free slot.</span><br><span class="line">*</span><br><span class="line">* 6、capped翻译为：用...封顶（盖住） Cells数组长度最大只能扩容到和CPU数量相同</span><br><span class="line">* The table size is capped because, when there are more threads</span><br><span class="line">* than CPUs, supposing that each thread were bound to a CPU,</span><br><span class="line">* there would exist a perfect hash function mapping threads to</span><br><span class="line">* slots that eliminates collisions. When we reach capacity, we</span><br><span class="line">* search for this mapping by randomly varying the hash codes of</span><br><span class="line">* colliding threads.  Because search is random, and collisions</span><br><span class="line">* only become known via CAS failures, convergence can be slow,</span><br><span class="line">* and because threads are typically not bound to CPUS forever,</span><br><span class="line">* may not occur at all. However, despite these limitations,</span><br><span class="line">* observed contention rates are typically low in these cases.</span><br><span class="line">*</span><br><span class="line">* 7、在Cells数组有些桶位的Cell可能没被线程命中用于CAS加值计数，但没关系，不用理会它，也不需要去找到这的Cell桶位然后删除之（画蛇添足）。</span><br><span class="line">* It is possible for a Cell to become unused when threads that</span><br><span class="line">* once hashed to it terminate, as well as in the case where</span><br><span class="line">* doubling the table causes no thread to hash to it under</span><br><span class="line">* expanded mask.  We do not try to detect or remove such cells,</span><br><span class="line">* under the assumption that for long-running instances, observed</span><br><span class="line">* contention levels will recur, so the cells will eventually be</span><br><span class="line">* needed again; and for short-lived ones, it does not matter.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E5%AE%98%E6%96%B9%E5%85%B3%E4%BA%8Ejdk1.8ConcurrentHashMap%E7%9A%84computeIfAbsent%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91/" rel="prev" title="Java高级主题：深度讨论官方关于jdk1.8ConcurrentHashMap的computeIfAbsent源代码修复逻辑">
      <i class="fa fa-chevron-left"></i> Java高级主题：深度讨论官方关于jdk1.8ConcurrentHashMap的computeIfAbsent源代码修复逻辑
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" rel="next" title="Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现">
      Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%A4%E7%A7%8D%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">1.</span> <span class="nav-text">1、两种并发计数器的性能比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%B8%A4%E8%80%85%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">2、两者性能差异的原因分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 单线程情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%83%85%E5%86%B5"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 多线程并发计数情况</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Striped64%E7%B1%BB%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">3、Striped64类分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-Cell%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Cell内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 其他成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-longAccumulat"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 longAccumulat</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
