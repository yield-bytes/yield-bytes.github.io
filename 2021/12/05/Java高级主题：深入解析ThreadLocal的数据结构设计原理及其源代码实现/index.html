<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="ThreadLocal可以实现完全基于无锁且也不是基于CAS的线程隔离需求，让每个线程可以有自己的本地实例，但如果对ThreadLocal底层设计不了解，那么对甚至无法正确ThreadLocal及其可能出现的内存泄露问题。可以说ThreadLocal的源代码设计也一种非常优秀的可支持“高并发”的实现。  《gitee 博客文章封面》">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现">
<meta property="og:url" content="https://yield-bytes.github.io/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="ThreadLocal可以实现完全基于无锁且也不是基于CAS的线程隔离需求，让每个线程可以有自己的本地实例，但如果对ThreadLocal底层设计不了解，那么对甚至无法正确ThreadLocal及其可能出现的内存泄露问题。可以说ThreadLocal的源代码设计也一种非常优秀的可支持“高并发”的实现。  《gitee 博客文章封面》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/692e077da2654f0eb1ec67ff4f54a4cf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9b76747291534dd4b553699e0ea6b551.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ac10ec60579e410f910401b2ab956b87.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/adb19cd01cd640d7bd8f5fc77a5daf8d.png">
<meta property="article:published_time" content="2021-12-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T07:04:24.280Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png">

<link rel="canonical" href="https://yield-bytes.github.io/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-05T00:00:00+08:00">2021-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-18 15:04:24" itemprop="dateModified" datetime="2022-05-18T15:04:24+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>ThreadLocal可以实现完全基于无锁且也不是基于CAS的线程隔离需求，让每个线程可以有自己的本地实例，但如果对ThreadLocal底层设计不了解，那么对甚至无法正确ThreadLocal及其可能出现的内存泄露问题。可以说ThreadLocal的源代码设计也一种非常优秀的可支持“高并发”的实现。</p>
<p><img src="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png" alt="在这里插入图片描述"></p>
<p>《gitee 博客文章封面》</p>
<a id="more"></a>
<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ThreadLocal&lt;String&gt; var1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            ThreadLocal&lt;String&gt; var2=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            <span class="comment">// 普通用法</span></span><br><span class="line">            var1.set(<span class="string">&quot;foo A&quot;</span>);</span><br><span class="line">            var2.set(<span class="string">&quot;bar A&quot;</span>);</span><br><span class="line">            System.out.println(var1.get()); <span class="comment">// 输出foo A</span></span><br><span class="line">            System.out.println(var2.get()); <span class="comment">// 输出bar A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ThreadLocal&lt;String&gt; var1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            ThreadLocal&lt;String&gt; var2=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            <span class="comment">// 普通用法</span></span><br><span class="line">            var1.set(<span class="string">&quot;foo B&quot;</span>);</span><br><span class="line">            var2.set(<span class="string">&quot;bar B&quot;</span>);</span><br><span class="line">            System.out.println(var1.get()); <span class="comment">// 输出foo B</span></span><br><span class="line">            System.out.println(var2.get()); <span class="comment">// 输出bar B</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ProducerA().start();</span><br><span class="line">        <span class="keyword">new</span> ProducerB().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里创建了两个线程，每个线程内部有自己的ThreadLocal变量，线程之间ThreadLocal变量内部的set和get互相独立，互不影响，无需使用锁即可实现了线程安全操作。线程内部的变量使用set方法给定初始值、get方法取值，可以猜测其内部有类似HashMap这样的设计，但是否照搬HashMap数据结构设计呢？ 其实不然。</p>
<p>在这里，ProducerA内部其实是创建了一个称为“ThreadLocalMap”的Map结构用于存放ThreadLocal变量和它的value，ProducerB内部也创建了一个ThreadLocalMap，也即每个线程绑定一个自己内部ThreadLocalMap，这里提到的ThreadLocalMap就是提供了set、get方法的底层Map数据结构，所谓的ThreadLocal数据结构分析其实就是特指其内部的ThreadLocalMap的数据结构分析。</p>
<h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCount</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;HoldCount&gt; rh=ThreadLocal.withInitial(HoldCount::<span class="keyword">new</span>); <span class="comment">// 设定rh这个ThreadLocal变量的初始值</span></span><br><span class="line">        rh.set(<span class="keyword">new</span> HoldCount());  <span class="comment">// 将计数器放在rh中缓存</span></span><br><span class="line">        HoldCount h= rh.get();</span><br><span class="line">        System.out.println(h.count); <span class="comment">// 这里输出的rh初始值，也即HoldCount的count属性初始值:0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            h.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(h.count);</span><br><span class="line"></span><br><span class="line">        HoldCount newh=rh.get();<span class="comment">// 更新缓存计数器后，再从ThreadLocal重新读取</span></span><br><span class="line">        System.out.println(newh.count); <span class="comment">// 可以读取新的计数值</span></span><br><span class="line">        <span class="comment">// 在rh这个ThreadLocal里面的Map结构中移除HoldCount实例对象</span></span><br><span class="line">        rh.remove();</span><br><span class="line">        System.out.println(rh.get()); <span class="comment">// 此时rh里面Map已经不存在HoldCount对象，因此这里返回NUll</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在demo2中，给出了使用ThreadLocal后需要及时删除其实例对象的情况，这部分原因将在文章后面给出深入分析。</p>
<h3 id="ThreadLocal内部数据结构简析"><a href="#ThreadLocal内部数据结构简析" class="headerlink" title="ThreadLocal内部数据结构简析"></a>ThreadLocal内部数据结构简析</h3><p>可以看到set方法是由内部ThreadLocalMap实现的set方法，既然是个“Map”，那么当然可以猜测是否跟HashMap的数据结构：数据+链表+红黑树类似呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实ThreadLocalMap的数据结构没有HashMap数据结构复杂，ThreadLocalMap底层仅有一个table数组，这里，也许你会好奇：HashMap为了解决hash冲突，在数组的桶位上加入一条单向链表，冲突的entry自然会放入到此链表中（或者红黑树），那么问题来了，ThreadLocalMap底层仅有一个table数组，它是如何解决hash冲突？以下正式其设计原理之一，这里的数组给出最简单的情况，不包括“stale entry（无效entry）”的情况，以便让读者快速理解ThreadLocalMap设计原理：<br><img src="https://img-blog.csdnimg.cn/692e077da2654f0eb1ec67ff4f54a4cf.png" alt="在这里插入图片描述"><br>可以看到图中所说的“解决冲突的方式：从i=3开始向后遍历出首个空slot，也即i=5，将keyC放入此空slot即可”的逻辑被称为“线性探测法”，所谓的“线性”就是o(n)复杂度的遍历操作，所谓的“探测”就是不断向后“探测、寻找”，直到找到首个空slot位置。</p>
<p>以上内容为ThreadLocalMap的放入new Entry的简单情况，如果有理解HashMap源代码设计的读者应该可以猜到其他重要设计：例如，当数组容量不够时，如何扩容，也即rehash（注意ThreadLocalMap里面的resize和rehash不是同一个逻辑），再例如ThreadLocalMap里面已经存在的entry，如果它的key已经变成无效（stale），那么如何该清理，或者说在set和get的线性探测过程中遇到有stale entry时，该如何清理？这些问题将在后面逐个深入探讨。</p>
<h3 id="ThreadLocalMap的基本成员变量"><a href="#ThreadLocalMap的基本成员变量" class="headerlink" title="ThreadLocalMap的基本成员变量"></a>ThreadLocalMap的基本成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// ThreadLocalMap底层数组存放的WeakReference类型的entry，使用弱引用类型是为了能够高效GC，避免内存泄露，文章后面给出此设计的讨论</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">		<span class="comment">/* entry的key就是ThreadLocal对象，例如一个线程内部有10个ThreadLocal变量，那么此线程内部的ThreadLocalMap将存放这10个entry，这里的value就是ThreadLocal变量的“值”。</span></span><br><span class="line"><span class="comment">    例如demo1中：</span></span><br><span class="line"><span class="comment">        ThreadLocal&lt;String&gt; var1=new ThreadLocal&lt;&gt;();</span></span><br><span class="line"><span class="comment">        var1.set(&quot;foo A&quot;)</span></span><br><span class="line"><span class="comment">        那么entry的key就是这个名称为var1的ThreadLocal对象，value就是字符串“foo A”</span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 数组的初始容量16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">     * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap的底层数组，这里也采用2的次方，原因在HashMap的源代码讨论已经给出深入的解析，这里不再累赘。</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 数据含有entry的个数，注意即使entry的key处于stale状态，它也算一个entry</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 注意区别于HashMap的扩容阈值是len*3/4</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increment i modulo len.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 返回数组当前位置i的下一个位置i+1,如果下一个位置超过数组长度，那么下一个位置又从下标0开始，这种方式实现了所谓的“环形数组”，在后面get、set方法中或者stale entry清空机制的处理中可以看到它的用处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decrement i modulo len.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 逻辑同上，方向相反，返回当前位置i的前一个位置i+1，如果来到数组头部，那么前一个位置即回到数组末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="set方法完全解析"><a href="#set方法完全解析" class="headerlink" title="set方法完全解析"></a>set方法完全解析</h3><h4 id="set方法本身"><a href="#set方法本身" class="headerlink" title="set方法本身"></a>set方法本身</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the value associated with key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">      <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">      <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">      <span class="comment">// path would fail more often than not.</span></span><br><span class="line">      </span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="comment">// 1.计算给定key对应的桶位，此hash算法能够最大程度将key平均分布到数组对应的桶位上，具体算法参考文后说明</span></span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      <span class="comment">/* 2.线性探测发的实现</span></span><br><span class="line"><span class="comment">      从定位到i桶位开始遍历，直到遇到一个entry确实是null的空桶位，如果此遍历过程中遇到stale entry那么将其替换即可完成set操作。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">           e != <span class="keyword">null</span>;</span><br><span class="line">           e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">// 3.如果此桶位的key恰好是给定给定的key，那么更新此桶位的value后可直接返回。</span></span><br><span class="line">          <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">              e.value = value;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">		<span class="comment">// 4. 当前桶位的entry的key为null（注意这个key是弱引用类型，说明此entry已经被GC），使用replaceStaleEntry放入新entry</span></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">              replaceStaleEntry(key, value, i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 5.在2的线性探测过程中，遇到entry为空的即可来到这流程,直接放入新entry，并且数组的entry数量加1，在这里应该可以猜到，当向数组添加一个新entry后接下来就要判断是否需要扩容</span></span><br><span class="line">      tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">      <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    	<span class="comment">// 6.满足扩容的条件：cleanSomeSlots返回False且entry数量达到扩容阈值</span></span><br><span class="line">      <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">          rehash();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于线性探测法的说明</p>
<p>1.为何会有“环形数组或者环形遍历”的设计:<code>nextIndex</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">     e != <span class="keyword">null</span>;</span><br><span class="line">     e = tab[i = nextIndex(i, len)]) </span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/9b76747291534dd4b553699e0ea6b551.png" alt="在这里插入图片描述"></p>
<p>图1所示，假设目前有一个keyX定位到的桶位是i=13，但此桶位已存在entry，只能继续向后探测，来到数组尾部的桶位也不为空，此时经过<code>e = tab[i = nextIndex(i, len)]</code>的计算后，线性探测再次回到数组的头部位置重新遍历，如图2所示，当遍历到i=6时，发现此桶位为空，即可跳出循环接着在此位置放置新的entry，这就是“环形数组或者环形遍历”的底层设计逻辑。</p>
<h4 id="更加离散的hash计算"><a href="#更加离散的hash计算" class="headerlink" title="更加离散的hash计算"></a>更加离散的hash计算</h4><p>ThreadLocalMap内部的hash计算方式没有采用类似HashMap的计算方式,而是自行设计了一套</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">     * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">     * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">     * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">     * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">     * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">     * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">     * less common cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 巧妙利用了原子累加器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// hash值递增步长，每次对新的i计算hash值前先加上此数，计算结果能更加离散,这个值对应的十进制数为1640531527，这个值就是带符号的32位int的最大值的黄金分割值取正</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next hash code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次对新的i计算hash值前先加上此数，计算结果能更加离散</span></span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>模拟ThreadLocalMap的hash计算方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tableLength=<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">32</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h=i*HASH_INCREMENT+HASH_INCREMENT;</span><br><span class="line">            <span class="keyword">int</span> index=h &amp; (tableLength-<span class="number">1</span>);</span><br><span class="line">            System.out.println(i+<span class="string">&quot;定位的桶位是:&quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以观察不同桶位计算出的hash值确实足够离散：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0定位的桶位是:7</span><br><span class="line">1定位的桶位是:14</span><br><span class="line">2定位的桶位是:5</span><br><span class="line">3定位的桶位是:12</span><br><span class="line">4定位的桶位是:3</span><br><span class="line">5定位的桶位是:10</span><br><span class="line">6定位的桶位是:1</span><br><span class="line">7定位的桶位是:8</span><br><span class="line">8定位的桶位是:15</span><br><span class="line">9定位的桶位是:6</span><br><span class="line">10定位的桶位是:13</span><br><span class="line">11定位的桶位是:4</span><br><span class="line">12定位的桶位是:11</span><br><span class="line">13定位的桶位是:2</span><br><span class="line">14定位的桶位是:9</span><br><span class="line">15定位的桶位是:0</span><br><span class="line">16定位的桶位是:7</span><br><span class="line">17定位的桶位是:14</span><br><span class="line">18定位的桶位是:5</span><br><span class="line">19定位的桶位是:12</span><br><span class="line">20定位的桶位是:3</span><br><span class="line">21定位的桶位是:10</span><br><span class="line">22定位的桶位是:1</span><br><span class="line">23定位的桶位是:8</span><br><span class="line">24定位的桶位是:15</span><br><span class="line">25定位的桶位是:6</span><br><span class="line">26定位的桶位是:13</span><br><span class="line">27定位的桶位是:4</span><br><span class="line">28定位的桶位是:11</span><br><span class="line">29定位的桶位是:2</span><br><span class="line">30定位的桶位是:9</span><br><span class="line">31定位的桶位是:0</span><br></pre></td></tr></table></figure>
<h4 id="replaceStaleEntry方法解析（核心内容）"><a href="#replaceStaleEntry方法解析（核心内容）" class="headerlink" title="replaceStaleEntry方法解析（核心内容）"></a>replaceStaleEntry方法解析（核心内容）</h4><p>在set方法中的第4点：替换失效的entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 当前桶位的entry的key为null（注意这个key是弱引用类型，说明此entry已经被GC），使用replaceStaleEntry放入新entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>其源码设计包括两个重要的核心功能：替换对应位置失效的entry和具有顺带功能（As a side effect）的清理其他失效entry，其中清理entry的逻辑设计最为复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、staleSlot是对于给定key用线性探测法“前向遍历”找到的首次出现的stale entry对应的下标</span></span><br><span class="line"><span class="comment">    为何第1步骤的前向遍历没有安排类似第2步骤的“替换操作等逻辑呢”，因为“ThreadLocal本身用的是开发地址法，冲突的key都被放置在后面空的slot，就算来到table末尾再从头遍历，它也是遵循“向后放置发生冲突的key””</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">   <span class="comment">// 2. 从set方法传入的staleSlot下标开始向后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     以下逻辑非常关键：</span></span><br><span class="line"><span class="comment">     3.1 如果从stale slot开始的“后向遍历”的第i下标又出现了key冲突，说明给定的key“本应放在stale slot 下标位置，但是因为冲突，被迫挪到比stale slot 更靠后的位置i”，既然现在stale slot已失效，那么就可以将给定key放回本应该更靠近hash定位的下标位置staleSlot。这里采用交换两者位置即可实现此逻辑。这就是”to swap it with the stale entry to maintain hash table order”所要表达的逻辑。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;  </span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">           <span class="comment">// 3.2 如果slotToExpunge还是staleSlot，说明第1步骤的“前向探测”没有stale entry，那么就将清理起始下标改到i，因为i下标位置存放的是在3.1交换过来的stale entry：tab[i] = tab[staleSlot]</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        <span class="comment">/* 3.3 到此，我们知道，截止到i下标的stale entry情况ß：</span></span><br><span class="line"><span class="comment">         [某个空slot,staleSlot)：从staleSlot的前向位置都没有stale entry</span></span><br><span class="line"><span class="comment">         staleSlot：将i位置的有效entry交换过来tab[staleSlot] = e</span></span><br><span class="line"><span class="comment">         [staleSlot+1,i-1]：后向遍历没有出现stale entry</span></span><br><span class="line"><span class="comment">         i：存放的是从staleSlot交换过来的stale entry</span></span><br><span class="line"><span class="comment">         因此slotToExpunge肯定是从i下标开始做清理工作。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">      	<span class="comment">// 3.4 后向遍历在第i下标发现了一个stale entry且在前向遍历没有出现stale entry，那么清理开始下标当然要重置为i，那么staleSlot位置还存放着stale entry且没有也没有像3.1这样的“swap it”的设计，那么staleSlot自己是如何处理呢。它会在接下里的第4步骤中被处理掉！ 那么在这个步骤发现第i号下标新的stale entry又是如何处理呢？ 它会在第5个步骤被清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">   <span class="comment">/* 4. 在整个run都没有找到对应的key且也没有发现stale entry（除了staleSlot本身整个），那么好办，直接将staleSlot这个在set方法一开始就发现的stale entry的位置替换为新 entry即可，这就是为何方法名字命名为replaceStaleEntry。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">  <span class="comment">// 第5步骤：接第3.4步骤出现的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于“A run”的理解（理解run及其内部清理标记逻辑才能透彻理解set背后的原理）</p>
<p>As a side effect, this method expunges all stale entries in the “run” containing the stale entry(A run is a sequence of entries between two null slots.)<br><img src="https://img-blog.csdnimg.cn/ac10ec60579e410f910401b2ab956b87.png" alt="在这里插入图片描述"><br>如上图所示：</p>
<p>一个”run”就是在两个空slot之间的slots，例如上图，i=0和i=12之间就是一个“run”。 </p>
<p>1.为何这“run”是以两个空slot作为边界呢？</p>
<p>这是因为replaceStaleEntry的第1步骤使用prevIndex前向探测，直到遇到null slot则结束循环，而第2步骤使用nextIndex后向探测，直到遇到null slot则结束循环，因此可以得出一前一后都是null slot作为边界。</p>
<p>2.结合replaceStaleEntry的源代码分析的第1点：显然经过prevIndex的“前向探测”探测到了首个i=1的stale entry，因此slotToExpunge指向i=1表示此下标是接下expungeStaleEntry清理的起始下标。</p>
<p>3.根据1可知，如果slotToExpunge下标和staleSlot下标相等，说明“前向探测”根本没发现stale entry，也即slotToExpunge指向没动过。</p>
<p>4.根据第3.4步骤可知，<code>k == null &amp;&amp; slotToExpunge == staleSlot</code>，说明除了在set方法第一次发现的staleSlot，还在replaceStaleEntry的后向探测中的第i位置又发现了一个stale entry，因此起始清理下标要重置为slotToExpunge=i</p>
<p><img src="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png" alt="在这里插入图片描述"></p>
<p>关于replaceStaleEntry内部最关键的“替换算法”，也即对应第第3.1步骤到第3.3步骤如上图1和图2所示：</p>
<p>不妨假设i=8就是“给定的key”hash定位时发生的冲突下标，假设i=11的key1等于“给定的key”，也即对应第3.1步骤，</p>
<p>此时实施3.1步骤的“swap”逻辑：</p>
<p>将staleSlot=9的stale entry交换到key1的i=11位置，原i=11位置entry交换到staleSlot=9位置并且key不变但value被更新为“给定key对应的value”。</p>
<p>经过这么处理，“给定的key”所在桶位显然更靠近原本属于它的8号桶位，而不是像之前“被迫挪到”11号桶位，这就是源代码注释说提到的“we need to swap it with the stale entry to maintain hash table order”</p>
<p>以上的算法设计可以抽象为以下类比逻辑：</p>
<blockquote>
<p>A本应坐在1号位，但发现来晚了，1号位置有人坐了，2、3、4也有人坐了，A被迫坐在5号位，某个时刻“新来的B”发现2号位已经变成staleSlot且1号位还有人在坐，那么此时B可以将A交换到2号位且把2号位的stale entry交换到5号位，那么此刻位于2号位的A显然更靠近“本属于自己的1号座位</p>
</blockquote>
<h4 id="关于staleSlot的清理逻辑设计"><a href="#关于staleSlot的清理逻辑设计" class="headerlink" title="关于staleSlot的清理逻辑设计"></a>关于staleSlot的清理逻辑设计</h4><p>在4.2 中replaceStaleEntry为我们展示了精密的如何找出“起始清理下标”的算法设计，从</p>
<p><code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>可知，清理逻辑被设计为两部分：<br>第一部分：<code>expungeStaleEntry(slotToExpunge)</code>，此方法返回一个i下标。第一部分的清理可称为“线性地清理”——“linear expunge”。注意此过程还包括rehash过程！！</p>
<p>第二部分：<code>cleanSomeSlots(i, len)</code>，第二部分的清理可以称为“Heuristically expunge”，这里并不打算翻译为“启发性清理”，因为此处不建议使用中文硬翻译。（若要翻译，则可以翻译为“试探性地清理”）</p>
<p>以下是关于“线性地清理-expungeStaleEntry”的解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1.这里入参的staleSlot，就是replaceStaleEntry探测到的slotToExpunge下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 2.首先清空当前slotToExpunge下标的stale entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">  <span class="comment">// 3. 在slotToExpunge+1到恰好遇到null slot之间进行逐个探测清理</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 3.1 又出现stale entry可直接清空</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2 再次计算当前位置i放置的entry对应的hash值，如果hash值和当前i桶位一致，说明没有冲突，此entry恰好就是位于“本属于自己的桶位上”，如果hash值和当前i不一致，说明“此entry因为冲突被迫放到了第i位置，而第i位置不是此entry的直接定位”，可以将位于i桶位的“entry”放在“属于自己的h桶位”，这样就保证了entry能最大程度靠近或者就位于“本属于自己的桶位”范围以内，目的是为了提供线性探测查询效率！</span></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>); </span><br><span class="line">          	<span class="comment">// 从向后探测的开放地址法可知，h值更小，i值更大，正是因为原h位置有冲突，e才被放置到更靠后的第i位置</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">              <span class="comment">// 因为发生冲突被迫放置在i位置的entry,后面会被放到它的直接定位h桶位，因此i位置可以置为null</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">   虽然h桶位就是此entry的直接定位，但是考虑到h桶位可能被放置了其他entry，因此需要加入“向后探测”的逻辑，直到发现下一个位置为null slot。</span></span><br><span class="line"><span class="comment">   tab[h] = e  的写法就实现了“因为发生冲突被迫放置在i位置的entry，现在能够最接近地放到本属于自己直接定位的h桶位*/</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 显然此i就是第3步骤for循环里面从slotToExpunge向后探测到下一个null slot下标，此下标会被cleanSomeSlots方法中利用起来。</span></span><br><span class="line"><span class="comment"> for (i = nextIndex(staleSlot, len);</span></span><br><span class="line"><span class="comment">         (e = tab[i]) != null;</span></span><br><span class="line"><span class="comment">         i = nextIndex(i, len))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>expungeStaleEntry难点其实在第3.2步骤中遇到的情况，需要做个简单的rehash，保证entry更加靠近“本属于自己的直接定位h桶位”，过程解析参考以下算法流程：<br><img src="https://img-blog.csdnimg.cn/adb19cd01cd640d7bd8f5fc77a5daf8d.png" alt="在这里插入图片描述"><br>当然，如果在图2的中i=8不是null slot，那么从h位置开始<code>while (tab[h] != null)</code>探测，也会探测到i=10位置是个null slot，结果就是<code>table[h=i=10]=e</code>，e还是位于第i位置上。</p>
<h4 id="cleanSomeSlots-i-len-方法"><a href="#cleanSomeSlots-i-len-方法" class="headerlink" title="cleanSomeSlots(i, len)方法"></a>cleanSomeSlots(i, len)方法</h4><p>注意，要清楚<code>cleanSomeSlots(i, len)</code> i和len含义，否则无法理解cleanSomeSlots目的，这里的<code>i</code>就是<code>expungeStaleEntry</code>返回的一个空slot，len是table长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 3.</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//4 .</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 5.控制探测的次数</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.首先，考虑最简单的情况，如果第i和len之前都不存在stale entry，那么就相当于在1和len范围内折半探测，时间复杂度为log2(n)</p>
<p>2.其次，考虑到探测在i和len过程中，出现了stale entry，此时会将n重置为len长度，继续while，再一轮log2(n)次遍历</p>
<p>这就是所谓的“Heuristically scan”，因为是log2(n)，即使出现如2情况，此试探性的探测动作也是可以很快完成。</p>
<h4 id="set方法内部的rehash"><a href="#set方法内部的rehash" class="headerlink" title="set方法内部的rehash"></a>set方法内部的rehash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">      <span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 显然如果cleanSomeSlots返回true，表明在table中清理了不少于1个的stale entry，恰好可以腾出不少于1个空slot，显然不需要table扩容。</span></span><br><span class="line"><span class="comment">2. 当!cleanSomeSlots(i, sz) 表示没有遇到stale entry且table的entry数量已经达到了阈值，可以进入扩容逻辑</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">      <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">          rehash();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>rehash内部设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class="line"><span class="comment">   * table removing stale entries. If this doesn&#x27;t sufficiently</span></span><br><span class="line"><span class="comment">   * shrink the size of the table, double the table size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.扩容前，先从头到尾线性清理一下stale entry，运气好的话，清理的stale entry后恰好有足够多的null slot，这样省去真正的扩容操作，效率更高。</span></span><br><span class="line">      expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">      <span class="comment">// 2.此时的size是在1步骤清理完stale entry后的实际entry个数，只有当此时的size达到了0.75threshold才会去扩容，</span></span><br><span class="line">      <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Entry[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">      <span class="comment">// 这里看出是两倍扩容</span></span><br><span class="line">      <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">      Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 1.从旧表开始逐个遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">          Entry e = oldTab[j];</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">              <span class="comment">// 2.旧表当前j位置出现stale entry，那么直接将entry的value强引用设为null，Help the GC</span></span><br><span class="line">              <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 3. 旧表当前遍历位置j是正常的entry，那么用新表newLen计算它在新表的桶位号  </span></span><br><span class="line">                  <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                  <span class="comment">// 4. 开放地址法在新表中为“当前旧表遍历位置下entry”找到对应的null slot新表h位置</span></span><br><span class="line">                  <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                      h = nextIndex(h, newLen); <span class="comment">// 注意这里是在新表计算</span></span><br><span class="line">                  newTab[h] = e; </span><br><span class="line">                  count++; </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setThreshold(newLen);</span><br><span class="line">      size = count;</span><br><span class="line">      table = newTab; <span class="comment">// table 指向新表引用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rehash的逻辑相对简单。</p>
<h3 id="get方法解析"><a href="#get方法解析" class="headerlink" title="get方法解析"></a>get方法解析</h3><p>有了set方法完全解析流程后，对于get方法则很好理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="comment">// 1、ThreadLocalMap已经存在时</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getEntry才是正在在底层table去查找给定key对应的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果线程t的ThreadLocal内部ThreadLocalMap还未初始化，直接返回ThreadLocal初始化时设定的初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> getMap的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">  * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">  * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 这里可以看出，原来ThreadLocal并不是独立存在，而是它里面的ThreadLocalMap绑定当前线程的成员变量threadLocals，因此ThreadLocalMap的生命周期和线程同在</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">     t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">      * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">      * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"> ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">         table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">         <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">         table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">         size = <span class="number">1</span>;</span><br><span class="line">         setThreshold(INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>getEntry整体设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment"> * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment"> * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 1. 对应上面源代码注释提到“Only the fast path：a direct hit of existing key” 逻辑，也即给定key对应的i桶位的entry恰好存放的就是key的entry。</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">   <span class="comment">// 2. 说明这个key在之前是发生冲突了，放置到比i更靠后的位置，需要采用“后向探测”去检索。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key&#x27;s hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 从给定的entry开始后向遍历探测</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 1.找到，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 2.遇到stale entry，调用expungeStaleEntry清理它，此时i位置就是slotToExpunge起始清理的下标</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 3.继续向后探测下一个entry  </span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line"><span class="comment">// 目的是主动让entry的父类成员变量置null，那么entry自然就不会存在任何引用了，直接从正常的entry变成stale entry</span></span><br><span class="line">            e.clear(); </span><br><span class="line"><span class="comment">//            </span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> e.clear()关键逻辑：此方法来自<code>import java.lang.ref.Reference；</code>可以看到<code>e.clear()</code>目的是主动让entry的父类成员变量置null，那么entry自然就不会存在任何引用了，直接从正常的entry变成stale entry</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this reference object.  Invoking this method will not cause this</span></span><br><span class="line"><span class="comment"> * object to be enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment"> * clears references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal弱引用和内存泄露问题"><a href="#ThreadLocal弱引用和内存泄露问题" class="headerlink" title="ThreadLocal弱引用和内存泄露问题"></a>ThreadLocal弱引用和内存泄露问题</h3><p>在前面的所有内容中，我们都知道在线性探测中用<code>if (k == null)</code> 去判断当前桶位的entry是否为变为一个stale entry，放入一个正常的entry的为何会在某个时刻变成“失效的entry”？这是因为entry的key被设计为<code>WeakReference ,</code>这是ThreadLocalMap关键设计之一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">注意以下源代码的解析</span></span><br><span class="line"><span class="comment">   To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k); <span class="comment">// key 是弱引用类型</span></span><br><span class="line">            value = v; <span class="comment">// value 是强引用类型  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所谓的java弱引用：一旦有gc，那么WeakReference类型的对象就会被回收，用以下demo说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        Entry(String key,String value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Entry&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;key=&#x27;&quot;</span> + key + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Entry entry=<span class="keyword">new</span> Entry(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>); <span class="comment">// entry显然是一个强引用</span></span><br><span class="line">        WeakReference&lt;Entry&gt; entryWeakReference=<span class="keyword">new</span> WeakReference&lt;&gt;(entry); <span class="comment">// entryWeakReference是一个弱引用</span></span><br><span class="line"></span><br><span class="line">        System.gc();<span class="comment">// gc1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc1,entry:&quot;</span>+entry); <span class="comment">// Entry&#123;key=&#x27;foo&#x27;, value=&#x27;bar&#x27;&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc1,entryWeakReference:&quot;</span>+entryWeakReference.get()); <span class="comment">// Entry&#123;key=&#x27;foo&#x27;, value=&#x27;bar&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        entry=<span class="keyword">null</span>; <span class="comment">// 此时entry强引用被置为null，那么会被gc回收</span></span><br><span class="line">        System.gc();<span class="comment">// gc2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc2,entryWeakReference:&quot;</span>+entryWeakReference.get()); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after gc1,entry:Entry&#123;key&#x3D;&#39;foo&#39;, value&#x3D;&#39;bar&#39;&#125;</span><br><span class="line">after gc1,entryWeakReference:Entry&#123;key&#x3D;&#39;foo&#39;, value&#x3D;&#39;bar&#39;&#125;</span><br><span class="line">after gc2,entryWeakReference:null</span><br></pre></td></tr></table></figure>
<p>注意到ThreadLocalMap中的Entry，key类型是<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 弱引用的，因此一旦此key没有指向强引用，那么key显然会变为null，那么gc时作为key的ThreadLocal对象在jvm堆中就会被回收，对应的Entry就是一个<code>stale entry</code>，注意，如果Entry的value此时还不是null也即还是处于强引用类型状态，这会引出另外一个问题：ThreadLocal内存泄露问题，或者说：</p>
<p>为何ThreadLocal会有内存泄露问题？</p>
<p>其实比较好理解，首先ThreadLocal内部ThreadLocalMap存放的Entry对象和当前线程的生命周期一致，只要线程不结束，且Entry的value也即给ThreadLocal对象设置的value没有被删除（强引用还在），那么这个Entry就不会被回收，假设一个线程内部的ThreadLocalMap里面有很多这样的Entry，那么就会面临内存泄露的风险，</p>
<p>考虑线程池的情况，例如有线程使用ThreadlLocal对象，此线程位于线程池中会一直保持运行，对于它的ThreadlLocal对象内部的ThreadLocalMap来说，如果map中Entry的value没有被外界使用完后及时删除，就导致此Entry一直得不到回收，容易发生内存泄露。</p>
<p>Entry的key采用弱引用类型，value为何不采用同样的弱引用类型设计呢？</p>
<p>首先，key是线程本地变量ThreadLocal，它本身可以被回收，但是其变量的值value本身是在其他地方被使用着，例如value放着的是一个Session对象或者事务管理中的Connection对象，如果value被设计为弱引用类型，那么在也业务层面被使用“线程本地变量的value”——Session对象或者Connection对象就会随机被回收，导致业务层出错，显然无法接受这种情况。所以value保持强引用的设计才是符合实际情况的。</p>
<h4 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h4><p>代码中满足一定<code>ThreadLocal.get()、ThreadLocal.set()</code>逻辑设计的情况下，主动调用<code>ThreadLocalMap.remove</code> 来移除Entry对象的引用关系，这种高级且科学用法，其实在<code>ReentrantReadWriteLock</code>的源代码设计有所体现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      定义一个给每个线程自己的内部读锁计数器</span></span><br><span class="line"><span class="comment">      * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">      * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * ThreadLocal subclass. Easiest to explicitly define for sake</span></span><br><span class="line"><span class="comment">      * of deserialization mechanics.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">	<span class="comment">// 如何实现每个线程独立记录的读锁计数器？ 使用ThreadLocal即可保证线程隔离的计数，互不影响。</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  <span class="comment">// 线程自己持有的读锁计数器初始值0</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">      * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">      * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">     Sync() &#123;</span><br><span class="line">         readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">         setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程释放自己持有的读锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         <span class="comment">// 第一个持有读锁的线程恰好是当前线程，</span></span><br><span class="line">         <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">             <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">             <span class="comment">// “第一个持有读锁的线程” 也准备释放读锁，firstReader不再指向任何读线程</span></span><br><span class="line">             <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                 firstReader = <span class="keyword">null</span>;</span><br><span class="line">           	<span class="comment">// 否则“第一个持有读锁的线程”重入锁次数减1</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 firstReaderHoldCount--;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             HoldCounter rh = cachedHoldCounter;</span><br><span class="line">             <span class="comment">// 如果线程自己缓存的读锁计数器对象为空，或者线程自己的读锁计数器缓存的线程不是当前线程</span></span><br><span class="line">             <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 当前线程持有读锁的计数器readHolds</span></span><br><span class="line">                 rh = readHolds.get();</span><br><span class="line">             <span class="keyword">int</span> count = rh.count;</span><br><span class="line">             <span class="comment">// 当前线程持有读锁的计小于等于1，说明在本次读锁退出后，当前线程不再持有任何读锁，也即不再使用“计数器ThreadLocalHoldCounter”，因此用在它身上的ThreadLocal&lt;HoldCounter&gt;对象需要马上移除，避免ThreadLocal发生内存泄露。</span></span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                 readHolds.remove();</span><br><span class="line">                 <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">// 线程自己持有读锁自减1</span></span><br><span class="line">             --rh.count;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           	<span class="comment">// 总的读锁锁-1</span></span><br><span class="line">             <span class="keyword">int</span> c = getState();</span><br><span class="line">             <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                 <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                 <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                 <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                 <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>从这里<code>ReentrantReadWriteLock</code>的关于ThreadLocal的使用中，再次理解了源代码注释提到的“可以使得状态和线程关联起来”，这里的“状态”就是读线锁中的每个线程持有读锁的数量，显然它和该线程绑定了起来，因此体现ThreadLocal变量使用的完美场景。</p>
<h4 id="ThreadLocal在类中常见用法"><a href="#ThreadLocal在类中常见用法" class="headerlink" title="ThreadLocal在类中常见用法"></a>ThreadLocal在类中常见用法</h4><p>在ThreadLocal源代码文件的注释开头有提到以下说明：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
</blockquote>
<p>尤其这句<code>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</code></p>
<p>ThreadLocal实例通常是位于类中的私有静态字段，目的是为了实现把“状态”与线程（例如，用户ID或事务ID）绑定起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">  	 <span class="comment">// 放在类的静态字段位置，这样类的其他方法可以直接使用“此线程局部变量” </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">      			 <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个例子是在《Thinkinkg in Java 4》提供的demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> idn)</span></span>&#123;id=idn;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            ThreadLocalHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> +id+<span class="string">&quot;:&quot;</span>+ThreadLocalHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作为类ThreadLocalHolder的静态变量，并指定初始值的生成方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.set(value.get()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value.get();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个线程，每个线程都有ThreadLocalHolder的一个副本，且独立计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：可以看到5个线程实现自己内部的独立自增计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#0:7114</span><br><span class="line">#1:2381</span><br><span class="line">#2:7294</span><br><span class="line">#3:3291</span><br><span class="line">#4:5247</span><br><span class="line">#0:7115</span><br><span class="line">#1:2382</span><br><span class="line">#2:7295</span><br><span class="line">#3:3292</span><br><span class="line">#4:5248</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>这里也可以引出另外一个问题，ThreadLocal变量放在类中使用时，一般作为类的静态字段使用，为何？</p>
<p>其实很好理解，类的静态变量确保在类的多次实例化后仍然保持在内存中仅有一份副本，或者说为了避免重复创建thread specific object（与线程相关的变量），例如ThreadLocal变量管理了一个Session对象，那么当然希望在同一个线程中，此Session对象仅有一份实例，如果存在多份，那么就无法实现所谓“在同一session完成相关业务”的设计，导致逻辑出错。</p>
<h3 id="为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？"><a href="#为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？" class="headerlink" title="为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？"></a>为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？</h3><ol>
<li><p>首先，如果ThreadLocal使用ConcurrentHashMap来达到key-value管理目的，那么是无法实现“线程本地变量即：每个线程持有自己的本地实例”这样的需求，因此对于<code>Josh Bloch and Doug Lea</code>来说，需要给ThreadLocal设计全新一套的数据结构及其一些算法细节，以打造出可以支持和实现“线程本地变量且不需要基于任何锁的支持即可实现线程隔离”功能的数据结构，这显然是非常创新的工作，虽然ConcurrentHashMap的源代码设计已经堪称十分优秀。</p>
</li>
<li><p>其次，既然不采用ConcurrentHashMap这样内部复杂设计的Map结构，那么就要设计出非常高效、简约的数据结构，因此设计了底层只有一个数组table的ThreadLocalMap，不再有什么单链表、红黑树等结构，采用开放寻址法解决hash冲突，同时，只基于数组实现相关逻辑的代码会变得更加直观、简单，例如在扩容、清理stale entry方面，仅需基于数组的前后线性遍历即可。</p>
</li>
<li><p>ThreadLocal底层只基于一个数组table，结合设计特定的hash魔数，可以使得Entry的hash在数组中分散很均匀，大大降低了冲突概率，提高查询效率。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="prev" title="Java高级主题：LongAdder高并发计数性能分析">
      <i class="fa fa-chevron-left"></i> Java高级主题：LongAdder高并发计数性能分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/07/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84ConcurrentSkipListMap%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="next" title="Java高级主题：深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）">
      Java高级主题：深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">基本用法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#demo1"><span class="nav-number">1.1.</span> <span class="nav-text">demo1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#demo2"><span class="nav-number">1.2.</span> <span class="nav-text">demo2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal内部数据结构简析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">ThreadLocalMap的基本成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E6%96%B9%E6%B3%95%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">set方法完全解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set%E6%96%B9%E6%B3%95%E6%9C%AC%E8%BA%AB"><span class="nav-number">4.1.</span> <span class="nav-text">set方法本身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%8A%A0%E7%A6%BB%E6%95%A3%E7%9A%84hash%E8%AE%A1%E7%AE%97"><span class="nav-number">4.2.</span> <span class="nav-text">更加离散的hash计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replaceStaleEntry%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%88%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">replaceStaleEntry方法解析（核心内容）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EstaleSlot%E7%9A%84%E6%B8%85%E7%90%86%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.4.</span> <span class="nav-text">关于staleSlot的清理逻辑设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cleanSomeSlots-i-len-%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">cleanSomeSlots(i, len)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%9A%84rehash"><span class="nav-number">4.6.</span> <span class="nav-text">set方法内部的rehash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">get方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">remove方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">ThreadLocal弱引用和内存泄露问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">7.1.</span> <span class="nav-text">如何避免内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">ThreadLocal在类中常见用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95ThreadLocal%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E9%87%87%E7%94%A8ConcurrentHashMap%E8%BF%99%E6%A0%B7%E7%9A%84Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
