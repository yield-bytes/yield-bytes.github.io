<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在ReentrantLock的独占模式下，当需要在一个读写高度竞争场景中使用它的lock.lock()时，你会发现这是独占锁，它会让大量同时请求锁的线程们都不得不进入CLH阻塞队列中等待，如果在“读多写少”的场景中，ReentrantLock的这种独占锁方式显然会降低并发性能，因此ReentrantReadWriteLock就是为了解决这种“读多写少”的场景：一个线程正在请求锁进行读操作可以不影响">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：基于AQS实现的ReentrantReadWriteLock源代码深入分析">
<meta property="og:url" content="https://yield-bytes.github.io/2021/08/07/%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84ReentrantReadWriteLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="在ReentrantLock的独占模式下，当需要在一个读写高度竞争场景中使用它的lock.lock()时，你会发现这是独占锁，它会让大量同时请求锁的线程们都不得不进入CLH阻塞队列中等待，如果在“读多写少”的场景中，ReentrantLock的这种独占锁方式显然会降低并发性能，因此ReentrantReadWriteLock就是为了解决这种“读多写少”的场景：一个线程正在请求锁进行读操作可以不影响">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-06T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T14:12:39.921Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yield-bytes.github.io/2021/08/07/%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84ReentrantReadWriteLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：基于AQS实现的ReentrantReadWriteLock源代码深入分析 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/08/07/%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84ReentrantReadWriteLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：基于AQS实现的ReentrantReadWriteLock源代码深入分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-07T00:00:00+08:00">2021-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-18 22:12:39" itemprop="dateModified" datetime="2022-05-18T22:12:39+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>38k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在ReentrantLock的独占模式下，当需要在一个读写高度竞争场景中使用它的<code>lock.lock()</code>时，你会发现这是独占锁，它会让大量同时请求锁的线程们都不得不进入CLH阻塞队列中等待，如果在“读多写少”的场景中，ReentrantLock的这种独占锁方式显然会降低并发性能，因此ReentrantReadWriteLock就是为了解决这种“读多写少”的场景：一个线程正在请求锁进行读操作可以不影响其他线程同时请求读锁（共享锁），意味着多个线程可以并发读。</p>
<p>这里首先通过Doug Lea在源码注释给出的demo作为对ReentrantReadWriteLock一般用法说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读线程需要对data读取，写线程可以对data进行更新，那么data显然是线程不安全的，需要借助锁进行相关操作</span></span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid; <span class="comment">// 判断data是否已经被缓存</span></span><br><span class="line">  <span class="comment">// 1、创建一个读写锁</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock(); </span><br><span class="line"> <span class="comment">//该方式的功能就是对已经缓存的数据进行预处理 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、由于一开始，我们乐观认为data可能已经被缓存，因此我们不急着申请独占锁，而是申请并发的共享读锁</span></span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="comment">// 3、结果发现：我们太乐观了，原来data没缓存，因此还不能读取数据（如果非得去读，只能读到旧数据）</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      <span class="comment">// 4、既然乐观错估了情况，那么只能用上“强大的独占锁”，保证自己能独占的实施“写操作、更新操作、删除操作”：因为读写锁是互斥的，需先释放读锁，然后在升级为写锁。</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      <span class="comment">// 这就是所谓的“锁升级”。虽然说升级，但这里是当前线程请求独占锁，若同一时刻有其他线程已经拿到写锁，那么在这里当前线程会被阻塞在AQS里面的CLH阻塞队列</span></span><br><span class="line">      rwl.writeLock().lock(); </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="comment">// 5、由于我们获取写锁的时机也许比其他线程晚一步拿到，因此在这里拿到独占锁后，还得重新检查是否data已经提前被其他线程更新过</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ... <span class="comment">// 例如从数据库重新读取最新的data，然后将cacheValid标记为true，表示data已经更新（或已经更新缓存）</span></span><br><span class="line">          cacheValid = <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、由于我们还得使用更新后的data，因此可以申请读锁。注意，由于当前线程还持有写锁，因此其他线程不可能获得写锁进行写操作，因此当前线程此时可以申请读锁</span></span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7、显然data已经被我“独占式”地更新过，可以释放写锁了</span></span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 8、在第6点获得共享的读锁后，在这里可以使用已经缓存的新data</span></span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 9、释放读锁</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于读锁、写锁、读线程、写线程的一些说明"><a href="#关于读锁、写锁、读线程、写线程的一些说明" class="headerlink" title="关于读锁、写锁、读线程、写线程的一些说明"></a>关于读锁、写锁、读线程、写线程的一些说明</h4><p><code>rwl.readLock().lock()</code> `:很明显，线程在请求读锁，此锁是AQS的共享模式</p>
<p><code>rwl.writeLock().lock()</code>:很明显，线程在请求写锁，此锁是AQS的独占模式</p>
<p>严格来说：对于ReentrantReadWriteLock这种读写锁的设计，请求读锁的线程直接称为“读线程”可以吗，例如，请求写锁的线程，由于已经获取独占锁的线程可以去请求读锁，那么这个线程是应该称为“写线程”？“读线程”？还是“写、读线程”？还是“读写线程”呢？ 这么看来，请求到读锁的线程似乎也不适合称为读线程？成功请求到写锁的线程也不适合称为写线程。也许换一个角度可以更容易区分：</p>
<p>在用户代码层面的角度出发：</p>
<blockquote>
<p>1、用户设计此方法具有明显“读取”数据的逻辑时，该方法首先使用<code>`rwl.readLock().lock()</code> `，过程中不管是否需要再次请求写锁，都可以把执行用户方法的线程称为“读线程”</p>
<p>2、用户设计此方法具有明显“更新、删除、改、插入”数据的逻辑时，该方法首先使用<code>`rwl.writeLock().lock()</code> `，过程中不管是否需要再次请求写锁、还是读锁，都可以把执行用户方法的线程称为“写线程”</p>
</blockquote>
<p>但是从ReentrantReadWriteLock内部设计来看，可能按以下思路去想会更清晰：</p>
<blockquote>
<p>1、仅在ReentrantReadWriteLock内部调用tryAcquire方法来看，调用tryAcquire方法的线程可以看成是写线程，因为它是从<code>rwl.writeLock().lock()</code>来的</p>
<p>2、仅在ReentrantReadWriteLock内部调用tryAcquireShared方法来看，调用tryAcquireShared方法的线程可以看成是读线程，因为它是从<code>rwl.readLock().lock()</code>来的</p>
</blockquote>
<a id="more"></a>
<p>如果不按”用户代码”或者不按<code>ReentrantReadWriteLock</code>内部设计的角度，那么也可以按以下说明进行统一化描述：</p>
<p>“请求读锁的线程”、“持有读锁的线程”</p>
<p>“请求写锁的线程”、“持有写锁的线程”</p>
<p>在持有写锁的情况下，请求读锁的线程。</p>
<p>不存在“持有读锁的情况下，还能同时持有写锁的线程”的情形！  （否则此读锁已不是共享锁，而是变相成为了独占锁）或者说不满足“读写互斥设计”</p>
<h4 id="关于同步状态值的设计"><a href="#关于同步状态值的设计" class="headerlink" title="关于同步状态值的设计"></a>关于同步状态值的设计</h4><p>在ReentrantLock中，如何记录线程已经获得锁资源的次数呢？回顾代码设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 只有state为0时，其他线程才有机会争抢独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 同一线程再次获取独占锁，同一线程重入锁</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock仅有一个state值，对于同一线程执行<code>lock.lock()</code>n次，那么state变为n，表示此线程获取独占锁n次或者说重入n次（当然也要求此线程要释放n次），既然是独占锁，那么就不会出现这种情况：有多个不同线程同时成功更改state，也即同一个时刻，仅能有个线程CAS更改成功。</p>
<p>而在ReentrantReadWriteLock的同步状态值中，state的设计非常巧妙，使用高16位作为读锁重入的计数，低16位作为线程写锁重入的计数</p>
<blockquote>
<p>对于一个int值通过位运算实现不同场景下的计数，在Doug Lea的并发设计里面一个高级的手段：例如在ConcurrentHashMap里面的resizeStamp也采用这种移位计算状态的策略，还有ConcurrentHashMap的TreeBin读写锁设计也是采用位运算策略。</p>
</blockquote>
<p>高16位作为读锁重入的计数有两种情况：</p>
<p>（1）此高16位的数值可表示同一读线程的请求的读锁总数（总重入数）</p>
<p>（2）此高16位的数值可表示多个读线程同时请求到读锁总数</p>
<p>低16位作为写锁计数的情况仅有一种：</p>
<p>因为写锁是独占锁，因此低16位一定是表示同一写线程请求的总独占锁数量（总重入数）</p>
<p>以下是读写锁的同步计数移位计算的设计</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SHARED_SHIFT   = 16</span><br><span class="line">（1）读锁设计</span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);  用于获取state高16的读锁总数</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">// 1右移16位，对应的就是SHARED_UNIT</span><br><span class="line">0000 0000 0000 0001 0000 0000 0000 0000</span><br><span class="line"></span><br><span class="line">如何获取读锁总数？</span><br><span class="line">0000 0000 0000 0110 0000 0000 0000 0010;某一时刻state的值</span><br><span class="line">对其左移16位：</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0110</span><br><span class="line">因此可以快速得出读锁数量：6个读锁（当然也同时存在某个线程重入2次的写锁）</span><br><span class="line">以上就是sharedCount的设计</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line">如何实现读锁加1呢？如果直接state+1，那么这个加1是加在低位上，显然不合理，其实也很简单：</span><br><span class="line">state+(1&lt;&lt;SHARED_SHIFT)，这就实现在在高16位的读锁加1 </span><br><span class="line"></span><br><span class="line">（2） 写锁设计</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; 用于获取state低16位的写线程数量</span><br><span class="line">任意的state值和这个独占锁掩码相与后即可得到state的低16位置,例如下面</span><br><span class="line">0000 0000 0000 0110 0000 0000 0000 0010 ；;某一时刻state的值</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111 ；独占锁掩码</span><br><span class="line">两者取与后，得到写线程数量：</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">因此可以快速得出写锁数量：2个写锁（当然也同时存在6个读锁）</span><br><span class="line">以上exclusiveCount的设计</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">写锁如何加1？</span><br><span class="line">state+(1 &amp; EXCLUSIVE_MASK),显然state+1就是在state的低16位上做累加，计算公式合理</span><br><span class="line">写锁如何加n?</span><br><span class="line">state+(n &amp; EXCLUSIVE_MASK),显然state+n就是在state的低16位上做累加，计算公式合理</span><br><span class="line"></span><br><span class="line">（3）读锁最大可重入数量为65535，当然写锁也是</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1</span><br><span class="line">0000 0000 0000 0001 0000 0000 0000 0000 减1 也即：</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111 </span><br></pre></td></tr></table></figure>
<h4 id="写锁实现"><a href="#写锁实现" class="headerlink" title="写锁实现"></a>写锁实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个读写锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock(); </span><br><span class="line"><span class="comment">// 2、请求写锁</span></span><br><span class="line">rwl.writeLock().lock(); </span><br></pre></td></tr></table></figure>
<p>原来写锁的获取并不像ReentrantLock使用<code>lock.lock()</code>的方式，而是通过<code>writeLock().lock()</code>获取，从方法名就知道这样设计为了方便使用者知道当前使用什么类型的锁。</p>
<p>首先看其构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">   * default (nonfair) ordering properties.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;  <span class="comment">// 默认构造器使用的是非公平模式</span></span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">   * the given fairness policy.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">      sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">      readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);  <span class="comment">// new时就已经实例化一个readerLock 对象和 writerLock 对象</span></span><br><span class="line">      writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">// Sync当然是ReentrantReadWriteLock内部核心实现类，实现了AQS的tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared的关键逻辑，以及其他辅助方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// <span class="title">WriteLock</span>和 <span class="title">ReadLock</span> 都是<span class="title">ReentrantReadWriteLock</span>内部类</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">ReentrantReadWriteLock</span>.<span class="title">WriteLock</span> <span class="title">writeLock</span>() </span>&#123; <span class="keyword">return</span> writerLock; &#125; </span><br><span class="line">  <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h5 id="WriteLock实现类"><a href="#WriteLock实现类" class="headerlink" title="WriteLock实现类"></a>WriteLock实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for use by subclasses</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// WriteLock的调用点是在ReentrantReadWriteLock的构造器中：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public ReentrantReadWriteLock(boolean fair) &#123;</span></span><br><span class="line"><span class="comment">        sync = fair ? new FairSync() : new NonfairSync();</span></span><br><span class="line"><span class="comment">        readerLock = new ReadLock(this);  </span></span><br><span class="line"><span class="comment">        writerLock = new WriteLock(this);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the write lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the write lock if neither the read nor write lock</span></span><br><span class="line"><span class="comment">     * are held by another thread</span></span><br><span class="line"><span class="comment">     * and returns immediately, setting the write lock hold count to</span></span><br><span class="line"><span class="comment">     * one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread already holds the write lock then the</span></span><br><span class="line"><span class="comment">     * hold count is incremented by one and the method returns</span></span><br><span class="line"><span class="comment">     * immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is held by another thread then the current</span></span><br><span class="line"><span class="comment">     * thread becomes disabled for thread scheduling purposes and</span></span><br><span class="line"><span class="comment">     * lies dormant until the write lock has been acquired, at which</span></span><br><span class="line"><span class="comment">     * time the write lock hold count is set to one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 从这里可以看出：类似的用户程序使用rwl.writeLock().lock()时，其实就是调用AQS的独占锁的获取锁逻辑：acquire(1)，显然既然是独占锁，那么获取逻辑自然跟ReentrantLock的lock()是类似的，也即AQS的acquire方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	...<span class="comment">//WriteLock类其他省略部分</span></span><br><span class="line">              </span><br></pre></td></tr></table></figure>
<p>显然<code>sync.acquire(1)</code>对应内部的AQS逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// tryAcquire由ReentrantReadWriteLock的sync实现</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="写锁获取-tryAcquire"><a href="#写锁获取-tryAcquire" class="headerlink" title="写锁获取-tryAcquire"></a>写锁获取-tryAcquire</h5><p>要知道所谓的写锁获取，其实就是独占锁的请求，要么仅能一个线程拥有此独占锁，要么同一线程重入独占锁多次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Walkthrough:攻略或玩法，也即tryAcquire的成功与否的策略</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 当前同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 当前写锁计数（需要利用移位来计算出）</span></span><br><span class="line">  	<span class="comment">// 由于同步状态可以表征读锁计数和写锁计数，因为当前线程想获取写锁，因此它需要判断：同步状态值不为0到底是指有其他线程获取到了写锁还是获取了读锁还是都被获取？</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 1、c != 0且写锁计数为0，说明当前线程持有读锁，不允许请求写锁（否则就是持有读锁情况下拿到写锁，那么这个读锁就不是共享模式读锁，而是变相的独占锁，显然违背了ReentrantReadWriteLock的功能设计初衷）；或者说“当前线程持有读锁且不释放读锁的情况下，不允许升级为写锁，否则读锁就变相的成为了独占锁”</span></span><br><span class="line">       <span class="comment">// 2、写锁计数不为了0，说明是当前线程正在重入独占锁，如果不是同一线程请求，写锁当然请求失败，返回false</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">// 3、是当前线程重入的写锁请求，但重入次数超过最大值，直接抛出异常提示</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">      	<span class="comment">// 4、说明是同一线程的写锁重入，累加计数后，允许通过请求锁。</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 5、执行流来到这里说明c等于0，说明此刻暂时还没其他线程在竞争读、写锁，那么当前线程可以去CAS抢锁</span></span><br><span class="line">  <span class="comment">/* writerShouldBlock() 是用于是否使用公平模式抢锁策略，对于写锁获取策略来说，显然是false，如下所示</span></span><br><span class="line"><span class="comment">static final class NonfairSync extends Sync &#123;</span></span><br><span class="line"><span class="comment">	private static final long serialVersionUID = -8159625535654395037L;</span></span><br><span class="line"><span class="comment">  final boolean writerShouldBlock() &#123; return false; // writers can always barge ，写锁获取只能直接争抢</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">	因此这里的if第一个writerShouldBlock()返回false然后第二个条件就是去跟其他写线程CAS抢锁了，失败那么只能返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 6、对于c != 0，说明此写线程重入成功，对于c=0，说明此线程是第一个获得独占锁的线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="写锁释放-tryRelease"><a href="#写锁释放-tryRelease" class="headerlink" title="写锁释放-tryRelease"></a>写锁释放-tryRelease</h5><p>用户代码层面，只需调用<code>rwl.writeLock().unlock()</code>来释放写锁，需要注意的是，这里指代独占锁的释放，意味着要么已经拥有独占锁的写线程释放此锁，要么已经重入独占锁的写线程退出重入锁 </p>
<p>（读锁的释放也会使用此方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is the holder of this lock then</span></span><br><span class="line"><span class="comment">     * the hold count is decremented. If the hold count is now</span></span><br><span class="line"><span class="comment">     * zero then the lock is released.  If the current thread is</span></span><br><span class="line"><span class="comment">     * not the holder of this lock then &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * IllegalMonitorStateException&#125; is thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if the current thread does not</span></span><br><span class="line"><span class="comment">     * hold this lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//按照注释提示：</span></span><br><span class="line"><span class="comment">// 1、如果当前线程是重入的，那么每次unlock就是对重入次数减1，也即此线程内部写锁计数hold count 减1 （注意，如果hold count减1后不为0，此写线程是不会释放独占锁的）</span></span><br><span class="line"><span class="comment">// 2、如果当前线程的不是重入，仅是获取独占锁一次，那么当它调用unlock时，显然state变为0，意味着是释放独占锁，其他线程可以争抢此独占锁了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">     * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">     * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">     * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 释放锁的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// 扣减释放量</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; <span class="comment">// 这里的free是指写锁释放完全释放，如果等于0，说写锁完全被释放。</span></span><br><span class="line">      	<span class="comment">// 如果为0，说明写锁完全被释放，其他线程（含读、写线程）可以争抢了</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      	<span class="comment">// free不为0，说明是同一线程重入写锁后，现在是释放自己重入的写锁，也即“重入-退出”操作，将state设为扣减后的值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="读锁实现"><a href="#读锁实现" class="headerlink" title="读锁实现"></a>读锁实现</h4><p>读锁的实现类最关键的还是<code>lock</code>和<code>unlock</code>方法，具体实现由<code>ReentrantReadWriteLock</code>  内部的<code>Sync</code>类的<code>tryAcquireShared</code>和<code>tryReleaseShared</code>对应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The lock returned by method &#123;<span class="doctag">@link</span> ReentrantReadWriteLock#readLock&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for use by subclasses</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the read lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">     * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">     * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">     * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>); <span class="comment">// 具体获取读锁的逻辑在tryAcquireShared实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 响应中断的获取读锁方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即时返回是否成功获取读锁，显然如果写锁别其他线程持有，那么此时tryLock() 立即返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否读锁，具体释放读锁的逻辑在tryReleaseShared实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125; because</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ReadLocks&#125; do not support conditions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string identifying this lock, as well as its lock state.</span></span><br><span class="line"><span class="comment">     * The state, in brackets, includes the String &#123;<span class="doctag">@code</span> &quot;Read locks =&quot;&#125;</span></span><br><span class="line"><span class="comment">     * followed by the number of held read locks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string identifying this lock, as well as its lock state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = sync.getReadLockCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">            <span class="string">&quot;[Read locks = &quot;</span> + r + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="读锁获取-tryAcquireShared"><a href="#读锁获取-tryAcquireShared" class="headerlink" title="读锁获取(tryAcquireShared)"></a>读锁获取(tryAcquireShared)</h5><p>调用者使用<code>rwl.readLock().lock()</code> 获取读锁，内部调用是acquireShared方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires the read lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment"> * another thread and returns immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment"> * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireShared当然是AQS的模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 只要ReentrantReadWriteLock的tryAcquireShared获取读锁方法返回-1，就说明当前线程没能马上获得读锁，得去CLH排队等待</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryAcquireShared</code>则是<code>ReentrantReadWriteLock</code>实现请求读锁的关键逻辑</p>
<p>其实<code>tryAcquireShared</code>总逻辑分为4部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 第1部分：全局存在写锁且不是当前线程持有，因此当前线程不能获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 第2部分：全局层面获得读锁</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">	 </span><br><span class="line">      <span class="comment">// 第3部分:&#123;第2部分的全局层面获得读锁后，还得对当前线程自己持有的读锁计数进行相关管理&#125;，这部分最为核心，也是最难理解的部分。</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 第2部分的全局层面获得读锁，必然返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第4部分：在全局层面获取读锁失败，使用以下全面尝试获取读锁的逻辑去获取读锁，增加当前线程获取读锁的概率。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">          	<span class="comment">//1、 当前state存在写锁计数但不是当前线程持有，那么不容许获取读锁，因为两者被设计为是互斥的，换句话说：在有写锁存在的条件下，只能是已经持有写锁的当前线程才能获取当前读锁，当然这种情况被称为“锁降级”。想想为何？</span></span><br><span class="line">           <span class="comment">//  因为如果存在写锁的条件下但不是当前线程持有，还去允许当前线程获取读锁的话，这不就等价于将别人占有的写锁“抢了过来”，这显然是不符合ReentrantReadWriteLock的读写互斥设计的。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//2、当前state拥有的读锁数量</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">          	<span class="comment">//3、如果此时读线程是非公平模式且读锁计数小于最大值且CAS更新读锁计数加1成功，那么就执行此if里面的条件</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123; </span><br><span class="line"><span class="comment">// 在state的高16位累加1，也即使得所有线程总的读锁计数加1,执行流来到这里，说明当前线程已经成功获得读锁，下面就是要完成当前线程持有读锁的计数管理相关逻辑。</span></span><br><span class="line">              </span><br><span class="line">              	<span class="comment">//4、在2读取的r值如果为0，说明当前线程是第一个进来请求读锁的线程，记为firstReader</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// 记录第一个读线程的重入数量，首次当然是1 </span></span><br><span class="line">               <span class="comment">//  5、 如果在第2点读取的读锁数量不为0且当前线程就是之前的第一个读线程，说明是重入，对第一个读线程的重入进行计数加1 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">               <span class="comment">// 6、以下的读锁设计比较难理解，参考后面的内容分析。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 读取“全局缓存计数器”，注意到此“全局缓存计数器”只缓存“最新成功获取读锁的那个线程”：The hold count of the last thread to successfully acquire readLock，目的是This saves ThreadLocal lookup，避免回到ThreadLocalHoldCounter的readHolds去查找。</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                   <span class="comment">/* 6.1 </span></span><br><span class="line"><span class="comment">                  	情况1 如果此“全局缓存计数器”变量为空，说明在此刻之前没有“最新成功获取读锁的那个线程””出现，那么当前线程自然可以将自己设为“最新成功获取读锁的那个线程”这个角色</span></span><br><span class="line"><span class="comment">                  	情况2 如果此“全局缓存计数器”变量不为空但已经缓存“最新成功获取读锁的那个线程”，而这个缓存线程又不是当前线程，说明当前线程从此刻起将成为“最新成功获取读锁的线程”角色。</span></span><br><span class="line"><span class="comment">                  	针对情况1和情况2，既然当前线程在此刻已经成为“最新成功获取读锁的线程”角色，那么当前线程取出自己的计数器并放入“全局缓存计数器”：cachedHoldCounter = rh = readHolds.get()。这样就保证了cachedHoldCounter会一直指向“最新成功获取读锁的线程”  </span></span><br><span class="line"><span class="comment">                  	*/</span></span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="comment">/*6.2</span></span><br><span class="line"><span class="comment">                   说明6.1两个条件都不成立，说明“全局缓存计数器”缓存的恰好是当前线程，如果缓存的读锁计数为0，那么说明这个线程是在上一刻释放了自己持有的最后一个读锁且将“全局缓存计数器”计数减至0（并且它会调用readHolds.remove()移除了rh计数器对象，这一操作可以发生在tryReleaseShared中），现在这一刻此线程又再次进来作为“最新成功获取读锁的线程”，而此刻当前线程自己readHolds并没有放置计时器，于是作为“最新成功获取读锁的线程”，当前线程再将计数器放入到自己的“ThreadLocalHoldCounter的readHolds中”。</span></span><br><span class="line"><span class="comment">                   */</span> </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）"><a href="#关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）" class="headerlink" title="关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）"></a>关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）</h5><p>首先，读锁的计数需要在两个层面上进行去理解：</p>
<p>所有线程请求的总读锁计数的加1操作，使用以下方式记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 也即每个线程，只要请求读锁成功，那么读锁总数对应加1（state的高16位加1）  </span></span><br><span class="line"><span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">           r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">           compareAndSetState(c, c + SHARED_UNIT)) &#123; </span><br></pre></td></tr></table></figure>
<p>其次，还需要记录每个线程自己请求读锁的数量（或者重入读锁的次数），也即“当前线程自己持有的读锁计数进行相关管理”。这里解释为何每个线程需要记录自己读锁的数量，这是因为ReentrantReadWriteLock设计的读锁是可重入的，那么每个线程管理自己的读锁数量后，可以方便进行且准确的加锁、释放锁操作（自己重入多少次，就需要释放多少次）以及是否需要进入排队操作。<code>而compareAndSetState(c, c + SHARED_UNIT)</code>是记录所有线程的总读锁数量的设计，显然无法实现“当前线程自己持有的读锁计数进行相关管理”的功能。</p>
<p>这种要实现“每个线程自己的状态管理和线程关联起来”的场景，ThreadLocal无疑是最适合的，这在“ThreadLocal的源代码设计的深度解析”的文章中已提及过。在这里通过设计一个计数器HoldCounter并放入到ThreadLocal，也即ThreadLocalHoldCounter，即可实现线程安全方式实现“当前线程自己持有的读锁计数进行相关管理”的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解本节内容的前提是掌握ThreadLocal的底层设计原理及其源代码实现，否则无法掌握其设计内涵。	</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">     * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 1、此辅助对象就是为了记录当前线程请求读锁的次数，目的是为了知道此线程第一有没有持有读锁，第二持有读锁情况下重入多少次。交由ThreadLocal来维护。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 记录当前线程的读锁请求次数</span></span><br><span class="line">        <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">      	<span class="comment">// 当前线程的内存地址ID号，用于一些特别场景例如下面的cachedHoldCounter</span></span><br><span class="line">		<span class="comment">// 使用线程ID号而不是对象可以有效优化GC</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2、通过ThreadLocal维护HoldCounter的更新，实现每个线程能线程安全的方式去管理持有读锁的计数。</span></span><br><span class="line"><span class="comment">// 这里是设定HoldCounter的初始化值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">     * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">     * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 3、当前线程持有读锁的重入次数，如果不为0，说明当前线程肯定持有读锁,需要注意它的灵活用法:</span></span><br><span class="line"><span class="comment"> 总体上一定要遵守“当前线程不再持有读锁时，当前线程的ThreadLocal对象一定不能还存放着HoldCounter对象，否则HoldCounter是强引用，会造成当前线程的ThreadLocal出现内存泄露的风险”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 3.1 一旦当前线程释放自己持有的最后一个读锁，说明当前线程不再需要持有“读锁计时器”引用来给自己计算读锁数量，那么当前线程还需要做多一个操作： readHolds.remove(),保证当前线程不再引用此“ThreadLocal变量”的读锁计数器，从而避免当前线程的ThreadLocal内存泄露，对应的代码逻辑（此逻辑一般在释放锁的操作中实施）：</span></span><br><span class="line"><span class="comment">       if (count &lt;= 1) &#123;</span></span><br><span class="line"><span class="comment">                readHolds.remove();</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> readHolds = new ThreadLocalHoldCounter() ,当然此初始化已经被上面initialValue取代了。</span></span><br><span class="line"><span class="comment"> 每个线程持有的readHolds初始值：count=0，tid=此线程内存地址ID</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 3.2 如果当前线程查询自己readHolds的rh.count=0,说明当前线程是第一次成功获取读锁，考虑当前线程以后可能有重入读锁，那么此时可以将自己“读锁计数器” rh放到readHolds里面，对应的代码逻辑（此逻辑一般在请求读锁的操作中实施）：</span></span><br><span class="line"><span class="comment">         else if (rh.count == 0)</span></span><br><span class="line"><span class="comment">                    readHolds.set(rh);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">     * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">     * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">     * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">     * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">     * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">     * reference to the Thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model&#x27;s final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此cachedHoldCounter从名字可以直到它是一个缓存的读锁计数器，那么它是缓存哪个线程的读锁计时器呢？</span></span><br><span class="line"><span class="comment">// 缓存的是“最近（最新）获得读锁的那个线程的读锁计数器”，例如Thread-0、Thread-1、Thread-2三个线程并发竞争读锁，如果Thread-1是最后一个成功获取读锁的线程，那么cachedHoldCounter就会缓存Thread-1的读锁计数count=1和Thread-1对应的内存地址ID号。当然如果后面还有最新的来的Thread-xx，那么cachedHoldCounter就会马上更新缓存Thread-xx的信息。</span></span><br><span class="line"><span class="comment">/* 这个缓存cachedHoldCounter有何作用呢？ </span></span><br><span class="line"><span class="comment">（1）在前面ThreadLocalHoldCounter中，每个线程HoldCounter由ThreadLocal维护，如果此线程需要查询自己的读锁计数，需要使用ThreadLocal里面的get方法，而此get方法会调用ThreadLocal里面ThreadLocalMap的getEntry方法，了解ThreadLocal的底层设计都知道这一get操作还可能引起ThreadLocalMap的额外清理操作，这无疑降低查询效率，因此干脆设计用于“具有缓存功能、快速查询”的cachedHoldCounter，如果当前线程恰好就是设置cachedHoldCounter的线程，那么它直接在cachedHoldCounter就可以拿到自己的读锁数，完全不需要调用ThreadLocal里面get方法来查询（避免了在ThreadLocalMap内部的一系列操作）通过这种方式，当前线程在读锁重入时能提高加锁效率。</span></span><br><span class="line"><span class="comment">  （2）当前如果读锁竞争激烈，那么假设线程加锁后缓存了Thread-1，在Thread-1释放锁前，又有其他线程Thread-2、Thread-3请求了读锁，那么cachedHoldCounter就会一直更新，这种情况导致Thread-1需要调用ThreadLocal查询自己的读锁计数。可以说Thread-1在请求读锁重入锁期间没有“享受到缓存带来的性能提升”</span></span><br><span class="line"><span class="comment">  正如源码注释里面的说的：This is non-volatile since it is just used as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">  因为这是被设计为一个试探性的缓存，因此不需要设为volatile类型，如果当前线程试探性去查询发现此缓存是自己加锁后设置的缓存，那么就可以提高此线程的本次加锁和释放读锁的性能，如果不是自己设置缓存，那就稍微牺牲一点性能ThreadLocal（在内部的ThreadLocalMap）去查询。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">     * firstReaderHoldCount is firstReader&#x27;s hold count.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">     * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">     * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">     * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">     * sets it to null.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model&#x27;s out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">     * locks to be very cheap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* 以下两个成员也是为了提升读锁加速的性能。认真看其源码注释说：更准确地说，firstReader是指向一个线程———这个线程是让总读锁计数从0变为1的线程。注意需要用动态的思维看待这样的解释。简单来说就是第一个获得读锁的线程，firstReaderHoldCount显然就是第一个获得读锁线程的重入计数</span></span><br><span class="line"><span class="comment">那么在什么场景下firstReader和firstReaderHoldCount起到提升性能的作用呢？</span></span><br><span class="line"><span class="comment">对于这种有序获取读锁的场景，优化效果明显，例如，</span></span><br><span class="line"><span class="comment">Thread-0加锁-释放锁后，接着Thread-1才开始请求读锁，Thread-1释放读锁，然后Thread-2才开始请求读锁....</span></span><br><span class="line"><span class="comment">可以这么理解：</span></span><br><span class="line"><span class="comment">当Thraed-0作为第一个请求读锁的线程，它从加锁到释放锁的代码执行期间，此时Thread-1还没开始启动请求读锁。那么当Thread-0再次重入锁时（而且此刻还没其他线程来请求读锁），显然只需查询firstReaderHoldCount自己的读锁计数即可，无需进入自己的ThreadLocal里面去查询读锁计数，因为进入ThreadLocal去查询意味着要去ThreadLocalMap查询（get操作还可能引起清理stale entry）意味着降低查询效率。</span></span><br><span class="line"><span class="comment">这就是注释所说的：This allows tracking of read holds for uncontended read locks to be very cheap. 能够使用最小代价去追踪那种非竞争线程获取的读锁计数</span></span><br><span class="line"><span class="comment">uncontended read locks：一个线程拥有读锁的时候，没有其他线程企图获得读锁（也就是非并发竞争的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure>
<p>可以看到，读锁的获取设计确实较为复杂，因为Doug Lea为了实现在某些非竞争情况下请求锁性能的提升，采用了非常高技巧的“fast path”策略——先试探性执行某个“快速”操作，如果没命中那就再执行那个“相对耗时”的操作。（这种设计思想其实在ConcurrentHashMap里面的<code>addCount</code>和<code>fullAddCount</code>已经体现过）</p>
<p>其次可以通过一个内部方法快速理解线程自己管理的读锁计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 获取当前线程想获取自己持有读锁的数量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="comment">// 1. 如果总读锁数量为0，那么当前线程持有的读锁数量肯定也为0</span></span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">    		<span class="comment">// 2. 看看自己是否为第一个获取读锁的角色，如果是，好办直接使用firstReaderHoldCount存储的数量即可，无需进入到ThreadLocal里面查询</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line">		<span class="comment">// 3. 说明当前线程不是“第一个获取读锁”的线程，那就看看“全局缓存计时器”缓存的是哪个线程的</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    		<span class="comment">// 4. 如果存在“全局缓存计时器”且缓存的就是当前线程自己，那么说明当前线程一定是“最新获取读锁的那个线程”，返回缓存的计数即可</span></span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="comment">// 5. 说明自己不是“最新获取读锁的那个线程”，当然也不是“第一个获取读锁的角色”，因此要读取自己持有的读锁计数，显然要先取出自己在ThreadLocal放置的计时器</span></span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">    		<span class="comment">// 6. 自己在ThreadLocal放置的计时器的读锁数量已经变为0，说明当前线程接下来已经不再持有读锁，也即不需要再借助“计数器”，那么应该及时在自己的ThreadLocal变量删除此“计数器对象”——ThreadLocalHoldCounter</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有了以上缓存和快速试探的算法设计以及线程自己是如何管理自己持有的读锁的分析后，那么<code>fullTryAcquireShared</code>的算法流程才相对好理解。</p>
<h5 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h5><p>处理“快速尝试tryAcquireShared中CAS失败更新总读锁”的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">     * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 正如注释里面说的：专为快速尝试tryAcquireShared中CAS失败更新总读锁、重入读锁的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">         * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">         * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">         * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      	<span class="comment">// 注释也说到fullTryAcquireShared的总体代码实现跟tryAcquireShared大体类似（有部分冗余）</span></span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 自旋+内部CAS，保证了当前线程一定会在某个时机上成功拿到读锁，或在某个时机拿不到锁然后被放入CLH阻塞队列里面排队</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">          	<span class="comment">// 1、同tryAcquireShared的设计，同步状态存在写锁，且是其他线程持有的写锁，显然当前线程无法获取读锁，因为不同线程的写、读锁请求是互斥的。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// A</span></span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              	<span class="comment">// else return -1</span></span><br><span class="line">              	<span class="comment">//补充技术点：注意到这里有个死锁的解释：假设给A配一个else分支，返回-1，那么就使得持有写锁的当前线程进入阻塞队列，它持有的写锁一直不会释放，而外面的线程又等着这个写锁的释放，因此进入了死锁困境，所以不能在这里return -1。换句话说，不要试图阻塞已持有的独占锁线程，否则会出现死锁意外。其实这种合理的设计在AQS的条件队列await里面的“addConditionWaiter然后fullyRelease”有提到（进了条件队列后，阻塞前把自己持有的所有独占锁完全释放掉）</span></span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line">              <span class="comment">// 2、来到这里说明此时写锁计数为0，暂时没有其他线程请求写锁，当前线程可以去请求读锁但遗憾的是readerShouldBlock为true时，表示当前线程需要被阻塞，而if里面的逻辑并没有关于“进入CLH阻塞队列排队的操作”，原来这里的if是这么设计的：既然当前线程待会要进去阻塞队列，那么在它进去之前，要求当前线程先处理好自己的读锁计数情况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 如果存在这样的场合：假设某线程AA在某次tryAcquireShared请求读锁成功，然后在某次重入读锁时tryAcquireShared没有抢到读锁只能调用fullTryAcquireShared来处理重入锁时，线程AA来到if (readerShouldBlock()) 为true情况，接下里怎么安排呢？ 以下就是对应的处理策略：                 </span></span><br><span class="line">              	<span class="comment">// 3.1 如果当前线程就是第一个加读锁的线程，说明是重入读锁，即使readerShouldBlock为true，当前线程也不需要去阻塞队列排队（也即不需要在这里return -1），因为对于重入锁情况，直接它进入下面的第11位置执行重入锁逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                  	<span class="comment">// 并没有直接返回-1</span></span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3.2 说明当前线程不是firstReader也不是firstReader的重入，而是此线程是第一次竞争读锁，但因为大前提readerShouldBlock是true，因此此线程一定会进入CLH阻塞队列。</span></span><br><span class="line">                <span class="comment">// 4、 </span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                      	<span class="comment">//5、</span></span><br><span class="line">                      	<span class="comment">// 5.1 当前线程（显然是非firstReader角色）如果是第一次请求读锁，发现cachedHoldCounter还是空或者里面缓存不是自己的，从自己的ThreadLocal取出HoldCounter对象,然后进入6.1</span></span><br><span class="line">                      	<span class="comment">// 5.2 当前线程是重入锁的情况，显然rh不是null，且6.1的判断不成立,会走入7.2逻辑</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                          <span class="comment">// 6、</span></span><br><span class="line">                          <span class="comment">//  6.1 对接5.1 由于当前线程是第一次请求读锁，但此时并没有拿到读锁，需要清空自己的ThreadLocal里面的HoldCounter对象，然后会来到7.1。因为这个线程将被送入CLH阻塞队列中，既然它准备要在阻塞队列了，那么它的ThreadLocal存放的HoldCounter对象要移除，避免ThreadLocal造成此线程的内存泄露。然后会进入7.1步骤</span></span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  	<span class="comment">// 7、</span></span><br><span class="line">                  	<span class="comment">// 7.1 当前线程第一次请求读锁,此时它持有读锁数量是0，由于readerShouldBlock为true，因此当前线程不能直接竞争读锁要去阻塞队列排队等待，因此返回-1</span></span><br><span class="line">                  	<span class="comment">// 7.2 当前线程是重入情况，显然rh.count不等于0，因此会进入第12的重入锁累加</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8、 读锁总数达到最大值</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">          	<span class="comment">// 9、如果当前线程CAS对总读锁加1成功，那么结果一定是返回1，中间逻辑就是线程对自己的计数器加1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//10、发现此时读锁为0，那么当前线程就变成firstReader角色。</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 11、firstReader的重入  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                <span class="comment">// 12、 当前线程（其他线程，非firstReader角色）的第一次请求读锁或者重入锁的情况 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="comment">// 12.1 rh为空，说明准备要将缓冲计时器cachedHoldCounter指向当前“最新成功获取读锁的线程”</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">/* 12.2 </span></span><br><span class="line"><span class="comment">              	情况1 如果此“全局缓存计数器”变量为空，说明在此刻之前没有“最新成功获取读锁的那个线程””出现，那么当前线程自然可以将自己设为“最新成功获取读锁的那个线程”这个角色</span></span><br><span class="line"><span class="comment">              	情况2 如果此“全局缓存计数器”变量不为空但已经缓存“最新成功获取读锁的那个线程”，而这个缓存线程又不是当前线程，说明当前线程从此刻起将成为“最新成功获取读锁的线程”角色。</span></span><br><span class="line"><span class="comment">              	针对情况1和情况2，既然当前线程在此刻已经成为“最新成功获取读锁的线程”角色，那么当前线程取出自己的计数器并放入“全局缓存计数器”：放入的前提是rh.count == 0，说明当前线程是“最新成功获取读锁的线程”且不是重入的，cachedHoldCounter = rh = readHolds.get()。这样就保证了cachedHoldCounter会一直指向“最新成功获取读锁的线程”  。</span></span><br><span class="line"><span class="comment">              	如果当前线程是重入请求读锁，那么这里if (rh.count == 0)就不会成立，自然不会有readHolds.set(rh)</span></span><br><span class="line"><span class="comment">              	*/</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 当前线程（其他线程，非firstReader角色）增加自己的读锁计数器，并将缓存设置为自己的 </span></span><br><span class="line">                    rh.count++;</span><br><span class="line">                  	</span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实<code>fullTryAcquireShared</code>考虑到两种角色的线程处理，而每种角色有对应着“第一次请求读锁”和“重入读锁”的两种情况，这导致了<code>fullTryAcquireShared</code>设计的复杂性</p>
<p>第一种角色的线程：<code>firstReader</code></p>
<p>当<code>readerShouldBlock</code>为true时（意味着此线程要进行排队，但有例外：重入锁情况不需要排队）：</p>
<p>（1）如果<code>firstReader</code> 是重入的，不需要返回-1，也即不需要进入CLH阻塞排队，直接进入第11位置的重入锁加1逻辑</p>
<p>第二种角色的线程：非<code>firstReader</code>角色，也即不是第一个请求读锁的线程</p>
<p>当<code>readerShouldBlock</code>为true时（意味着此线程要进行排队，但有例外：重入锁情况不需要排队）：</p>
<p>（1）如果当前线程（非<code>firstReader</code>角色）是重入的，此时<code>rh.count!=0</code>不需要返回-1，也即不需要进入CLH阻塞排队，直接进入第11位置的重入锁加1逻辑</p>
<p>（2）如果当前线程（非<code>firstReader</code>角色）是第一次请求读锁，但因为<code>readerShouldBlock</code>为true，表示需要进入阻塞队列排队，因此会满足<code>rh.count=0</code>返回-1，此线程进入阻塞队列</p>
<p>或者用更为简洁的话：</p>
<p>如果其他线程是第一次获取读锁，因为<code>readerShouldBlock</code>为true，因此就要返回-1，这样这种线程才会被安排到CLH队列去排队，符合“ShouldBlock的要求”。又因为这些线程第一次获取读锁就需要被安排到CLH排队，因此他们持有的计数器对象如果rh.count=0,就需要readHolds.remove()，这样保证了入队后，这个线程首先没有持有读锁且能对应没有持有读锁计数器，保证了这些线程不会发生“ThreadLocal内存泄露”。</p>
<p>如果是<code>firstReader</code>是重入锁或者其他线程做重入锁，那么对自己的HoldCount进行加1计数后返回1，表示重入锁成功。</p>
<h5 id="关于读锁的非公平设计readerShouldBlock"><a href="#关于读锁的非公平设计readerShouldBlock" class="headerlink" title="关于读锁的非公平设计readerShouldBlock"></a>关于读锁的非公平设计readerShouldBlock</h5><p>如果<code>ReentrantReadWriteLock</code>在初始化给定的是非公平模式，那么其设计思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nonfair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要到这里的readerShouldBlock方法都会在<code>tryAcquireShared</code>和<code>fullTryAcquireShared</code>使用，具体实现是<code>apparentlyFirstQueuedIsExclusive</code>,注释说它可以“试探性”的（或者说在一定概率上）防止在阻塞队列等待的写线程节点发生“锁饥饿”情况。</p>
<p>为何会出现“阻塞队列等待的写线程节点发生“锁饥饿”情况”?</p>
<p>假设现在有一个写锁节点已经在阻塞队列，结构如下：</p>
<p>head(null,-1)&lt;-&gt;node(写线程,0)</p>
<p>在<code>fullTryAcquireShared</code>中，如果<code>readerShouldBlock</code>的非公平模式设计为直接返回false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）假设现在有新来的10个线程Thread-1~Thread-10并发请求读锁的线程，那么按照<code>readerShouldBlock</code>返回false的逻辑，他们可以直接竞争第一次请求锁或者重入锁，不妨假设这些请求读锁的10个线程都恰好领先于阻塞队列的写线程获取锁（毕竟新来的线程拿到CPU时间片的概率要比阻塞队列里面的写线程要高），那么就会导致此写线程根本无机会去请求锁，只能一直“委屈的在阻塞队列里面等待”，也即发生了“锁饥饿”情况。</p>
<p>那么如何优化这种极限情况？这就是<code>apparentlyFirstQueuedIsExclusive</code>方法要解决的。</p>
<p>（2）从方法的命名也可以看出它的含义：阻塞队列的第一个排队节点是否就是独占模式节点（在本文可以理解为：阻塞队列的第一个排队节点是否就是写线程节点），如果是独占模式节点，那么<code>readerShouldBlock</code>就会返回true，就会使得那些新来的请求读锁的线程们不能直接去竞争锁资源，而是被安排到阻塞队列去排队等候，这就使得阻塞队列的第一个写线程节点能够出队去竞争锁资源了，从而避免在（1）提到的“锁饥饿”情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment"> * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment"> * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment"> * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment"> * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="comment">// 1、存在阻塞队列</span></span><br><span class="line">  	<span class="comment">// 2、阻塞队列至少有1个线程节点在排队</span></span><br><span class="line">  	<span class="comment">// 3、且第一个线程节点是独占模式节点</span></span><br><span class="line">  	<span class="comment">// 4、且第一个线程节点线程未取消</span></span><br><span class="line">  	<span class="comment">// 如果以上4个条件同时成立，那么就会返回true，也即readerShouldBlock返回true</span></span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上逻辑可以结合以下两种情况来理解：</p>
<p>第一种情况：</p>
<p>外面的新来的线程们：Thread-1~Thread10</p>
<p>阻塞队列的情况：head(null,-1)&lt;-&gt;node(写线程,0)</p>
<p>因此,根据<code>apparentlyFirstQueuedIsExclusive</code>的第三个条件，阻塞队列的第一个节点是独占模式节点（请求写锁的线程），那么<code>readerShouldBlock</code>就会返回true，要求外面的新来的线程们去阻塞队列排队等待，保证了此写线程能够出队抢锁。</p>
<p>第二种情况：</p>
<p>外面的新来的线程们：Thread-1~Thread10</p>
<p>阻塞队列的情况：head(null,-1)&lt;-&gt;node(读线程,-1)&lt;-&gt;node(写线程,0)</p>
<p>或者：head(null,-1)&lt;-&gt;node(读线程,-1)…….&lt;-&gt;node(写线程,0)</p>
<p>可以看到，阻塞队列里面的第一个线程节点为读线程节点，写线程排在第二或者其他更后面的位置，这时<code>apparentlyFirstQueuedIsExclusive</code> 显然因为<code>!s.isShared()</code>是共享模式节点而返回false，也即<code>`readerShouldBlock</code>就会返回false，那么外面新来的10个线程就会直接争抢锁资源而不需要排队，这会导致排在第二位置或者更后位置的写线程发生了一定程度的“锁饥饿”，因此只能说这种设计能够在一定程度上减少<code>writer starvation</code>，但不能保证一定杜绝<code>writer starvation</code>。</p>
<p>因此，正如<code>readerShouldBlock</code>里面的注释：a probabilistic effect 或者As a heuristic to avoid indefinite writer starvation，也即有一定概率性的。</p>
<p>这里不得不赞叹Dung Lea设计的读锁请求算法是如此的精妙和高超！</p>
<h5 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、用户代码</span></span><br><span class="line">rwl.readLock().unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、ReentrantReadWriteLock的unlock</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the number of readers is now zero then the lock</span></span><br><span class="line"><span class="comment">         * is made available for write lock attempts.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、调用的是AQS的releaseShared：共享锁释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、ReentrantReadWriteLock内部Sync定义的释放读锁逻辑</span></span><br><span class="line"><span class="comment">// 从读锁的加锁分析中可以推理出：有几种释放锁情况</span></span><br><span class="line"><span class="comment">// 第一：请求读锁然后马上释放锁的情况，</span></span><br><span class="line"><span class="comment">// 第二：已经是重入锁的情况去释放自己的重入锁	</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">          	<span class="comment">// 1、如果当前线程恰好是第一个拿到读锁的线程，那么对于首次加锁那么释放锁就是直接将firstReader置为null，否则说明是重入锁的释放，只需将自己持有的读锁计数减1</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 2、 非firstReader角色释放自己持有的读锁 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">              	<span class="comment">// 2.1 如果缓存为空或者缓存的HoldCounter对象不是当前线程，那么就从当前线程的ThreadLocal取出它的HoldCounter对象赋给rh变量</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">              	<span class="comment">// 2.2 如果原来持有的读锁&lt;=1,那么因为本次释放就会使得自己持有读锁计数变为0，对应要清除自己ThreadLocal存放的HoldCounter对象，这是因为考虑到ThreadLocal里面的entry是WeakReference类型，而HoldCounter是放在entry中，那么显然调用remove后，使得这个entry没有对象引用，加速GC回收。</span></span><br><span class="line">               <span class="comment">// 此外，当前线程因此已经准备要释放自己持有的最后一个读锁，说明释放后它就不不再需要计数，因此通过主动调用remove来避免ThreadLocal出现内存泄漏。</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();  <span class="comment">// 务必已经掌握了ThreadLocal的底层源码设计，否则这段将无法理解为何要使用remove。</span></span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">// 2.3 如果原来持有的读锁计数大于1，那么当前线程的本次释放并不是释放自己持有的最后一个读锁，而是重入锁的退出，只需对自己持有的重入锁计数器减1即可</span></span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//3、以上1和2步骤都是为了完成线程自己持有读锁的计数减1，那么下面使用自旋保证当前线程一定能使得总读锁计数state-1，如果释放后总锁（含读、写锁）剩余量刚好为0，那么当前下线程就会使用doReleaseShared去唤醒阻塞队里面正在等待的线程节点，尤其是被阻塞的写线程节点。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">					<span class="comment">/* 这里也说到：如果是读线程释放读锁，对于持有读锁的线程来说是无影响的，如何理解这句话？</span></span><br><span class="line"><span class="comment">          想象一下：假设有65535个线程并发使用lock请求读锁，并假设都可以拿到读锁（意味着每个线程拿到1个读锁）,此时state的高16位计数为65535，假设在下一刻有65534个线程同一时刻释放自己的读锁，可以容易推出：每次有线程成功CAS：compareAndSetState(c, nextc)，且nextc不等于0，对应tryReleaseShared返回false，那么在外面此线程并不需要进入doReleaseShared()逻辑，这其实在说明：65534个线程在释放锁的过程中，tryReleaseShared都是返回false，显然都不影响其他读线程，这就是“Releasing the read lock has no effect on readers”的含义。</span></span><br><span class="line"><span class="comment">          当tryReleaseShared返回true时，说明第65535个线程也释放自己的锁，此时nextc==0成立，这时当前线程才会进入doReleaseShared()唤醒阻塞队列里面的线程节点。 因此这一刻，读锁和写锁都没人请求，阻塞队列的线程节点当然可以出队去请求锁。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写锁的公平性"><a href="#读写锁的公平性" class="headerlink" title="读写锁的公平性"></a>读写锁的公平性</h4><p>我们知道，<code>ReentrantReadWriteLock</code>在创建时默认使用的非公平模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造器使用的是非公平模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);  <span class="comment">// new时就已经实例化一个readerLock 对象和 writerLock 对象</span></span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平模式实现：</p>
<p>请求写锁时：当前准备请求写锁的线程可以直接CAS写锁，不需要询问CLH阻塞队列是否有线程在等待拿锁。</p>
<p>请求读锁时：返回apparentlyFirstQueuedIsExclusive的策略，解析参考上文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nonfair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平模式：</p>
<p>请求写锁时：当前准备请求写锁的线程要去查询CLH阻塞队列是否有线程正在排队</p>
<p>请求读锁时：当前准备请求读锁的线程要去查询CLH阻塞队列是否有线程正在排队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Fair version of Sync</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Queries whether any threads have been waiting to acquire longer</span></span><br><span class="line"><span class="comment">   * than the current thread.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment">   * more efficient than):</span></span><br><span class="line"><span class="comment">   *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;</span></span><br><span class="line"><span class="comment">   * hasQueuedThreads()&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">   * timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">   * guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">   * thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">   * race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">   * due to the queue being empty.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This method is designed to be used by a fair synchronizer to</span></span><br><span class="line"><span class="comment">   * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">   * Such a synchronizer&#x27;s &#123;<span class="doctag">@link</span> #tryAcquire&#125; method should return</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> false&#125;, and its &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; method should</span></span><br><span class="line"><span class="comment">   * return a negative value, if this method returns &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">   * (unless this is a reentrant acquire).  For example, the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * tryAcquire&#125; method for a fair, reentrant, exclusive mode</span></span><br><span class="line"><span class="comment">   * synchronizer might look like this:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   // 这里给出当前线程请求独占锁前需要询问阻塞队列的是否有线程正在排队情况	</span></span><br><span class="line"><span class="comment">   * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">   *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">   *     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">   *     return true;</span></span><br><span class="line"><span class="comment">   *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">   *     return false;</span></span><br><span class="line"><span class="comment">   *   &#125; else &#123;</span></span><br><span class="line"><span class="comment">   *     // try to acquire normally</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">   *         current thread, and &#123;<span class="doctag">@code</span> false&#125; if the current thread</span></span><br><span class="line"><span class="comment">   *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果当前准备请求读写锁的线程调用hasQueuedPredecessors()返回false，说明当前线程要么已经在队列且作为第一个排队节点，要么就是没有CLH阻塞队列，也即没有其他线程在排队，这两种情况都可以说明当前线程不需要排队可以直接去竞争锁。</span></span><br><span class="line"> <span class="comment">//  2. s = h.next且s.thread = Thread.currentThread()，就是说明CLH阻塞队列里面第一个排队线程就是当前线程本身。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">      <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">      <span class="comment">// thread is first in queue.</span></span><br><span class="line">      Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">      Node h = head;</span><br><span class="line">      Node s;</span><br><span class="line">      <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">          ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>基于以上全文，显然<code>ReentrantReadWriteLock</code>的一些特定如下：</p>
<p>读读不互斥：持有读锁的线程A读数据显然不影响持有读锁的线程B读数据，这样的<code>读读不互斥</code>才是<code>ReentrantReadWriteLock</code>的高性能设计，如果采用<code>ReentrantLock</code>，那么持有<code>lock</code>的线程A读数据显然会导致线程B需要等待线程A释放了<code>ReentrantLock的lock</code>才能读数据，这就是为何<code>ReentrantLock</code>读读互斥不再符合<code>读多写少</code>的高并发需求的场景。</p>
<p>读写互斥：设想，如果允许读写不互斥，那么持有写锁的线程A正在写数据时，持有读锁的线程B读数据就会读到旧数据，这不是<code>ReentrantReadWriteLock</code>的设计初衷。因此持有写锁的线程A正在写数据时，线程B将无法请求到读锁或者写锁。持有读锁的线程A正在读数据时，线程B将无法请求到写锁来执行相关写操作，这样就保证了线程A在写时，其他线程不会读到乱数据。</p>
<p>写写互斥：持有写锁的线程A正在写数据时，线程B显然无法请求到写锁。</p>
<p>对于同一线程持有读锁的情况下，不允许持有写锁：否则就是持当前线程有读锁情况下竟然可以请求到写锁，那么这个读锁就不是共享模式读锁，而是变相称为了独占锁。</p>
<p>对于同一线程持有写锁的情况下，允许持有读锁：这是允许的，因此例如持有写锁的线程A正在写数据（外面的其他线程无法请求读锁和写锁），写完数据后，可以请求读锁再去读数据，这样不管是线程A自己还是外面的线程都能正确的读取到正确的数据。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/02/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84CyclicBarrier%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" rel="prev" title="Java高级主题：基于AQS驱动的CyclicBarrier实现原理解析">
      <i class="fa fa-chevron-left"></i> Java高级主题：基于AQS驱动的CyclicBarrier实现原理解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/15/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.8%20ConcurrentHashMap%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Btransfer%E6%96%B9%E6%B3%95%E6%A1%B6%E4%BD%8D%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B/" rel="next" title="Java高级主题：深度讨论jdk1.8 ConcurrentHashMap并发环境下transfer方法桶位分配过程">
      Java高级主题：深度讨论jdk1.8 ConcurrentHashMap并发环境下transfer方法桶位分配过程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81%E3%80%81%E8%AF%BB%E7%BA%BF%E7%A8%8B%E3%80%81%E5%86%99%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">关于读锁、写锁、读线程、写线程的一些说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E5%80%BC%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">关于同步状态值的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">写锁实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WriteLock%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">WriteLock实现类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E9%94%81%E8%8E%B7%E5%8F%96-tryAcquire"><span class="nav-number">3.2.</span> <span class="nav-text">写锁获取-tryAcquire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E9%94%81%E9%87%8A%E6%94%BE-tryRelease"><span class="nav-number">3.3.</span> <span class="nav-text">写锁释放-tryRelease</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">读锁实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E8%8E%B7%E5%8F%96-tryAcquireShared"><span class="nav-number">4.1.</span> <span class="nav-text">读锁获取(tryAcquireShared)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E2%80%9C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E8%87%AA%E5%B7%B1%E6%8C%81%E6%9C%89%E7%9A%84%E8%AF%BB%E9%94%81%E8%AE%A1%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%85%B3%E7%AE%A1%E7%90%86%E2%80%9D%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88ReentrantReadWriteLock%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fullTryAcquireShared"><span class="nav-number">4.3.</span> <span class="nav-text">fullTryAcquireShared</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%BB%E9%94%81%E7%9A%84%E9%9D%9E%E5%85%AC%E5%B9%B3%E8%AE%BE%E8%AE%A1readerShouldBlock"><span class="nav-number">4.4.</span> <span class="nav-text">关于读锁的非公平设计readerShouldBlock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E9%87%8A%E6%94%BE"><span class="nav-number">4.5.</span> <span class="nav-text">读锁释放</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">读写锁的公平性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
