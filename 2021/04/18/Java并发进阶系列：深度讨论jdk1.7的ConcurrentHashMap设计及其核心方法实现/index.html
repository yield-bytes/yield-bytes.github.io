<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读本文前，需要部分JDK源码深度知识储备：Unsafe与CAS原理、jdk1.7的HashMap原理设计以及分析过其源代码  《gitee 博客封面图》 1、为何引入ConcurrentHashMap这种适应并发场景数据结构？ HashTable  从Java7和Java8的HashMap源码设计可以得出基本结论：两者都不是线程安全，如果非得在并发情况下使用它们，会出现一些问题，如Java7的H">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现">
<meta property="og:url" content="https://yield-bytes.github.io/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="阅读本文前，需要部分JDK源码深度知识储备：Unsafe与CAS原理、jdk1.7的HashMap原理设计以及分析过其源代码  《gitee 博客封面图》 1、为何引入ConcurrentHashMap这种适应并发场景数据结构？ HashTable  从Java7和Java8的HashMap源码设计可以得出基本结论：两者都不是线程安全，如果非得在并发情况下使用它们，会出现一些问题，如Java7的H">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3238fd00eb9a4704a77076200e1f9df6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/198b28346f38434b879c3bfc4c67b771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/afab5722a7e149bd89688b03bb7a10cf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e0247aaaadae4453a0e2da4cb18c117f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/749bdcdee5ce43819369aec363bf8703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2021-04-17T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-09T13:48:35.840Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="https://yield-bytes.github.io/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-18T00:00:00+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 21:48:35" itemprop="dateModified" datetime="2022-05-09T21:48:35+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>阅读本文前，需要部分JDK源码深度知识储备：Unsafe与CAS原理、jdk1.7的HashMap原理设计以及分析过其源代码</p>
<p><img src="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>《gitee 博客封面图》</p>
<h4 id="1、为何引入ConcurrentHashMap这种适应并发场景数据结构？"><a href="#1、为何引入ConcurrentHashMap这种适应并发场景数据结构？" class="headerlink" title="1、为何引入ConcurrentHashMap这种适应并发场景数据结构？"></a>1、为何引入ConcurrentHashMap这种适应并发场景数据结构？</h4><ul>
<li>HashTable</li>
</ul>
<p>从Java7和Java8的HashMap源码设计可以得出基本结论：两者都不是线程安全，如果非得在并发情况下使用它们，会出现一些问题，如Java7的HashMap死循环导致CPU利用率飙高、put/get不一致问题等，当然也有绝对线程安全的HashTable，但从其源码实现来看，HashTable简单粗暴地在put/get/size等方法前加一个<code>synchronized</code> 修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//...</span></span></span><br></pre></td></tr></table></figure>
<p>在并发操作HashTable的线程数量不多的场景下，其性能影响不大，而且线程隔离程度最高（保证线程安全）；但在高并发场景下，HashTable的性能显得力不从心，考察以下情况：</p>
<p>例如有1000个线程对HashTable（数组长度为1024）进行读写操作，由于synchronized是对整个数组进行加锁，只要有一个线程在数组的某个桶位上进行put/get等操作，其他999个线程都会被阻塞无法做其他事情，就连读操作也会被阻塞而不能并发读。</p>
<a id="more"></a>
<ul>
<li>Collections.synchronizedMap(map)</li>
</ul>
<p>此方法也能实现线程安全：用它可以将非线程安全版本的HashMap“包装”为线程安全的HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map=Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer,String&gt;());</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>其内部实现方式，如外界不指定加锁对象，那么它会对“当前SynchronizedMap对象的引用”加锁，然后再套用HashMap的方法即可完成线程安全的设计，简单、粗暴、直接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.m = m; <span class="comment">// </span></span><br><span class="line">      mutex = <span class="keyword">this</span>;<span class="comment">// 当前SynchronizedMap对象的引用,后面的get、put会对其加锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// HashTable是在方法前面加synchronized修饰</span></span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Collections.unmodifiableMap(map)</li>
</ul>
<p>当然也还有一个冷门的unmodifiableMap类支持多线程并发的读的场景，但不支持并发写，因为unmodifiableMap类是只读的map，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">Map&lt;Integer, String&gt; map1 = Collections.unmodifiableMap(map);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>); <span class="comment">// 抛出UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>
<p>查看unmodifiableMap源码即可了解其设计思想：对“写入操作”相关方法改造为抛出异常，从而实现将可读写的map“包装”成只读map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>此外unmodifiableMap类业务场景受限，它不支持并发写入等复杂操作的场景。</p>
<p>以上三种map虽然都是线程安全map，但它们在高并发场景下，读写（当然unmodifiableMap不支持写入操作）性能低，因此有必要介绍能支持高并发的HashMap，也即ConcurrentHashMap简称CHM，当然本文特指jdk1.7版本的CHM。</p>
<h4 id="2、ConcurrentHashMap双层结构图及其基本术语"><a href="#2、ConcurrentHashMap双层结构图及其基本术语" class="headerlink" title="2、ConcurrentHashMap双层结构图及其基本术语"></a>2、ConcurrentHashMap双层结构图及其基本术语</h4><p><img src="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从图中可以看出，ConcurrentHashMap具有两层结构：Segment数组+HashEntry数组</p>
<ul>
<li>第一层结构：是一个Segment数组，该数组每个元素都是一个Segment对象，Segment对象是什么？首先它是ConcurrentHashMap的一个内部“辅佐类”，本质是一个锁对象，继承了ReentrantLock，只不过在ReentrantLock基础上增加各种功能，Segment定义源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  			<span class="comment">// ...</span></span><br><span class="line">        Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">  		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的“分段锁”、“锁分段”说的就是Segment数组里每个元素（每个桶位）都是一个锁，换句话说：Segment数组的每个桶位都持有一个锁，都可以独立加锁和解锁，桶位之间的读写操作互不影响，这种直接继承ReentrantLock来封装成为新的“工具”的设计思想确实巧妙。</p>
<ul>
<li>第二层结构：从Segment类的定义可以看出，每个Segment对象又包含了一个HashEntry数组，它才是键值对或者冲突链真正存放的地方，显然这一层结构就是大家所熟悉的Java7 HashMap结构。在Segment对象内部，对HashEntry数组的并发写操作采用CAS无锁原子操作机制，并发读操作使用volatile和Unsafe机制实现。</li>
</ul>
<p>这里还是以前面第1节的案例说明：</p>
<blockquote>
<p>例如有1000个线程对ConcurrentHashMap（数组长度为1024）进行(key,value)读写操作，假设1000个线程能够均匀分别1000个不同Segment数组桶位上，由于Segment数组每个桶位都是一把锁，每个线程对自己桶位进行加锁后独立进行读写操作，完全不会阻塞其他桶位上的线程操作，因此1000个线程可以同一时刻并发执行读写，整个ConcurrentHashMap的操作效率大增。</p>
</blockquote>
<h4 id="3、重点成员变量以及构造方法"><a href="#3、重点成员变量以及构造方法" class="headerlink" title="3、重点成员变量以及构造方法"></a>3、重点成员变量以及构造方法</h4><p>从最熟悉的用法put开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>通常是以该类的重点成员变量以及最多参数那个构造方法作为分析切入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 第一层结构Segment数组的默认初始容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">		<span class="comment">//第二层结构里面HashMap的负载因子，注意：这里不是Segment数组的负载因子，Segment数组没有扩容机制，初始化设定多少就是多少（原因看后面的源码分析），因此不需要LOAD_FACTOR</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">		<span class="comment">// 写并发度，也即允许同时操作多少个线程来操作该Segment数组，数组的一个桶位对应一个写操作并发度，读并发度不限制</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">		<span class="comment">// 第二层结构里面HashMap的最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 第二层结构里面HashMap的初始默认容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一层结构Segment数组的最大容量65536，Doug Lea自己也认为该最值设定有点保守，因为同一台服务器，cpu、内存等配置不同，同时开启的线程数量也不同，性能好的服务器，同时打开10万个线程也不成问题</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment">     * methods before resorting to locking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 在计算size时，加阻塞锁的最大尝试次数，后面的size方法会提到。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应第一层结构的Segment数组，注意这里是final修饰，也再次能说明：Segment数组一旦创建，以后就不能修改和扩容了</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="comment">// 如果给定的并发度例如10万，显然大于默认Segment数组的长度，只能取到65536，</span></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">  <span class="comment">// 用于算出给定相关参数下的最佳Segment数组容量，2的n次幂，以下以默认构造方法的入参作为说明，因此给定initialCapacity=16作为实例说明，其他参数loadFactor=0.75，concurrencyLevel=16。</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>; <span class="comment">// ssize变量就是创建Segment数组的容量值</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">          <span class="comment">// 找出大于等于并发度的2整数幂值，因为concurrencyLevel默认为16，因此经过以下简单计算，sshift=4，ssize=16</span></span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// segmentShift=32-4=28，用于计算key的hash值，采用这种方式能够使得key分布更加离散</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">      	<span class="comment">// segmentMask=16-1=15&lt;==&gt;1111,使用二进制能够快速计算定位到key对应的桶位号，这个知识点已经在jdk1.8HashMap解析的文章详细解析过。</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize; <span class="comment">// 由于initialCapacity=16， ssize=16，那么c计算为1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 由于c*ssize=1*16恰好能满足c * ssize&gt;=initialCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity) </span><br><span class="line">            ++c; <span class="comment">// 此时c=1</span></span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">//默认创建HashEntry[]的容量，值为2</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c) <span class="comment">//  由于c=1,显然这里cap不再调整，cap还是取默认值MIN_SEGMENT_TABLE_CAPACITY=2</span></span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">      <span class="comment">// 创建第0个segment对象，用于未来其他线程创建新segment对象时以s0作为模板去“克隆创建”</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]); <span class="comment">// 从上面可知，这里cap就是2，因此位于s0位置的HashEntry数组长度为2</span></span><br><span class="line">        <span class="comment">// 创建一个容量为ssize的segments数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        <span class="comment">// 数组的segments[0]=s0 </span></span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss; <span class="comment">// segments数组内部变量名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该构造方法有以下几个重要细节：</p>
<ul>
<li><p>1、Segment数组是在new ConcurrentHashMap&lt;&gt;()时创建的，默认容量为16，同时会在Segment数组的第0个桶位上创建一个Segment对象，赋给变量s0，而Segment数组其他1~15的位置则为null，也即惰性创建，在以后有新的key put进来时再到相应的下标创建新的Segment。此外，在Segment数组第0号下标也创建好一个默认容量为2的HashEntry数组。</p>
</li>
<li><p>2、这里使用<code>UNSAFE.putOrderedObject(ss, SBASE, s0)</code> ，为何不使用 putObjectVolatile()方法？</p>
</li>
</ul>
<blockquote>
<p>首先putOrderedObject()是有序、延迟版本的 putObjectVolatile方法，用它写入值不会立即被其他线程获取到，这样做的好处是写入性能比 putObjectVolatile() 高，</p>
</blockquote>
<ul>
<li>3、如何理解“这样做的好处是写入性能比 putObjectVolatile() 高？</li>
</ul>
<blockquote>
<p>首先，假设在new构造方法阶段和put阶段，采用putObjectVolatile()，那么s0会马上写入主存，由于new阶段之后紧接着put操作，而put方法里有相关操作也涉及到立即写入主存的需求，如果这些写入操作都直接使用putObjectVolatile，那么相当于主存与cpu缓存之间来回跑了几次，其实完全可以这么设计：“从new到put方法的finally之前，积攒多个写入操作后再一次性写入主存”</p>
<p>Doug Lea就是这么干的：在new构造方法开始使用putOrderedObject，让s0变量写入主存的时间延迟到<code>put</code>方法的结尾前，也即在finally的unclock执行前，就能实现“积攒多个写入操作后一次性写入主存”，因此写入性能有提高的，而且保证的数据一致性。</p>
<p>注意：JMM规定，对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/60888757">https://www.zhihu.com/question/60888757</a></p>
</blockquote>
<h4 id="4-put方法解析"><a href="#4-put方法解析" class="headerlink" title="4 put方法解析"></a>4 put方法解析</h4><p>基于ConcurrentHashMap两层结构可知，要put一个key进去，需要两次hash定位，第一次定位在Segment数组对应的Segment上，第二次定位：在第一次定位的基础上，确定key位于HashEntry数组的哪个桶位上，显然，第二次定位才是key真正要put的位置，由于是多线程并发put，因此代码设计相对复杂：</p>
<p>第一次定位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">// 这里可以看出ConcurrentHashMap不允许放入null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  	<span class="comment">// 对比HashMap的index=hashCode&amp;table.length-1的桶位计算即可知道，j就是确定key所在的Segment数据下标位置</span></span><br><span class="line">  	<span class="comment">// 第一次定位，也即找出key所在的Segment数组的下标位置，这里的hash右移了segmentShift位，目的是让key的高位特征参与桶位计算，使得hash进一步分散</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 投机写法：若当前还未有其他线程写入，那么可以使用getObject快速获取segment实例</span></span><br><span class="line">  	<span class="comment">// 如果key对应的Segment对象恰好为null，说明还未创建Segment对象，因此需要在ensureSegment方法内部创建key对应的Segment对象，具体逻辑参考ensureSegment方法的解析</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck in ensureSegment</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) </span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">  	<span class="comment">// 真正将键值对put入HashEntry数组</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次定位 <code>s.put(key, hash, value, false)</code>  </p>
<p>该put方法是Segment对象自己的内部方法，其内部设计也很巧妙，这里给出其总体设计思想：</p>
<p>1、此put方法是真正将key放入HashEntry数组的逻辑，那么当前线程必须要获得锁才能保证独占put</p>
<p>2、使用非租塞方式自旋方式获取锁，但不会让当前线程白白浪费自旋，因此在自旋期间给当前线程安排了任务（对应下面的scanAndLockForPut方法）</p>
<p>3、任务是：麻烦你（当前线程）在自旋的过程中，顺便帮我检查key是否存在链表中，如果不存在，顺便帮我提前创建key对应的Entry节点，以便我获取锁后可以马上使用。（对应下面的HashEntry<K,V> node = tryLock() ? null :scanAndLockForPut(key, hash, value);）</p>
<p>4、拿到锁后，即可在HashEntry数组上找到合适位置并插入新key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应上面的 s.put(key, hash, value, false)调用       </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//由于segment对象自己就是一个ReentrantLock，因此当然有tryLock()加锁方法，所以在这里先尝试第一次加锁</span></span><br><span class="line"><span class="comment">// 若第一次加锁成功，则node没机会提前被创建，因此对应为null。若第一次加锁失败（说明有其他线程竞争并抢占成功），当前线程会在scanAndLockForPut里面尝试加锁且顺便提前为key创建好对应的node节点。 </span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :scanAndLockForPut(key, hash, value);</span><br><span class="line">  <span class="comment">// ===========================加锁成功（进入临界区）===========================</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 这一句代码非常能体现作者对并发性能的理解是有多细腻！参考后面解释</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">              	<span class="comment">// 使用Volatile语义获取key对应的桶位头节点，也即冲突链的头结点，用于下面遍历</span></span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">              	<span class="comment">// 以下内容其实在HashMap解析中已经讲过，逻辑不难</span></span><br><span class="line">             <span class="comment">// 从冲突链的头节点开始遍历，在合适位置插入key，若key已经在链表中存在，则更新其value</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                  	<span class="comment">//冲突链的头节点不为空，则进入链表遍历，若在链中找到对应key，则结束遍历。</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                              <span class="comment">// 更新value后，ConcurrentMap结构修改次数加1</span></span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      	<span class="comment">// 用于保持链表的遍历</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                  	<span class="comment">// 程序运行到该分支，说明key所在的桶位头节点是null</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 若上面的自旋加锁期间顺便把key对应的node节点创建好，那么就直接使用头插法将此node插入桶位上</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 若上面 的tryLock() ? 没有机会提前将key对应的node节点创建好，在这里也可以为该key创建节点，显然是用头插法</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">// HashEntry容量统计加1</span></span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 添加新节点后，若HashEntry数组容量达到扩容阈值，则进行扩容rehash</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意，这里是在HashEntry数组的index桶位创建key对应的node节点，也是用了延迟写入主存的策略（putOrderedObject）：</span></span><br><span class="line"><span class="comment">	setEntryAt(tab,i,e) </span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">        UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);</span></span><br><span class="line"><span class="comment">   		 &#125;</span></span><br><span class="line"><span class="comment">	*/</span>        </span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            put方法在代码开始位置就获得了锁，那么key写入后，自然需要释放锁，注意这里需联系前面构造方法里面的</span></span><br><span class="line"><span class="comment">            UNSAFE.putOrderedObject(ss, SBASE, s0)使用延迟写入主存的原因</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                unlock();<span class="comment">// 执行unlock之前，jvm能把之前每个调用putOrderedObject的写入操作在此刻全部一起写入到主存</span></span><br><span class="line">  <span class="comment">// ===========================成功释放锁（离开临界区）===========================</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在put方法的前面，Dung Lea安排了<code>HashEntry&lt;K,V&gt;[] tab = table</code>，将原本volatile修饰的table变量转为普通变量，</p>
<p>这是因为：在这一句之前，当前线程已经通过tryLock获取了独占锁，因此只会有一个线程对table进行写操作，既然如此，那就不必再使用volatile语义的table变量，将table赋值给put方法中的一个局部变量，从而使得能够减少volatile带来的不必要性能损耗。</p>
<h5 id="ensureSegment方法解析"><a href="#ensureSegment方法解析" class="headerlink" title="ensureSegment方法解析"></a>ensureSegment方法解析</h5><p>该方法的解析主要是来自前面put方面里面的<code>s = ensureSegment(j)，主要设计思想：</code></p>
<p>1、先投机性去主存Segment数组j下标取segment对象，若该位置对应的Segment对象不为空，则直接返回它，</p>
<p>2、若在1步骤发现j位置下Segment为null，那么当前线程准备把它创建了，创建方式当然基于自旋+CAS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 构造方法里面的初始化的Segment数组</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">  	<span class="comment">// key定位到j下标对应的相对地址，注意j下标和u的不同</span></span><br><span class="line">  	<span class="comment">// int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span></span><br><span class="line">  	<span class="comment">// s = ensureSegment(j);</span></span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">  	<span class="comment">//到这这一步,可能出现多线程并发创建Segment，因此使用Volatile语义判断Segment数组j下标是否已经创建Segment实例以及该Segment对应的hashEntry数组</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 若当前j下标元素为空，用Segment数组的第0号桶位上的segment实例作为模板为桶位j创建segment实例</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]; </span><br><span class="line">   <span class="comment">// 再次检查当前j下标是否有其他线程创建了segment实例，若没有创建，就使用自旋+CAS方式来创建，这时一定原子操作，而且仅有一个线程会创建segment成功</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">          	<span class="comment">// 自旋检查j下标位置是否有其他线程创建了segment实例，若自旋中恰好发现还未创建segment实例，则使用CAS原子操作创建</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                  	<span class="comment">// 若当前线程创建segment实例成果，则退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者这样考虑ensureSegment的设计：考察多个线程一起调用ensureSegment情况，其实只要其中一个线程抢先在j位置创Segment对象，那么其他线程只需要判断该位置不为空时就不用重复在j位置创建segment实例，直接 return seg即可。</p>
<p>再使用并发思维理解以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line"><span class="comment">// 自旋检查j下标位置是否有其他线程创建了segment实例</span></span><br><span class="line"> <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">        == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">       	<span class="comment">// 若当前线程能成功创建segment实例，则退出自旋</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>考察A、B两个线程同时执行到上面compareAndSwapObject，由于原子性操作，因此可保证只有A线程（假设A线程先抢到）去操作CAS且返回true，B线程去<code>UNSAFE.compareAndSwapObject(ss, u, null, seg = s)</code> 就会返回false，此时的u位置不再是null而是A线程已写入的segment实例，线程B在while循环发现seg已不为空，所以B线程不会再重复创建segment对象。</p>
<h5 id="scanAndLockForPut解析1"><a href="#scanAndLockForPut解析1" class="headerlink" title="scanAndLockForPut解析1"></a>scanAndLockForPut解析1</h5><p>put方法里面，因为要写入key，线程对当前segment写入操作前，当然需要先获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :scanAndLockForPut(key, hash, value);</span><br><span class="line">V oldValue;</span><br></pre></td></tr></table></figure>
<p>为了能够通俗理解<code>scanAndLockForPut</code>逻辑设计，这先给出ReentrantLock阻塞锁和非阻塞锁的对比，因此这一节称为<code>scanAndLockForPut解析1</code>，真正的源码解析安排下一节：<code>scanAndLockForPut解析2</code></p>
<ul>
<li>阻塞锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock Lock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A在工作时，线程B被阻塞了，啥事都做不了</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B在运行中&quot;</span>);</span><br><span class="line">            Lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的运行结果来看：线程A在工作时，线程B被阻塞了，而且被阻塞了5秒。在5秒里，线程B啥事都做不了，线程B明明也可以干活，但却被阻塞，这种并发设计未能充分利用cpu。</p>
<ul>
<li>非租塞锁</li>
</ul>
<p>如果使用非阻塞锁，那么线程A在工作时，线程B不会被阻塞，线程B可以自由做其他事情，没有白白自旋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> ReentrantLock Lock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A在工作时，使用tryLock非阻塞锁，这样线程B不会被线程A阻塞，线程A工作的同时，线程B同时也可以去干点别的事情</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Lock.tryLock())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B在工作中，对链表扫描是否存在key节点&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                Lock.unlock();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A在运行中</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br></pre></td></tr></table></figure>
<p>使用trylock非阻塞锁后，在这5秒时间内线程B没有白白浪费CPU资源，它顺便完成了查询key节点的工作，对比scanAndLockForPut的<code>while (!tryLock())</code>，即可理解其设计思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 若当前线程抢锁失败后不会白白浪费自旋cpu资源，而是顺便完成链表的遍历以及新key节点的创建</span></span><br><span class="line"> <span class="comment">// ......         </span></span><br><span class="line">         node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  			<span class="comment">// ...... </span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在<code>scanAndLockForPut</code> 内部使用非阻塞锁，也不会阻塞读线程在桶位的并发读，一石二鸟！</p>
<h5 id="scanAndLockForPut解析2"><a href="#scanAndLockForPut解析2" class="headerlink" title="scanAndLockForPut解析2"></a>scanAndLockForPut解析2</h5><p>完整逻辑分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">      		<span class="comment">// 获取key定位在HashEntry数组的桶位头节点</span></span><br><span class="line">          HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">          HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">          <span class="comment">// 该节点就是线程自旋抢锁过程中“顺便”把key节点提前创建好</span></span><br><span class="line">          HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">      		<span class="comment">// 记录自旋次数</span></span><br><span class="line">          <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">          <span class="comment">// 自旋尝试抢锁（加锁）</span></span><br><span class="line">          <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">              <span class="comment">// 以下的执行流都是基于“未拿到锁的条件下”进行的</span></span><br><span class="line">              HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">         		 <span class="comment">// 分支1：把能做的事情先做好了：创建了一个新的node节点，但还没获取到锁，只能继续循环</span></span><br><span class="line">              <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="comment">// 若当前key定位到的桶位为空</span></span><br><span class="line">                  <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                          node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 将retries置为0：是为了下一次循环跳到分支2或者分支3处理逻辑 </span></span><br><span class="line">                      retries = <span class="number">0</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"><span class="comment">//如果给定的key能在链表中找到，就不需要new一个node节点，继续while去获取锁</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                      retries = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                  <span class="comment">//   如果给定的key不是头节点key，说明要继续遍历该链表</span></span><br><span class="line">                      e = e.next;</span><br><span class="line">              &#125; <span class="comment">// 分支2：如果自旋获取锁的尝试大于64次，此时调用独占锁（阻塞锁），保证当前线程一定能获取到锁</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                  lock();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;<span class="comment">// 分支3：注意，此分支还未加锁，因此多个线程可能并发执行以下逻辑，如果获取锁的尝试次数未超默认值，在1~64次重试过程中，每达到偶数次：(retries &amp; 1) == 0，当前线程就去检查头节点是否发生了改变，如果头结点发生改变，说明有其他线程已经抢先将某个新节点放入链表头位置，因此当前线程只能重新实施while (!tryLock())。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                  e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                	<span class="comment">// 重置尝试次数</span></span><br><span class="line">                  retries = -<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个细节需要注意：代码最后部分“关于重试次数为偶数时就去判断当前桶位的头结点有无变化”，作者设计是基于这么思考：其实无需遍历64次，因为“安排当前线程在自旋过程中顺便去创建node节点”这个任务可要也可不要，如果在头节点恰好在奇数次例如（第3次）发生改变，那么在偶数次（第4次及其以后）就会错过判断，怎么办？ 从代码逻辑可以看出，retries次数达到64后，就会直接加阻塞锁成功，然后退出自旋，那么node节点将会在scanAndLockForPut外部被创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!tryLock())&#123;</span><br><span class="line">  		<span class="comment">//</span></span><br><span class="line">	   <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">           lock();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">//  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Doug Lea设计的scanAndLockForPut确实精妙，拿捏得死死的！（ 让线程没有”空跑、摸鱼”的余地）</p>
<h4 id="5、size方法"><a href="#5、size方法" class="headerlink" title="5、size方法"></a>5、size方法</h4><p>先理解主要设计设计思想：</p>
<p>1、从ConcurrentHashMap的两层结构可知：将每个segment段的HashEntry数组节点数进行累加即可得到总数，在多线程场景下，可以这样设计：先锁住所有segment段，累加后再解锁所有segment段。但这样设计有一个问题：直接加锁后，会阻塞其他线程对当前Segment段的并发写，有一丁点性能损耗。</p>
<p>2、基于1的优化：先“投机性赌一把”，赌遍历时没有其他线程来更新该map，那么当前线程可以先不加锁尝试3次遍历累计所有segment的更改次数（modCounts），如果相邻两次更改次数一样，说明这两次统计过程中没有其他线程来更新该map，赌成功了，此时size的计算结果相对很准确。（后面会解释为何是相对很准确，而不是100%准确）</p>
<p>如果相邻两次更改次数不一样，说明这两次统计过程中有其他线程来（put/remove/clear）该map，赌失败了，下一次尝试统计就需要对所有segment段加锁再统计size</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先尝试几次不加锁情况下的统计，如果统计失败，说明有持续的并发线程来更改HashEntry数组， resort to直译是使用(武力)，在这里则表示使用”暴力“的阻塞锁</span></span><br><span class="line">       <span class="comment">// 作者英文注释，简单明了解释了size方法设计思想:Try a few times to get accurate count. On failure due to continuous async changes in table, resort to locking.</span></span><br><span class="line">       <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">       <span class="keyword">int</span> size;</span><br><span class="line">     	<span class="comment">// 统计size是否有溢出32位最大值</span></span><br><span class="line">       <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">     	<span class="comment">// sum 和last 用于比较相邻两次的map修改数</span></span><br><span class="line">       <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">       <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">       <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             	<span class="comment">// 如果无锁情况下，统计尝试次数达到3次（从-1到1），则对所有segment段都加锁</span></span><br><span class="line">               <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                       ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">               &#125;</span><br><span class="line">               sum = <span class="number">0L</span>;</span><br><span class="line">               size = <span class="number">0</span>;</span><br><span class="line">               overflow = <span class="keyword">false</span>;</span><br><span class="line">             	<span class="comment">// 遍历所有segment并累计modCount，以及累计所有segment的HashEntry的节个数c</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                   Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                   <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       sum += seg.modCount;</span><br><span class="line">                       <span class="keyword">int</span> c = seg.count;</span><br><span class="line">ß                     	<span class="comment">// 判断累计的节个数c是否有溢出</span></span><br><span class="line">                       <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                           overflow = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             	<span class="comment">// 相邻两次modCount总修改数相等，说明当前没有其他线程来（put/remove/clear）map结构，可以结束统计</span></span><br><span class="line">               <span class="keyword">if</span> (sum == last)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               last = sum;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         	<span class="comment">// 前面加锁统计完size后，这里就需要释放锁</span></span><br><span class="line">           <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                   segmentAt(segments, j).unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     	<span class="comment">// size溢出则返回Integer.MAX_VALUE，否则返回实际统计的size值</span></span><br><span class="line">       <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从finally的逻辑可以看出，size结果是相对很准确，而不是100%准确，因为它在逐个释放锁的过程中，有可能其他线程正在对“已释放锁的Segment”进行写操作（put/remove）。</p>
<h4 id="6、rehash方法"><a href="#6、rehash方法" class="headerlink" title="6、rehash方法"></a>6、rehash方法</h4><p>rehash方法是Segment内部类方法，因此所谓的ConcurrentHashMap扩容，也是只是委托了对应的Segment段里面的HashEntry数组扩容，而不是Segment数组扩容！需要留意的是，rehash在put方法内部调用，执行rehash方法时，当前线程已经获得阻塞锁，因此可以独立扩容处理。</p>
<p>此外，java7的ConcurrentHashMap的原表节点转移到新表的设计跟java7的HashMap有点不一样</p>
<p>java7的HashMap扩容设计相对简单：针对冲突链的处理，将低位节点和高位节点区分开，分别放在新表的i位置、oldTab.length+i位置</p>
<p>而java7的ConcurrentHashMap的扩展设计：针对冲突链的处理，将“在新数组桶位相同的连续子链”和其他剩余节点区分开，然后两者放到新表对应位置。</p>
<p><font color=red> 新数组桶位相同的连续子链是指 ：子链尾节点必须是该父链尾节点，此子链才能定义为”连续子类“，所以19-&gt;35-&gt;51不是rehash定义的“连续子链”</font>， 参考后面的图示。</p>
<p>这里找子链的方法其实也不难，在一些leecode算法题例如在长字符串找一个“字符连续相同的子串”（abaaaab=&gt;aaaa）、在链表里找一个子链等。</p>
<p>以下准备了两张图解用于解释其扩容过程，基本约定：</p>
<p>1、hash计算约定：假设使用简单hash方法，也即hash（数字）=数字本身，桶位计算方式：j=hash&amp;oldTab.length-1</p>
<p>2、原数组长度为8，扩容阈值=8*0.75=6，链表已经达到6个节点，因此该桶位链表需要扩容，新表容量为16</p>
<p>3、在原数组桶位i=3位置上，形成冲突链，给定两种假设：</p>
<p>A、桶位含有“在新数组桶位相同的连续子链”的链表：3-&gt;11-&gt;19-&gt;35-&gt;51-&gt;67-&gt;null，如下图所示</p>
<p>（图中也清楚展示了“低位节点”和“高位节点”的情况，关于什么是低位和高位节点，只要有看过本博客关于HashMap的深度文章解析，这些是基本常识，这里不再累赘）<br><img src="https://img-blog.csdnimg.cn/3238fd00eb9a4704a77076200e1f9df6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="“桶位有连续子链”对应的扩容过程图解："><a href="#“桶位有连续子链”对应的扩容过程图解：" class="headerlink" title="“桶位有连续子链”对应的扩容过程图解："></a>“桶位有连续子链”对应的扩容过程图解：</h5><p><img src="https://img-blog.csdnimg.cn/198b28346f38434b879c3bfc4c67b771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>B、桶位不含有“子链”的链表：3-&gt;11-&gt;19-&gt;35-&gt;51-&gt;27-&gt;null，如下图所示</p>
<p>图中也清楚展示了“低位节点”和“高位节点”的情况</p>
<p><img src="https://img-blog.csdnimg.cn/afab5722a7e149bd89688b03bb7a10cf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="“桶位无连续子链”对应的扩容过程下面图解："><a href="#“桶位无连续子链”对应的扩容过程下面图解：" class="headerlink" title="“桶位无连续子链”对应的扩容过程下面图解："></a>“桶位无连续子链”对应的扩容过程下面图解：</h5><p><img src="https://img-blog.csdnimg.cn/e0247aaaadae4453a0e2da4cb18c117f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="rehash源码详细解析"><a href="#rehash源码详细解析" class="headerlink" title="rehash源码详细解析"></a>rehash源码详细解析</h5><p>基于以上四张图，再理解rehash源码设计思路则会简单很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 以下的原数组和新数组分别指代同一个segment段下，原HashEntry数组和新HashEntry数组</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">          	<span class="comment">// 新数组容量=2倍原数组容量</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 新数组的扩容阈值</span></span><br><span class="line">            threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">          	</span><br><span class="line">          	<span class="comment">// new一个新数组    </span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =(HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            </span><br><span class="line"> <span class="comment">// 使用位方式计算节点在新数组的桶位，在jdk1.8的HashMap源码解析中，已经对这部分知识讲得非常清楚，这里不再赘述</span></span><br><span class="line">            <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 遍历原数组每个桶位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">             		<span class="comment">// 若原数组i桶位头节点不为空，且next节点为null，说明该桶位仅有一个头节点，计算出该节点在新数组的idx位置后，头插法：newTable[idx] = e</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line"><span class="comment">//  若原数组i桶位头节点不为空，且next节点不为空，说明该桶位是一条冲突链，它的扩容处理比较复杂，可结合上面的图解内容进行综合分析</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="keyword">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                          	<span class="comment">// 计算当前遍历节点在新数组桶位号</span></span><br><span class="line">                            <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                          	</span><br><span class="line"><span class="comment">// 如果前一个节点在新数组桶位号和后一个节点在新数组桶位号相同，说明找到“连续的、新表桶位相同的子链”(对应图解里面图4的情况)，将lastRun指向该子链头节点，对应图中节点11。</span></span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//                       </span></span><br><span class="line">                        newTable[lastIdx] = lastRun;<span class="comment">// lastRun指向的子链整体迁移</span></span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<span class="comment">// 迁移其他非lastRun节点</span></span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                            <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n); <span class="comment">// 注意这里是用旧桶位节点的key和value来创建新节点，因此原桶位节点不会有任何改动，也说明rehash的同时也支持并发读</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 完成扩容后，对rehash(node)里面的新节点node放入到新newTable里面</span></span><br><span class="line">            <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里用putOrderedObject添加新节点到新数组里面，也是将其写入主存的操作延迟到外部方法put的finally的unlock位置，目的还是为减少频繁的“线程工作内存&lt;--&gt;主存”之间“来回跑”，等”凑齐“多个延迟写入的操作，然后在unlock前一并写入主存，提高put性能，作者对put性能提高的设计确定足够细腻！！！</span></span><br><span class="line"><span class="comment">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span></span><br><span class="line"><span class="comment">            UNSAFE.putOrderedObject(this, nextOffset, n);</span></span><br><span class="line"><span class="comment">        &#125;  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable; <span class="comment">// 将table引用指向newTable，原table指向的对象将会被GC</span></span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7、其他方法"><a href="#7、其他方法" class="headerlink" title="7、其他方法"></a>7、其他方法</h4><p>这里需要强调的是，前面第4到6节核心方法的设计及其源码都能理解的话，那么关于jdk1.7的ConcurrentHashMap其他方法的理解则变得相对简单很多</p>
<h5 id="get方法："><a href="#get方法：" class="headerlink" title="get方法："></a>get方法：</h5><p>两次定位，第一次定位到key对应segment位置，第二次定位到对应的HashEntry数组位置</p>
<p>两次定位都使用UNSAFE.getObjectVolatile方法实现，使用无锁实现高效率并发读，这也证明了读操作是并发的，不受写操作、独占锁影响，而且基于 happen-before</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">  	<span class="comment">// key对应的segment和HashEntry数组都在的情况下</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 定位HashEntry数组的对应桶位，然后再桶位上查找是否key这个节点</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">          	<span class="comment">// 找到则返回值</span></span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 找不到key，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>首先remove方法设计相对简单，它是委托key所在的Segment段实施的，因此不会影响其他Segment段的并发读写操作。</p>
<p>可以看出，remove属于写操作，跟put方法一样，首先需要获取独占锁。</p>
<p>remove两次hash定位和get方法一样，第一次先定位（路由、查找）到对应的Segment段，第二次定位HashEntry数组的桶位，remove方法内部内部封装了Segment的remove方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// map.remove(&quot;foo&quot;)  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">       <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Segment段内部remove方法设计：</p>
<p>设计说明</p>
<p>A、remove头节点情况：例如需要移除3-&gt;7-&gt;11-&gt;15-&gt;null的头节点3</p>
<p>e=3,next=7-&gt;11-&gt;15-&gt;null，</p>
<p>因此只需将节点7插入原桶位头节点即可：<code>setEntryAt(tab, index, next)</code>，而且使用<code>UNSAFE.putOrderedObject</code>方式，不急着写入到主存，等到finally的unlock前才一并写入主存。</p>
<p>B、remove非头结点情况：例如需要移除3-&gt;7-&gt;11-&gt;15-&gt;null的节点7</p>
<p>pred=3,e=7,next=11-&gt;15-&gt;null</p>
<p>只需将节点3的next指向节点11即可：pred.setNext(next)，也是使用UNSAFE.putOrderedObject方法，不急着写入到主存，等到finally的unlock前才一并写入主存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 先获取独占锁，跟scanAndLockForPut方法类似，但更简单，少了创建Node节点的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    <span class="comment">//====tryLock加锁成功，进入临界区====    </span></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">     		 <span class="comment">// 定位key所在的桶位</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，找出链表中与给定key相同的节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                  	<span class="comment">// 对应A情况</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="comment">// 对应B情况</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                  	<span class="comment">// 删除一个节点，map结构变化次数加1，节点数量当然需要减1</span></span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">//====释放锁，离开临界区====    </span></span><br><span class="line">       <span class="comment">// 释放独占锁， 前面所有使用UNSAFE.putOrderedObject的逻辑，将在这里一并写入到主存中</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>replace方法类似，此处不再累赘。</p>
<h5 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h5><p>第一次遍历所有Segment，对每个Segment的modCount进行累加：sum += seg.modCount，而且在遍历过程中，只要出现Segment对应的HashEntry数组长度不为0时，即可直接返回结果，不需再遍历剩余的Segment。</p>
<p>第二次遍历所有Segment，如果Segment里面的HashEntry数组长度为0，则进行操作：sum -= seg.modCount</p>
<p>设计思路：</p>
<ul>
<li><p>要证明ConcurrentHashMap为空，那么以上两次操作后，sum变量必须为0，表示两次统计modCount没有发生变化且为0次ModCount。</p>
</li>
<li><p>要证明ConcurrentHashMap不为空，那么在第二次遍历所有Segment，只要出现任意一个Segment的的HashEntry数据长度不为0，即可证明当前ConcurrentHashMap不为空</p>
</li>
</ul>
<p>以上就是isEmpty的设计思想，当然遍历数组Segment过程中访问Segment段还是会使用<code>UNSAFE.getObjectVolatile(ss, u)</code>方式来取。</p>
<p>为何不用map.size()==0来判断是否为空？</p>
<p>对比size方法计算流程和isEmpty计算流程可以得出答案，isEmpty代码简洁且效率会快一些，因为isEmpty在遍历过程出现一个Segment的HashEntry数组长度不为0即可返回结果，而size方法要计算所有Segment且需要计算两次（运气不好时还需要加锁计算）才能得出结论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">   <span class="comment">// 对应第一次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 只要有其中一个Segment的HashEntry数组长度不为0，即可返回结果：不空</span></span><br><span class="line">            <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 对应第二次遍历的情况</span></span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 只要有其中一个Segment的HashEntry数组长度不为0，即可返回结果：不空</span></span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum -= seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8、关键总结"><a href="#8、关键总结" class="headerlink" title="8、关键总结"></a>8、关键总结</h4><p><code>HashEntry</code>的成员变量<code>value</code>和<code>next</code>是被关键字<code>volatile</code>修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因而可以在不加锁的情况下读取到这两个引用的最新值</p>
<h5 id="8-1-ConcurrentHashMap与HashMap不同点对比"><a href="#8-1-ConcurrentHashMap与HashMap不同点对比" class="headerlink" title="8.1 ConcurrentHashMap与HashMap不同点对比"></a>8.1 ConcurrentHashMap与HashMap不同点对比</h5><ul>
<li><p>最简单区别当然线程安全：ConcurrentHashMap写操作：put/remove/replace都是需要加锁（scanAndLockForPut、scanAndLock）</p>
</li>
<li><p>HashMap允许Key和Value为null，而ConcurrentHashMap不允许key、value为空，参考8.5解释</p>
</li>
<li><p>HashMap不允许通过Iterator遍历的同时通过HashMap修改（强一致性要求），而ConcurrentHashMap允许该行为（本质原因CHM是弱一致性），并且该更新对后续的遍历可见，参考8.6</p>
</li>
</ul>
<h5 id="8-2-ConcurrentHashMap的并发度问题"><a href="#8-2-ConcurrentHashMap的并发度问题" class="headerlink" title="8.2 ConcurrentHashMap的并发度问题"></a>8.2 ConcurrentHashMap的并发度问题</h5><p> ConcurrentHashMap的并发度concurrencyLevel在new 构造方法就已经固定（默认并发度16个线程），例如一开始给定Segment数组是128，那么并发度最多128线程同时写操作，但对于读操作，则不限制，可以是128也可以10000等不同数量线程并发读。</p>
<p>此提问可衍生另外一个知识点：</p>
<p>如果ConrruentHashMap需要扩容，通过第6节的rehash方法可知，它是委托key所在的Segment段去扩容该段里面的HashEntry数组，而不是对Segment数组本身扩容，对于这个问题，如果不了解ConrruentHashMap，应该也会惯性思维认为：“扩容时，Segment数组也会被扩容”这样的错误理解。</p>
<p>由于Segment数组初始化就限制了并发度，因此需要你提前根据业务场景设定号并发度值，这也算是jdk1.7 ConrruentHashMap需要优化的地方。</p>
<h5 id="8-3-ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴"><a href="#8-3-ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴" class="headerlink" title="8.3 ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴"></a>8.3 ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴</h5><p>尤其在一些计高并发计数场景，例如jdk1.8的LongAdder、jdk1.8 ConcurrentHashMap里面的fullAddCount方法，但jdk1.8的思路更优，采用分段无锁方式，比Segment分段锁lock更高性能。</p>
<h5 id="8-4-ConcurrentHashMap有可能退化成SynchronizedMap"><a href="#8-4-ConcurrentHashMap有可能退化成SynchronizedMap" class="headerlink" title="8.4 ConcurrentHashMap有可能退化成SynchronizedMap"></a>8.4 ConcurrentHashMap有可能退化成SynchronizedMap</h5><p>假设有些业务的key不够合理，绝大部分的key都hash到同一个segment段，那么容易导致多个线程仅在这个Segment段进行写操作，退化成SynchronizedMap，这个段就是全局锁，这也是jdk1.7 ConrruentHashMap需要优化的地方。</p>
<h5 id="8-5-关于ConcurrentHashMap的key和value都不能为空的讨论"><a href="#8-5-关于ConcurrentHashMap的key和value都不能为空的讨论" class="headerlink" title="8.5 关于ConcurrentHashMap的key和value都不能为空的讨论"></a>8.5 关于ConcurrentHashMap的key和value都不能为空的讨论</h5><ul>
<li>ConcurrentHashMap的value不能为空的原因</li>
</ul>
<p>考察HashMap：在单线程操作的HashMap场景下，value可以放入null值，当使用get方法返回的值是null时，这个“null”存在二义性：要么key对应的value为null，要么key不在map里面，那么怎么唯一区分呢？很简单，只需结合containsKey方法就可以唯一确定取出的null是属于哪种情况，演示逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程能顺序执行以下所有逻辑</span></span><br><span class="line"><span class="comment">// 如果map包含该key，那么get返回的null是属于“key存在且对应的value为null”的情况</span></span><br><span class="line"><span class="comment">// 否则抛出key不存在的提示，这时就可以知道get返回的null是属于“key存不在map里面”的情况</span></span><br><span class="line"><span class="keyword">if</span> (m.containsKey(k)) &#123;</span><br><span class="line">   <span class="keyword">return</span> m.get(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotPresentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上的知识铺垫，下面我们再通过反证法来论证ConcurrentHashMap的value不能真实原因</p>
<p>在并发场景下 ，若将ConcurrentHashMap的value可以设为null，当使用get方法返回的值是null时，存在二义性：要么key对应的value为null，要么key不在map里面，考察使用containsKey方法来区分，参考图解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.containsKey(k)) &#123;</span><br><span class="line">   <span class="keyword">return</span> m.get(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotPresentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/749bdcdee5ce43819369aec363bf8703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这张图很好解释了ConcurrentHashMap的value不能设为空的原因，并发条件下，执行m.containsKey(k)和m.get(k)之间会有其他线程“捣乱流程”：</p>
<blockquote>
<p>线程A 执行m.containsKey(k)后返回true，线程A此时认为key存在map中，正准执行m.get前，线程B提前删除该key，接着线程A使用m.get得到的是null，然后线程A很自信得出“key是存在，只是value对应为null”的结论，而实际上呢，该key已经被线程B删除，实际情况为key不存在map中，ConcurrentHashMap这就是无法解决的二义性。</p>
</blockquote>
<ul>
<li>至于ConcurrentHashMap的key不能为空的依据：</li>
</ul>
<p>1、纯粹是基于Java关于null是否符合“程序优雅设计与否”的经验知识，其实Doug Lea认为map中允许键值为null是一种不合理的设计，HashMap虽然可以判断二义性，但是Doug Lea仍然觉得这样设计是不合理的。在java项目中，如果key为null通常意味着有些地方已经有出错的苗头，所以早点抛异常比允许null key更合适。</p>
<p>2、允许key为null另外一个不够优雅地方就是不方便遍历哈希表，尤其对于ConcurrentMap。</p>
<p>3、基于以上背景，Doug Lea在源码hash计算方法设计上就不支持key为null的处理，若为null，那么使用k.hashCode()抛出NPE，可以参考hash(key)方法。</p>
<h5 id="8-5-Fast-fail产生原因"><a href="#8-5-Fast-fail产生原因" class="headerlink" title="8.5 Fast-fail产生原因"></a>8.5 Fast-fail产生原因</h5><p><a target="_blank" rel="noopener" href="http://www.jasongj.com/java/concurrenthashmap/">http://www.jasongj.com/java/concurrenthashmap/</a></p>
<p>在使用迭代器的过程中如果HashMap被修改，那么<code>ConcurrentModificationException</code>将被抛出，也即Fast-fail策略。</p>
<p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">  expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">  Entry[] t = table;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出<code>ConcurrentModificationException</code>。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。</p>
<h5 id="8-6-ConcurrentHashMap高并发读为什么可以无锁？"><a href="#8-6-ConcurrentHashMap高并发读为什么可以无锁？" class="headerlink" title="8.6 ConcurrentHashMap高并发读为什么可以无锁？"></a>8.6 ConcurrentHashMap高并发读为什么可以无锁？</h5><p>首先：JMM实现了对volatile的保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</p>
<p>HashEntry定义中使用volatile修饰value、next字段，恰恰能享受到以上JMM所提及volatile两点收益：</p>
<p>1、volatile语义可以保证写操作在读操作之前（写操作happens-before于读操作），也即保证了写操作对后续的读操作都是可见的</p>
<p>2、其次在写入操作的时候使用`UNSAFE.putOrderedObjectE写入主存的时机延迟到put方法的unlock前，保证了数据的一致性。</p>
<p>有了以上两个机制后，那么使用 UNSAFE.getObjectVolatile即可支持并发无锁读</p>
<h5 id="8-8-为何HashEntry节点类型设置为final"><a href="#8-8-为何HashEntry节点类型设置为final" class="headerlink" title="8.8 为何HashEntry节点类型设置为final"></a>8.8 为何HashEntry节点类型设置为final</h5><p>首先ConcurrentHashMap的HashEntry为final类型（一旦创建就成为不可变类），而HashMap的Entry节点是非final类型，ConcurrentHashMap为何这么设计？</p>
<p>要回答这一问题，其实需要理解final有什么用？jvm会对final定义的变量做怎样的处理？<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/java-memory-model-6/">具体解释可参考此文章</a></p>
<p>简单来说：</p>
<p>1、对于使用final修饰的对象，java编译器会保证在读final域之前一定被写入过，即保证写在读之前发生，避免多线程并发条件下出现读后写，读到非预期的值。</p>
<p>ok，按这样的思路去解释HashEntry类：java编译器会保证在读HashEntry节点域里面的属性如key、value之前，一定会保证key、value先被写入后再来读，避免并发情况下出现“读后写，读到非预期的值”，也即保证线程安全。</p>
<p>2、对比volatile，final不需要额外的线程本地内存和主存之间的同步开销。</p>
<h5 id="8-7-HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？"><a href="#8-7-HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？" class="headerlink" title="8.7 HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？"></a>8.7 HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？</h5><p>ConcurrentHashMap的初始化在new 构造方法时就已经完成部分初始化，完成Segment数组创建、第0号位的Segment对象创建以及在其里面的HashEntry容量2的创建，因此，它的初始化可不是在第一次put才初始化</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/13/Java%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90jdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91balanceDeletion%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%A0%B8%E5%BF%83%E6%96%87%E7%AB%A0%EF%BC%89/" rel="prev" title="Java高级主题：深度解析jdk1.8的HashMap红黑树balanceDeletion节点删除平衡算法设计（核心文章）">
      <i class="fa fa-chevron-left"></i> Java高级主题：深度解析jdk1.8的HashMap红黑树balanceDeletion节点删除平衡算法设计（核心文章）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" rel="next" title="Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析">
      Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5ConcurrentHashMap%E8%BF%99%E7%A7%8D%E9%80%82%E5%BA%94%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1、为何引入ConcurrentHashMap这种适应并发场景数据结构？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81ConcurrentHashMap%E5%8F%8C%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">2.</span> <span class="nav-text">2、ConcurrentHashMap双层结构图及其基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%87%8D%E7%82%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">3、重点成员变量以及构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-put%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">4 put方法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ensureSegment%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">ensureSegment方法解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scanAndLockForPut%E8%A7%A3%E6%9E%901"><span class="nav-number">4.2.</span> <span class="nav-text">scanAndLockForPut解析1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scanAndLockForPut%E8%A7%A3%E6%9E%902"><span class="nav-number">4.3.</span> <span class="nav-text">scanAndLockForPut解析2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81size%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">5、size方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81rehash%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6、rehash方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%9C%E6%A1%B6%E4%BD%8D%E6%9C%89%E8%BF%9E%E7%BB%AD%E5%AD%90%E9%93%BE%E2%80%9D%E5%AF%B9%E5%BA%94%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">“桶位有连续子链”对应的扩容过程图解：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%9C%E6%A1%B6%E4%BD%8D%E6%97%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E9%93%BE%E2%80%9D%E5%AF%B9%E5%BA%94%E7%9A%84%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%B8%8B%E9%9D%A2%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="nav-number">6.2.</span> <span class="nav-text">“桶位无连续子链”对应的扩容过程下面图解：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rehash%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="nav-number">6.3.</span> <span class="nav-text">rehash源码详细解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">7、其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">get方法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">remove方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isEmpty%E6%96%B9%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">isEmpty方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%85%B3%E9%94%AE%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">8、关键总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-ConcurrentHashMap%E4%B8%8EHashMap%E4%B8%8D%E5%90%8C%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 ConcurrentHashMap与HashMap不同点对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-2-ConcurrentHashMap%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 ConcurrentHashMap的并发度问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-3-ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81%E7%9A%84%E5%B7%A7%E5%A6%99%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%98%AF%E5%80%BC%E5%BE%97%E5%80%9F%E9%89%B4"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-4-ConcurrentHashMap%E6%9C%89%E5%8F%AF%E8%83%BD%E9%80%80%E5%8C%96%E6%88%90SynchronizedMap"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 ConcurrentHashMap有可能退化成SynchronizedMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-5-%E5%85%B3%E4%BA%8EConcurrentHashMap%E7%9A%84key%E5%92%8Cvalue%E9%83%BD%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 关于ConcurrentHashMap的key和value都不能为空的讨论</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-5-Fast-fail%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">8.6.</span> <span class="nav-text">8.5 Fast-fail产生原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-6-ConcurrentHashMap%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%94%81%EF%BC%9F"><span class="nav-number">8.7.</span> <span class="nav-text">8.6 ConcurrentHashMap高并发读为什么可以无锁？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-8-%E4%B8%BA%E4%BD%95HashEntry%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BAfinal"><span class="nav-number">8.8.</span> <span class="nav-text">8.8 为何HashEntry节点类型设置为final</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-7-HashMap%E5%9C%A8%E7%AC%AC%E4%B8%80%E6%AC%A1put%E6%97%B6%E6%89%8D%E5%AE%8C%E6%88%90%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E9%82%A3%E4%B9%88ConcurrentHashMap%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E6%9C%BA%E5%BC%80%E5%A7%8B%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="nav-number">8.9.</span> <span class="nav-text">8.7 HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
