<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yield-bytes.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是入门和理解AQS框架的重要文章，尽管AQS还有共享模式以及条件Condition等设计，但重入锁仍然是最适合理解AQS底层数据结构及其算法设计的切入点。 单线程使用可重入锁的内部简单工作机制分别在以下两个断点位置进行debug，断点条件i&#x3D;&#x3D;5，并且在variables窗口watch一个特殊的变量state 1234567891011121314import java.util.concur">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析">
<meta property="og:url" content="https://yield-bytes.github.io/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="yield-bytes">
<meta property="og:description" content="本文是入门和理解AQS框架的重要文章，尽管AQS还有共享模式以及条件Condition等设计，但重入锁仍然是最适合理解AQS底层数据结构及其算法设计的切入点。 单线程使用可重入锁的内部简单工作机制分别在以下两个断点位置进行debug，断点条件i&#x3D;&#x3D;5，并且在variables窗口watch一个特殊的变量state 1234567891011121314import java.util.concur">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-10T03:16:34.043Z">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yield-bytes.github.io/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析 | yield-bytes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="yield-bytes" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yield-bytes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">沉淀、分享与无限进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th-large fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://gitee.com/yield-bytes" class="github-corner" title="Follow me on Gitee" aria-label="Follow me on Gitee" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yield-bytes.github.io/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="一个聪明的、友好的且专注于高水平技术总结的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yield-bytes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-25T00:00:00+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 11:16:34" itemprop="dateModified" datetime="2022-05-10T11:16:34+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Java高级主题</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>55k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>50 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是入门和理解AQS框架的重要文章，尽管AQS还有共享模式以及条件Condition等设计，但重入锁仍然是最适合理解AQS底层数据结构及其算法设计的切入点。</p>
<h4 id="单线程使用可重入锁的内部简单工作机制"><a href="#单线程使用可重入锁的内部简单工作机制" class="headerlink" title="单线程使用可重入锁的内部简单工作机制"></a>单线程使用可重入锁的内部简单工作机制</h4><p>分别在以下两个断点位置进行debug，断点条件i==5，并且在variables窗口watch一个特殊的变量<code>state</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 断点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.unlock();<span class="comment">// 断点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到<code>lock.lock()</code>的内部执行流程如下所示，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、java.util.concurrent.locks.ReentrantLock$NonfairSync@29444d75[State = 4, empty queue]</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;                  </span><br><span class="line">          sync.lock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">			<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 重点：使用cas更新state的值</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用下面5在ReentrantLock定义的tryAcquire方法</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();<span class="comment">// 重点：获取state变量当前值</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc); <span class="comment">// 重点：更新state变量值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>经过这么一轮debug，可以观察到原来<code>lock.lock()</code> 通过cas更改state变量值来实现“可重入性”，例如，这里for循环5次使得该线程在同一锁对象上加锁了5次，可以看到对应的state累加计数等于5，基于此可以推出<code>lock.unlock()</code>操作则是每次<code>unlock()</code>就是对state进行cas减1操作，如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; </span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;  <span class="comment">// 当i=5次循环时，这里getState=1,releases=1</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 所有的重入都退出后，此刻不再有线程持有独占锁。</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c); <span class="comment">// 当i=5次循环时，state被置为0</span></span><br><span class="line">            <span class="keyword">return</span> free;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其实这个state变量是一个非常重要的“同步状态”，记录了当前持有独占锁的线程的重入加锁次数，它在AbstractQueuedSynchronizer内部定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The synchronization state.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从<code>ReentrantLock</code>以上两个流程来看，重点需要解析<code>sync.lock()</code>、<code>sync.release(1)</code>，而这里sync实例是来自<code>ReentrantLock</code>内部定义<code>Sync</code>类，该类继承至<code>AbstractQueuedSynchronizer</code>，因此如果要真正理解<code>ReentrantLock</code>的可重入性，则需要深入底层的`AbstractQueuedSynchronizer，这是JUC众多锁工具的底层实现。</p>
<h4 id="从Sync类了解AQS"><a href="#从Sync类了解AQS" class="headerlink" title="从Sync类了解AQS"></a>从Sync类了解AQS</h4><p>在真正解析AQS之前，可以先看看在ReentrantLock内部定义的Sync，以下按<code>ReentrantLock</code>默认构造器进入分析流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NonfairSync</code>是实现非公平锁的主要逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     # 这里说，当前线程当前直接无需排队去争抢锁资源，也即不是先到先到，所以是才称为非公平模式。抢不到才去阻塞队列里面排队</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sync类定义了获取锁的分配逻辑，这里涉及到对同步状态state更改、同一线程的锁重入、锁重入释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"> * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment"> * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment"> * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">			</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1、AQS工作原理"><a href="#1、AQS工作原理" class="headerlink" title="1、AQS工作原理"></a>1、AQS工作原理</h4><p>源码给出的官方设计思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Even though this class is based on an internal FIFO queue, it does not automatically enforce FIFO acquisition policies. The core of exclusive synchronization takes the form:</span><br><span class="line">   Acquire:</span><br><span class="line">       while (!tryAcquire(arg)) &#123;</span><br><span class="line">          enqueue thread if it is not already queued;</span><br><span class="line">          possibly block current thread;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">   Release:</span><br><span class="line">       if (tryRelease(arg))</span><br><span class="line">          unblock the first queued thread;</span><br><span class="line">   </span><br><span class="line">(Shared mode is similar but may involve cascading signals.)</span><br></pre></td></tr></table></figure>
<p>等待队列（又称阻塞队列、阻塞链表、）内部工作原理：我们建议此工作原理在深度掌握AQS设计之前预读几遍，在深度掌握AQS源代码设计之后再回头理解它，你会发现能完全掌握AQS的整体设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Wait queue node class.</span><br><span class="line">		The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait.</span><br><span class="line">		To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field.</span><br><span class="line">            +------+  prev +-----+       +-----+</span><br><span class="line">       head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">            +------+       +-----+       +-----+</span><br><span class="line">       </span><br><span class="line">		Insertion into a CLH queue requires only a single atomic operation on &quot;tail&quot;, so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the &quot;head&quot;. However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts.</span><br><span class="line">		The &quot;prev&quot; links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;u&#x2F;scott&#x2F;synchronization&#x2F;</span><br><span class="line">		We also use &quot;next&quot; links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the &quot;next&quot; fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated &quot;tail&quot; when a node&#39;s successor appears to be null. (Or, said differently, the next-links are an optimization so that we don&#39;t usually need a backward scan.)</span><br><span class="line">		Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility.</span><br><span class="line">		CLH queues need a dummy header node to get started. But we don&#39;t create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention.</span><br><span class="line">Wait queue node class.</span><br><span class="line"></span><br><span class="line">		Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on.</span><br><span class="line">		Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class.</span><br></pre></td></tr></table></figure>
<p>这里当然最权威的方式是解析AQS源代码的开发注释</p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.</p>
<p>AQS为众多同步器（例如semaphores，events，reentrantLock）提供了一个实现框架，该框架的底层是基于变体的FIFO等待队列（注意：此等待队列又称为阻塞队列）实现的，大部分同步器只需通过原子更改一个变量名为state值的方式即可完成相关同步状态控制，AQS的子类（也即自行设计的同步器）必须重新定义相关的protected方法——以更新state状态变量，从而实现state值得变化能够表征获得锁或者释放锁，AQS的其他所有方法则实现了排队和阻塞机制。AQS的子类可以维护其他状态字段，但只有子类使用getState、setState和compareAndSetState方法去原子更新这个state值才能追踪到同步状态的变化。</p>
</blockquote>
<p>上面所说的FIFO等待队列其实就是CLH队列（Craig, Landin, Hagersten这三个人发明的数据结构，因此用他们名字命名），它在AQS内部使用双向链表队列+CAS原子锁实现，功能如下：</p>
<ul>
<li><p>FIFO的设计，保证线程在阻塞队列中的公平性，也即先进去阻塞队列等待抢锁资源的线程，也将是最先被唤醒出队</p>
</li>
<li><p>未成功拿到独占锁的线程们将通过自旋和CAS插入到队尾，显然是非阻塞设计，在短时间内能够实现无锁并发插入这些线程。</p>
</li>
</ul>
<h4 id="2、从构造方法解析"><a href="#2、从构造方法解析" class="headerlink" title="2、从构造方法解析"></a>2、从构造方法解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; instance</span></span><br><span class="line"><span class="comment">     * with initial synchronization state of zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue node class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     # 这里就解释了CLH阻塞队列的设计细节</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span></span><br><span class="line"><span class="comment">     * Hagersten) lock queue. CLH locks are normally used for</span></span><br><span class="line"><span class="comment">     * spinlocks.  We instead use them for blocking synchronizers, but</span></span><br><span class="line"><span class="comment">     * use the same basic tactic of holding some of the control</span></span><br><span class="line"><span class="comment">     * information about a thread in the predecessor of its node.  A</span></span><br><span class="line"><span class="comment">     * &quot;status&quot; field in each node keeps track of whether a thread</span></span><br><span class="line"><span class="comment">     * should block.  A node is signalled when its predecessor</span></span><br><span class="line"><span class="comment">     * releases.  Each node of the queue otherwise serves as a</span></span><br><span class="line"><span class="comment">     * specific-notification-style monitor holding a single waiting</span></span><br><span class="line"><span class="comment">     * thread. The status field does NOT control whether threads are</span></span><br><span class="line"><span class="comment">     * granted locks etc though.  A thread may try to acquire if it is</span></span><br><span class="line"><span class="comment">     * first in the queue. But being first does not guarantee success;</span></span><br><span class="line"><span class="comment">     * it only gives the right to contend.  So the currently released</span></span><br><span class="line"><span class="comment">     * contender thread may need to rewait.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span></span><br><span class="line"><span class="comment">     * tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span></span><br><span class="line"><span class="comment">     * operation on &quot;tail&quot;, so there is a simple atomic point of</span></span><br><span class="line"><span class="comment">     * demarcation from unqueued to queued. Similarly, dequeuing</span></span><br><span class="line"><span class="comment">     * involves only updating the &quot;head&quot;. However, it takes a bit</span></span><br><span class="line"><span class="comment">     * more work for nodes to determine who their successors are,</span></span><br><span class="line"><span class="comment">     * in part to deal with possible cancellation due to timeouts</span></span><br><span class="line"><span class="comment">     * and interrupts.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">     * needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">     * successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">     * predecessor. For explanation of similar mechanics in the case</span></span><br><span class="line"><span class="comment">     * of spin locks, see the papers by Scott and Scherer at</span></span><br><span class="line"><span class="comment">     * http://www.cs.rochester.edu/u/scott/synchronization/</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span></span><br><span class="line"><span class="comment">     * The thread id for each node is kept in its own node, so a</span></span><br><span class="line"><span class="comment">     * predecessor signals the next node to wake up by traversing</span></span><br><span class="line"><span class="comment">     * next link to determine which thread it is.  Determination of</span></span><br><span class="line"><span class="comment">     * successor must avoid races with newly queued nodes to set</span></span><br><span class="line"><span class="comment">     * the &quot;next&quot; fields of their predecessors.  This is solved</span></span><br><span class="line"><span class="comment">     * when necessary by checking backwards from the atomically</span></span><br><span class="line"><span class="comment">     * updated &quot;tail&quot; when a node&#x27;s successor appears to be null.</span></span><br><span class="line"><span class="comment">     * (Or, said differently, the next-links are an optimization</span></span><br><span class="line"><span class="comment">     * so that we don&#x27;t usually need a backward scan.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cancellation introduces some conservatism to the basic</span></span><br><span class="line"><span class="comment">     * algorithms.  Since we must poll for cancellation of other</span></span><br><span class="line"><span class="comment">     * nodes, we can miss noticing whether a cancelled node is</span></span><br><span class="line"><span class="comment">     * ahead or behind us. This is dealt with by always unparking</span></span><br><span class="line"><span class="comment">     * successors upon cancellation, allowing them to stabilize on</span></span><br><span class="line"><span class="comment">     * a new predecessor, unless we can identify an uncancelled</span></span><br><span class="line"><span class="comment">     * predecessor who will carry this responsibility.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;CLH queues need a dummy header node to get started. But</span></span><br><span class="line"><span class="comment">     * we don&#x27;t create them on construction, because it would be wasted</span></span><br><span class="line"><span class="comment">     * effort if there is never contention. Instead, the node</span></span><br><span class="line"><span class="comment">     * is constructed and head and tail pointers are set upon first</span></span><br><span class="line"><span class="comment">     * contention.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span></span><br><span class="line"><span class="comment">     * use an additional link. Conditions only need to link nodes</span></span><br><span class="line"><span class="comment">     * in simple (non-concurrent) linked queues because they are</span></span><br><span class="line"><span class="comment">     * only accessed when exclusively held.  Upon await, a node is</span></span><br><span class="line"><span class="comment">     * inserted into a condition queue.  Upon signal, the node is</span></span><br><span class="line"><span class="comment">     * transferred to the main queue.  A special value of status</span></span><br><span class="line"><span class="comment">     * field is used to mark which queue a node is on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span><br><span class="line"><span class="comment">     * Scherer and Michael Scott, along with members of JSR-166</span></span><br><span class="line"><span class="comment">     * expert group, for helpful ideas, discussions, and critiques</span></span><br><span class="line"><span class="comment">     * on the design of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="comment">// SHARED变量表示节点被标记为共享模式，可以看到是一个空的Node()对象，用于Semaphore这种共享模式的加锁工具</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">       <span class="comment">// EXCLUSIVE为null表示节点被标记为独占模式，用于类似ReentrantLock这种独占锁工具</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">      	<span class="comment">// waitStatus变量值若为1，表示当前线程节点已经被取消排队（注意虽然被标记为取消状态，但还未出队）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="comment">// waitStatus变量值若为-1，表示当前线程节点的后驱线程节点需要被唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="comment">// waitStatus变量值若为-2，表示当前线程节点处在条件等待当中</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 用于共享模式的锁工具的连续唤醒操作设计，ReentrantLock用不上此设计，Semaphore这种工具可以用上。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 以下是关于waitStatus变量取不同值时对应的场景说明</span></span><br><span class="line"><span class="comment">         * waitStatus用来表示当前线程节点的状态，仅取以下5个值</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         * SIGNAL的说明：当前线程节点的后驱节点发出SIGNAL唤醒的通知，当前线程需要在释放资源后或者自身被标记为取消状态后去唤醒挂在身后的后驱节点，为了避免无畏线程竞争，实现acquire功能的方法必须首先给出自己需要被通知，然后再重试“atomic acquire”,如果获取失败，则阻塞自己（而不是一直去CAS重试）</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         * SIGNAL的说明：由于超时或中断，节点被取消。此类节点不会脱落此取消状态。取消节点的线程不会再次阻塞。</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         * CONDITION的说明：节点当前位于“condition queue”，在被放到CLH队列之前，它不会用作同步队列节点，此时状态将设置为0。表示节点在等待队列上，当其他线程调用了Condition的signal方法后，CONDITION状态的节点将从等待队列转移到同步队列中，等待获取资源。</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         * PROPAGATE的说明：应将releaseShared操作传播到其他节点，这是在doReleaseShared中设置的（仅针对头部节点），以确保releaseShared操作能够传播继续进行，即使其他操作已经介入。</span></span><br><span class="line"><span class="comment">         * 换句话说：在共享模式下，前驱节点线程节点不仅要唤醒其后驱线程节点，同时也会唤醒后驱线程节点的后驱线程节点，类似一路唤醒下去。</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         * waitStatus采用这几个值得设计是为了方便使用，非负值表示节点不需要signal，所以，大多数代码不需要检查特定的值，只需要检查符号即可。</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         * waitStatus状态值，对于正常同步节点，它会被初始化为0，而对于condition nodes，则会被置为“CONDITION”，一般使用CAS去更新waitStatus的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        结合前面的prev指针用于处理线程被取消的情形。</span></span><br><span class="line"><span class="comment">     The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">     needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">     successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">     predecessor. </span></span><br><span class="line"><span class="comment">          non-callcelled node -&gt; a node -&gt;successor</span></span><br><span class="line"><span class="comment">          non-callcelled node -&gt;successor</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      next指针被设计为“We also use &quot;next&quot; links to implement blocking mechanics”。 已经被取消的节点会将next指针指向自己而不是把next指向null，这一点设计很像SkipList里面的remove设计逻辑这种设计有利于GC。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于指向获取锁的线程，可以看到其实Node节点就是包装需要获取锁的线程，因此也可以称为线程节点。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      ReentrantLock用不到此属性，CountDownLatch、CyclicBarrier等这种共享模式锁工具可以用到此属性。</span></span><br><span class="line"><span class="comment">nextWaiter特殊标记,Node在CLH队列时，nextWaiter表示共享式或独占式标记，也即nextWaiter=SHARED;Node在条件队列时，nextWaiter表示下个Node节点指针</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         判断线程节点是否处于共享模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 没有成功获取资源（例如锁）的线程就会使用此包装为一个Node，此节点会被addWaiter方法使用，也即将节点入队（此队列称为wait queue）</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其他属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">   * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">   * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">   * CANCELLED.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 阻塞队列（双向链表）的头结点，惰性创建，仅能在setHead方法能够对head指向做调整</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">   * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">// 阻塞队列（双向链表）的尾结点，惰性创建，仅能在enq方法能够对tail指向做调整</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The synchronization state.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 这个state变量就是AQS子类需要去更爱的，用于控制资源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">   * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、关于线程是如何被”Queuing”-入队操作"><a href="#3、关于线程是如何被”Queuing”-入队操作" class="headerlink" title="3、关于线程是如何被”Queuing” 入队操作"></a>3、关于线程是如何被”Queuing” 入队操作</h4><p>AQS本身并不会触发线程去入队的操作，那么是在什么时机才会有这个操作发生？这里不妨还是以</p>
<p><code>ReentrantLock</code>使用为例：根据基本的demo用法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建新线程执行任务</span></span><br><span class="line">    &#125;   <span class="keyword">catch</span> ( Exception e)&#123;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造器可以看出，默认创建的是非公平的同步锁，具体逻辑由<code>NonfairSync</code>类实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-NonfairSync"><a href="#3-1-NonfairSync" class="headerlink" title="3.1 NonfairSync"></a>3.1 NonfairSync</h5><p>Sync object for non-fair locks，也即<code>NonfairSync</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 线程执行lock.lock()也即对应以下逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 这个动词短语immediate barge用得很贴切：线程可以立即&quot;乱闯&quot;,也即新线程使用lock.lock()时，可以不排队直接参加竞争资源，如何竞争？ 只要将state状态CAS更新为1则抢占成功，这就是所谓的非公平锁。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          	<span class="comment">//该线程成功竞争后，将自己独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          	<span class="comment">// 新来的线程compareAndSetState(0, 1)失败，那么进入逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-acquire-1"><a href="#3-2-acquire-1" class="headerlink" title="3.2 acquire(1)"></a>3.2 acquire(1)</h5><p><code>acquire(1)</code> 是AQS内部的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      从该方法可以看出：线程在NonfairSync里面抢占更新state失败，也还有机会再来去申请资源，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也即上面的tryAcquire，如果成功，那么就返回true，如果线程还是tryAcquire失败，那么此时线程就会被排队：acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ，然后进入selfInterrupt()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于AQS的<code>tryAcquire</code>需要子类实现具体的逻辑，也即ReentrantLock内部的tryAcquire，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-nonfairTryAcquire"><a href="#3-3-nonfairTryAcquire" class="headerlink" title="3.3 nonfairTryAcquire"></a>3.3 nonfairTryAcquire</h5><p>ReentrantLock内部的tryAcquire内部是由<code>ReentrantLock</code>内部的Sync类的<code>nonfairTryAcquire</code>方法实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment"> * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment"> * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NonfairSync类的lock()方法实现了该抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 这里就是AQS的tryAcquire在子类Sync的具体实现逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">      	<span class="comment">// 获取同步状态state值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">      	<span class="comment">//①如果同步状态此时为0，说明没有其他线程在竞争，那么当前线程果断使用CAS尝试将state从0更新为1，这里也再次证明新线程使用lock.lock()第一次if (compareAndSetState(0, 1))不成功，在tryAcquire里面还有机会再尝试一次compareAndSetState，如果本次成功CAS那么将自己设为独占线程，获得锁资源，返回true。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	② 如果当前线程就是之前设置的独占线程，说明当前线程再次“重入”获取锁，那么只要重入次数最大值只要不溢出，那么就可以让当前线程再次“重入”并更新同步状态state的值，这就是ReentrantLock可重入锁设计的原理,最多可以重入多少次？ 首先state是int类型，因此最大值为：</span></span><br><span class="line"><span class="comment">      	max=(1&lt;&lt;31)-1</span></span><br><span class="line"><span class="comment">      	所以才会有以下的用法：</span></span><br><span class="line"><span class="comment">    double tooLarge=Math.pow(2,31);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= tooLarge; i++) &#123;</span></span><br><span class="line"><span class="comment">        lock.lock();  // 同一线程，重入加锁到最大值，其实内部就是对state进行CAS累加，也即setState(nextc)，直到state值累加到超过最大值则抛出&quot;Maximum lock count exceeded&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">        lock.unlock();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">      	</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*③ 若无法满足①、②条件，说明当前线程面临激烈锁资源竞争，那么只能返回false，接着就被安排去入队，也即AQS里面的</span></span><br><span class="line"><span class="comment">if (!tryAcquire(arg) &amp;&amp;</span></span><br><span class="line"><span class="comment">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span><br><span class="line"><span class="comment">        selfInterrupt();      </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  到此我们已经找出了线程从开始使用<code>lock.lock()</code> 到被<code>Queuing</code>入队的时机，因此接下里入队操作就是核心逻辑了</p>
<h4 id="4、AQS-的acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#4、AQS-的acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="4、AQS 的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))"></a>4、AQS 的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</h4><p>这里接着第3章节的内容，此时线程需要被入队，执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> ,这里的arg就是<code>acquire(1)</code>里面的1，表示需要对state加1或者需要获取1个锁资源</p>
<h5 id="4-1-addWaiter-Node-EXCLUSIVE"><a href="#4-1-addWaiter-Node-EXCLUSIVE" class="headerlink" title="4.1 addWaiter(Node.EXCLUSIVE)"></a>4.1 addWaiter(Node.EXCLUSIVE)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/*对于独占模式来说，addWaiter的功能就是将当前线程包装为线程节点，并使用CAS将自己添加到阻塞队列的尾部，分两个步骤：</span></span><br><span class="line"><span class="comment"> 1、优先快速尝试将自己通过CAS加到阻塞队列尾部，如果入队失败就进入2</span></span><br><span class="line"><span class="comment"> 2、使用enq(node)确保自己最后可以加入到阻塞队列尾部（或者入队成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">      Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">      <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">      Node pred = tail;</span><br><span class="line">      <span class="comment">//1、 node&lt;=&gt;node&lt;=&gt;pred 变成 node&lt;=&gt;node&lt;=&gt;pred&lt;=&gt;new Node</span></span><br><span class="line">      <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 新线程节点的前驱节点指针指向pred，如果pred节点没有被其他线程更改，那么CAS成功就会将pred的next指针指向新线程节点，从而使得新线程节点成功入队。</span></span><br><span class="line">          node.prev = pred;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">              pred.next = node;</span><br><span class="line">            	<span class="comment">//返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//2、enq内部使用自旋（for循环）保证线程一定能入队</span></span><br><span class="line">      enq(node);</span><br><span class="line">     <span class="comment">//返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-enq-node"><a href="#4-2-enq-node" class="headerlink" title="4.2 enq(node)"></a>4.2 enq(node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">// 将线程节点插入双向链表（阻塞队列）尾部，如果链表为空，则需要先初始化后再插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 自旋，保证线程一定能在某次循环中CAS入队成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">          	<span class="comment">// 如果链表尾节点为空，说明阻塞队列还未创建，因此需要初始化，这时新建一个非线程节点放在链表头部。</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"> <span class="comment">/* 这里非常关键：双向链表的头节点不是线程节点，而是一个无参构造方法的节点，这里可以称为辅助节点，就像ConcurrentSkipList底层的数据链表头节点(BASE_HEADER)也是辅助节点的设计:</span></span><br><span class="line"><span class="comment"> head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null),null, null, 1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            <span class="comment">// 如果双向链表已经存在，则线程节点尝试使用CAS将自己添加到队列尾部</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                  	<span class="comment">// 返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>未能获取的锁资源（未能对state更新成功的）新线程通过<code>addWaiter</code>或者<code>enq</code>方法让自己添加到阻塞队列尾部，或者这样理解：在<code>addWaiter</code>里面首先尝试，也就代码里面的注释所表达的意思：Try the fast path of enq; backup to full enq on failure</p>
<p>接下里还需要做什么？线程加入阻塞队列以后，是马上把自己阻塞起来，还是刚好位于队列第一个线程节点位置然后马上尝试获取锁资源呢？这就是<code>acquireQueued(addWaiter(Node.EXCLUSIVE),1))</code>核心设计</p>
<h5 id="4-3-acquireQueued-addWaiter-Node-EXCLUSIVE-1"><a href="#4-3-acquireQueued-addWaiter-Node-EXCLUSIVE-1" class="headerlink" title="4.3 acquireQueued(addWaiter(Node.EXCLUSIVE),1))"></a>4.3 acquireQueued(addWaiter(Node.EXCLUSIVE),1))</h5><p>从上面4.1和4.2可知，阻塞队列里面放的都是未能成功获取锁资源的线程节点（除了头节点辅助节点），这些节点已经入队，但总不能放着它们在队列里面就不管了，接下来还要做一件事情：</p>
<p>从队列取出线程节点，让它重新去尝试获取已经被外面活动线程释放的锁资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 已在队列中的线程以独占且不可中断的模式获取锁资源</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// failed表示是否成功获得锁资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 表示线程是否被中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">// 核心逻辑：取出当前入队线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	（注意区分阻塞队列的head节点（辅助节点又称哨兵节点）和阻塞队列的第一个线程节点）</span></span><br><span class="line"><span class="comment">          	如果当前线程节点前驱节点恰好是head节点，说明当前线程节点就是阻塞队列的第一个线程节点，当然有资格且第一个先去尝试获取锁资源，如下结构</span></span><br><span class="line"><span class="comment">          	head(辅助节点) &lt;-&gt; node（第一个线程节点） -&gt; null</span></span><br><span class="line"><span class="comment">          	*/</span> </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">             <span class="comment">// 这里的tryAcquire表示你（阻塞队列的第一个线程节点）有资格去抢锁资源，但也要看看能否抢赢外界线程</span></span><br><span class="line">            <span class="comment">/* 如果线程节点获取资源成功，那么就可以做出队操作，这里出队很巧妙:</span></span><br><span class="line"><span class="comment">            经过setHead之后，线程节点node.thread不再指向线程，而是变成了辅助节点而且成为阻塞队列的新head，原head节点通过p.next = null 完成GC，这就是为何阻塞队列将head节点设计辅助节点new Node()的原因：第一个线程节点获取锁资源后需要出队以及方便回收设计</span></span><br><span class="line"><span class="comment">                    private void setHead(Node node) &#123;</span></span><br><span class="line"><span class="comment">                    head = node;</span></span><br><span class="line"><span class="comment">                    node.thread = null;</span></span><br><span class="line"><span class="comment">                    node.prev = null;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	两种情况会进入if逻辑：</span></span><br><span class="line"><span class="comment">          	①如果当前节点是第一个线程节点或者说其前驱节点是head节点，但在tryAcquire(arg)竞争失败（因为外面有新的线程在lock.lock()里面CAS成功）</span></span><br><span class="line"><span class="comment">          	②当前线程节点不是第一个线程节点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-4-shouldParkAfterFailedAcquire-p-node"><a href="#4-4-shouldParkAfterFailedAcquire-p-node" class="headerlink" title="4.4 shouldParkAfterFailedAcquire(p, node)"></a>4.4 shouldParkAfterFailedAcquire(p, node)</h5><p>接4.3内容，这部分内容可以解析阻塞队列为何被称为“阻塞”队列的原因，<code>shouldParkAfterFailedAcquire</code>从方法名字也可以看出其设计目的：既然第一个线程节点获取锁资源失败，那么就不能一直无限去<code>Acquire</code>，而是在阻塞队列是自己变成“阻塞状态”去等待，这样就不会白白消耗cpu。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">    * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">    * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">/*非常重要的源码注释：根据4.3，如果线程节点未能p == head &amp;&amp; tryAcquire(arg)，则检查并更新该节点里面的Node.SIGNAL状态值。如果线程节点应该被阻塞，则返回true。</span></span><br><span class="line"><span class="comment">为了理解以下设计逻辑，这里不妨先假设当前链表结构为：</span></span><br><span class="line"><span class="comment">		head(waitStatus=0) &lt;-&gt; node(waitStatus=0) -&gt; null</span></span><br><span class="line"><span class="comment">		那么这里pred显然指向head(waitStatus=0) ，node指向第一个线程节点node（waitStatus=0）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// waitStatus也即线程节点的等待状态，新线程节点创建时waitStatus默认为0， </span></span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">   <span class="comment">// ①waitStatus变量值若为Node.SIGNAL也即等于-1，说明对于pred(-1)&lt;-&gt;node(ws=0)来说，pred节点其实已经是阻塞状态了，那么node作为pred的后驱节点也肯定要被阻塞，因此返回true后，在parkAndCheckInterrupt里面node就会被阻塞起来</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">/* ② 如果waitStatus的值&gt;0,也即waitStatus=Node.CANCELLED=1,说明pred线程节点取消排队，考察以下阻塞队列结构</span></span><br><span class="line"><span class="comment">  head(ws=-1)&lt;-&gt;node1(ws=-1)&lt;-&gt;node2(ws=1)&lt;-&gt;node3(ws=0)-&gt; null</span></span><br><span class="line"><span class="comment">  假设pred=node2,node=node3,显然node2已经取消排队，那么node3不能跟在它后面，因此需要将node2出队，也即node.prev = pred = pred.prev，有：</span></span><br><span class="line"><span class="comment">  head(ws=-1)&lt;-&gt;node1(ws=-1)&lt;-&gt;node3(ws=0)-&gt; null</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  如果链表中不止一个node2取消排队，还有很多节点也是处于“取消排队状态”，那么就使用前向遍历，直到找到有一个前驱线程节点不是取消排队的节点（说明此节点状态可靠），然后把它作为node3的前驱节点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">             <span class="comment">//将原来写法 node.prev = pred = pred.prev拆分为下面写法</span></span><br><span class="line">               pred=pred.prev;</span><br><span class="line">               node.prev = pred</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">         	<span class="comment">// 经过前向遍历后，所有取消状态的节点都被出队，那么到这里就可以找到一个可靠状态的pred前驱节点，将要处理的node挂在它后面即可</span></span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*注意这里的注释，非常重要：</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">         	<span class="comment">//③ 执行流来到这里说明前驱节点waitStatus要么是0要么是PROPAGATE，此时需要将待处理的node节点前驱节点pred的waitStatus设为SIGNAL值，以表示我作为pred的后驱节点需要等待被唤醒，但还没进入park阻塞状态。</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>流程：</p>
<p>1、构造器使用非公平同步类对象new NonfairSync()</p>
<p>2、lock.lock()调用1定义的lock()方法，尝试对父类AQS的state变量使用CAS从0更新为1，成功就将自己设为独占锁，失败就进入3</p>
<p>3、使用acquire(1)继续去竞争资源，其内部调用AQS的acquire方法，</p>
<p>4、AQS的acquire方法是模板方法，因此会调用子类的tryAcquire(arg)再次尝试更新state</p>
<p>5、子类tryAcquire里面的nonfairTryAcquire(1)，再次读取state，如果为0就尝试CAS加1，如果成功就跟2类似，失败CAS且当前线程是独占线程，就可以再次对state加1</p>
<p>6、否则AQS的tryAcquire(1)返回false，表示当前线程两次获取锁资源失败，那么就开始7</p>
<p>7、将当前线程包装为线程节点，将在addWaiter尝试加入双向链表：如果链表已经存在，快速执行CASTail，成功就返回，失败则使用enq使用for循环入队：第一次循环判断是否需要初始化双向链表，如果需要则新建一个辅助节点头结点，第二次循环才是CASTail，由于使用自旋，因此enq一定可以使得线程节点加入双向链表尾部。</p>
<p>8、在acquireQueued中，刚入队的线程节点如果恰好又是第一个线程节点就会马上尝试tryAcquire(1)，如果成功获取锁资源，就会将setHead操作，并将当前线程节点设为辅助节点（也即线程出队），如果tryAcquire(1)失败来到9</p>
<p>9、使用shouldParkAfterFailedAcquire(pred, node)  ，第一个线程节点尝试tryAcquire(1)失败后不能无限循环再获取资源，因此将它的前驱节点设为SIGNAL状态（要求：pred == node.prev 读一致性），表示当前节点等待阻塞中，需要被唤醒</p>
<p>10、由于当前节点的前驱节点可能处于“取消排队状态”，因此当前节点不能将此类节点作为自己的前驱节点，因此需要不断前向遍历，直到找到waitStatus&lt;=0的前驱节点 pred(waitStatus&lt;=0)（找到一个可以“挂靠”的、非取消状态的前驱节点）由于使用</p>
<p><code>node.prev = pred = pred.prev</code> 因此只要处于“取消排队状态”的前驱节点都会被删掉而不在链表中。</p>
<p>11、只要将前驱节点的ws设为Node.SIGNAL，那么就可以返回true，来到parkAndCheckInterrupt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>线程节点就可以自己阻塞了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>12、回到acquire(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment"> * acquire on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上流程完成了 线程入队、尝试获取锁资源、阻塞自己变成等待唤醒，接下来</p>
<p>需要了解清楚，在线程节点执行阻塞自己的时候使用shouldParkAfterFailedAcquire，里面能够向前遍历阻塞队列并会有side-effect作用：沿途清除“处在取消状态的线程节点”，那么为何会出现又取消状态的节点呢？以及在什么时机变成取消状态节点？</p>
<h5 id="4-5-acquireQueued里面的cancelAcquire-node"><a href="#4-5-acquireQueued里面的cancelAcquire-node" class="headerlink" title="4.5  acquireQueued里面的cancelAcquire(node)"></a>4.5  acquireQueued里面的cancelAcquire(node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p>
<ul>
<li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li>
<li>是在什么时间释放节点通知到被挂起的线程呢？</li>
</ul>
<p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utilities for various versions of acquire</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">/* cancelAcquire流程将结合以下链表结构作为解释，其中node4就是当前要被设为取消排队的线程节点，如果node5是null，那么说明node4是tail节点，如果node5是线程节点，说明node4不在链表尾部：</span></span><br><span class="line"><span class="comment">  	head&lt;-&gt;node1(非取消)&lt;-&gt;node2(CANCELLED)&lt;-&gt;node3(CANCELLED)&lt;-&gt;node4(非取消)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">  	<span class="comment">// 准备执行时发现node4已结被回收，则可以直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 既然当前节点取消排队，那么node.thread不再指向线程，转而执行null，用于GC</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ① </span></span><br><span class="line"><span class="comment">    例如按上面的链表节点结构假设，node4被设为CANCELLED状态前，必须先找到一个非CANCELLED的前驱节点，以便node4取消排队后，其后驱节点node5才可以挂靠在一个“可靠的前驱节点”pred，显然这个pred就是node1节点：</span></span><br><span class="line"><span class="comment">    也即：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(非取消)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">    而node2和node3线程节点都是取消排队状态，因此需要跳过它们：Skip cancelled predecessors</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">   <span class="comment">// pred.next=node ,pred=node.prev</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ②</span></span><br><span class="line"><span class="comment">   继续上面已经跳过cancelled predecessors，有：</span></span><br><span class="line"><span class="comment">   		head&lt;-&gt;node1(非取消)&lt;-&gt;node4(非取消)&lt;-&gt;node5，此时可以把node4设为取消状态</span></span><br><span class="line"><span class="comment">   也即：</span></span><br><span class="line"><span class="comment">   		head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">   		做这个操作有个收益： other Nodes can skip past us，也就是说其他当外面有新线程入队需要做shouldParkAfterFailedAcquire等操作时，都会忽略这个已经是CANCELLED状态的node4节点，这样cancelAcquire操作就不会被外界线程节点干扰到。</span></span><br><span class="line"><span class="comment">   	  acquireQueued和shouldParkAfterFailedAcquire回答了准备设置“CANCELLED”线程节点时机，而cancelAcquire的设计回答在什么条件下将“准备取消节点”设为“CANCELLED”</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">     node.waitStatus = Node.CANCELLED;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ③</span></span><br><span class="line"><span class="comment">   对于②链表结构：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5，如果node4本身就是tail节点（此时node5其实是null），那么将node4进行CAS设为null后，链表结构变为：</span></span><br><span class="line"><span class="comment">   head&lt;-&gt;node1(非取消)-&gt;null，也即注释里面说到的：If we are the tail, remove ourselves.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">         ④ </span></span><br><span class="line"><span class="comment">         根据③得到的链表结构且node4不是tail节点（此时node5是线程节点），</span></span><br><span class="line"><span class="comment">         有：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">         if条件1：如果pred不是头节点而且指向具体线程（也即node1不是头节点）且pred节点也即node1.ws是SIGNAL，那么则进入if</span></span><br><span class="line"><span class="comment">         if条件2：如果pred不是头节点而且指向具体线程（也即node1不是头节点）且pred节点也即node1.ws&lt;=0且经过CAS将node1.ws设为SIGNAL，那么则进入if。</span></span><br><span class="line"><span class="comment">         条件1意思是说如果node1.ws已经是SIGNAL，那么直接将node5（不是null且未取消）设为node1的后驱节点，这样就能正确的删除node4节点，而且能正确的将后面的线程节点挂在node1后面</span></span><br><span class="line"><span class="comment">         head&lt;-&gt;node1(ws=SIGNAL)&lt;-&gt;node5(ws非取消)</span></span><br><span class="line"><span class="comment">         条件2的意思是说如果node1.ws是未取消状态值那么就用CAS将node1.ws设为SIGNAL，然后再把node5（要求不是null且未取消）挂在node1后面</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">          	<span class="comment">// 要求即将被删除的node4节点的后驱节点node5既不是null且未取消状态才能将node5挂在node4前驱节点pred的后面</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	 ⑤ </span></span><br><span class="line"><span class="comment">      	 若不满足④说明，node4的前驱节点就是head节点，也即：</span></span><br><span class="line"><span class="comment">      	 head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">      	 那么，node4很快会被删除，那么node5（如果node5不是null也不是非取消节点）就作为阻塞队列的第一个线程节点当然可以优先出队去获外面其他线程释放的锁资源</span></span><br><span class="line"><span class="comment">      	 因此ndoe4删除前，需要先唤醒后驱节点node5，接下来就来到4.6下面的章节逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-6unparkSuccessor"><a href="#4-6unparkSuccessor" class="headerlink" title="4.6unparkSuccessor"></a>4.6<code>unparkSuccessor</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 接上面4.5的⑤内容，如果node4有后驱节点，那么就node4需要唤醒这个后驱节点（假设后驱节点不是null也不是取消状态）</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">       * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">       * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    	<span class="comment">// 由于接上面4.5流程，node4已经设为CANCELLED，那么以下if逻辑会被跳过</span></span><br><span class="line">      <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">          compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">       * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">       * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">       * non-cancelled successor.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	node4的后驱节点一定是个正常的线程节点吗？ node4.next可能是以下几种情况：</span></span><br><span class="line"><span class="comment">    	① node4-&gt;null</span></span><br><span class="line"><span class="comment">      ② head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5(CANCELLED)&lt;-&gt;node6(CANCELLED)&lt;-&gt;node7(非取消状态)....</span></span><br><span class="line"><span class="comment">      ③ head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5(非取消)....</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      Node s = node.next; <span class="comment">// 先取出node4的后驱节点</span></span><br><span class="line">    	<span class="comment">// 针对后驱节点为null或者后驱节点是取消状态的情况，如①、②链表结构所示</span></span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          s = <span class="keyword">null</span>;</span><br><span class="line">        	<span class="comment">// 从阻塞链表（阻塞队列）尾部向前遍历，找出一个waitStatus是不取消状态的的后驱节点，这个节点就是node4要唤醒的正常状态节点（总不能让node4唤醒一个已经取消排队或者为null的后驱节点吧）</span></span><br><span class="line">          <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  s = t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 针对情况③ node4的直接后驱节点就是正常状态节点或者经过&quot;traverse backwards&quot;找到的the actual non-cancelled successor，唤醒之</span></span><br><span class="line">      <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">          LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上完成<code>reentrantlock</code>的加锁lock.lcok() 过程</p>
<p>在<code>unparkSuccessor</code>为何采用从链表尾部向前遍历，而不是正序遍历去找一个<code>the actual non-cancelled successor</code> ?</p>
<p>首先在AQS的开头源代码注释里面有提到：</p>
<blockquote>
<p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor.</p>
<p>prev前驱指针主要用于解决线程节点取消排队的情况（注意CLH locks并没有使用prev前驱指针），如果一个线程节点已经取消，那么它的后驱节点就会重新链接到一个非取消状态的前驱节点</p>
<p>例如  现有阻塞队列结构：node1(非取消)&lt;—&gt;node2(取消)&lt;—&gt;node3(非取消)&lt;—&gt;node4(非取消)，假设现在要将node3设为取消节点，最终队列肯定要变成：node1(非取消)&lt;—&gt;node4(非取消)，过程就是按照cancelAcquire的流程：</p>
<p>①  跳过node3“已经是取消状态”的节点，也即node2</p>
<p>② 此时node1就是node3的后驱节点node4需要挂靠的前驱节点</p>
<p>③ 根据以下逻辑<code>compareAndSetNext(pred, predNext, next)</code>,也即<code>compareAndSetNext(pred=node1, predNext=node3, next=node4);</code>，可以推出：在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此只能利用prev指针从后往前遍历才能够遍历完全部的Node。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">     ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">         (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">        pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">      	<span class="comment">// 要求即将被删除的node4节点的后驱节点node5既不是null且未取消状态才能将node5挂在node4前驱节点pred的后面</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            compareAndSetNext(pred, predNext, next);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-7关于阻塞队列本身的其他方法：-Queue-inspection-methods"><a href="#4-7关于阻塞队列本身的其他方法：-Queue-inspection-methods" class="headerlink" title="4.7关于阻塞队列本身的其他方法： Queue inspection methods"></a>4.7关于阻塞队列本身的其他方法： Queue inspection methods</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Queries whether any threads are waiting to acquire. Note that</span></span><br><span class="line"><span class="comment">    * because cancellations due to interrupts and timeouts may occur</span></span><br><span class="line"><span class="comment">    * at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not guarantee that any</span></span><br><span class="line"><span class="comment">    * other thread will ever acquire.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">    * constant time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there may be other threads waiting to acquire</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// 返回队列里面是否有正在等待获取锁资源的线程节点，返回true也不代表存在“正在等待获取锁资源的线程节点”，因为“线程取消排队或者timeout”的情况随时可以发生，这会导致head != tail有二义性。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head != tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Queries whether any threads have ever contended to acquire this</span></span><br><span class="line"><span class="comment">    * synchronizer; that is if an acquire method has ever blocked.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">    * constant time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there has ever been contention</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// 返回是否曾经有线程出现过竞争同步器以获取锁资源，或者说acquire方法被阻塞过。简单的说：若head不为null，说明有线程节点执行enq方法里面的`compareAndSetHead(new Node())`，也即有竞争</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasContended</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation normally returns in</span></span><br><span class="line"><span class="comment">    * constant time, but may iterate upon contention if other threads are</span></span><br><span class="line"><span class="comment">    * concurrently modifying the queue.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="comment">// 返回阻塞队列中的第一个（等待时间最长的）线程节点，注意这可不是返回head这个头结点（辅助节点）。如果当前没有线程节点排队，则为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">       <span class="comment">// 先快速判断。head==tail说明阻塞队列还未创建，直接返回null即可，否则使用fullGetFirstQueuedThread去获取第一个线程节点。这种“投机性先实施A失败再实施B”的设计其实在ConcurrentHashMap里面的addCount：先尝试对baseCount累加失败则使用fullAddCount确保能够累加计数成功。</span></span><br><span class="line">       <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Version of getFirstQueuedThread called when fastpath fails</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Thread <span class="title">fullGetFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The first node is normally head.next. Try to get its</span></span><br><span class="line"><span class="comment">        * thread field, ensuring consistent reads: If thread</span></span><br><span class="line"><span class="comment">        * field is nulled out or s.prev is no longer head, then</span></span><br><span class="line"><span class="comment">        * some other thread(s) concurrently performed setHead in</span></span><br><span class="line"><span class="comment">        * between some of our reads. We try this twice before</span></span><br><span class="line"><span class="comment">        * resorting to traversal.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// h:head节点的临时变量，s：head节点的后驱节点(successor)临时变量</span></span><br><span class="line">       Node h, s;</span><br><span class="line">       Thread st;<span class="comment">// 后驱节点指向的线程:successorthread</span></span><br><span class="line">     </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       此设计非常巧妙：</span></span><br><span class="line"><span class="comment">       正常来说，阻塞队列的第一个线程节点就是我们要找的“first queued thread”节点,那么为了确保获取该节点刚开始读的线程节点，必须要保证前后一致性读：不一致性读是如何出现的呢？ 考察这种情况，第一次读node.thread不为空但第二读node.thread已经是null，或者第一次读s.prev是原来的head节点，第二次读s.prev已经不是原来的head节点，这是因为在这两次读的过程中，有其他线程节点正在并发执行setHead操作，那么如何快速实现一致性读呢？ 直接实施两次尝试即可！</span></span><br><span class="line"><span class="comment">       if ( (第一次尝试)|| (第二次尝试))</span></span><br><span class="line"><span class="comment">       第一次尝试：要求head节点不是null且后驱节点s不为null且s.prev还是指向原head节点且后驱节点的thread引用不为null</span></span><br><span class="line"><span class="comment">       第二次尝试： 要求head节点不是null且后驱节点s不为null且s.prev还是指向原head节点且后驱节点的thread引用不为null</span></span><br><span class="line"><span class="comment">       第一次尝试成功说明没有其他线程干扰确实是一致性读，那么head的后驱节点s就是要返回的first queued thread</span></span><br><span class="line"><span class="comment">       第一次尝试失败说明有其他线程正在进行setHead操作，那么需要再投机性的进行第二次尝试。</span></span><br><span class="line"><span class="comment">       如果第一次尝试失败、第二次尝试也失败，那么只能通过遍历阻塞队列的方式去找`first queued thread`</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>) ||</span><br><span class="line">           ((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>))</span><br><span class="line">           <span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Head&#x27;s next field might not have been set yet, or may have</span></span><br><span class="line"><span class="comment">        * been unset after setHead. So we must check to see if tail</span></span><br><span class="line"><span class="comment">        * is actually first node. If not, we continue on, safely</span></span><br><span class="line"><span class="comment">        * traversing from tail back to head to find first,</span></span><br><span class="line"><span class="comment">        * guaranteeing termination.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">			</span><br><span class="line">     	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			因为head节点next指针可能还未开始设置，又或者有线程在执行setHead过程中head的next还未设置好，因此直接无法利用next指针从链表头部往后遍历。</span></span><br><span class="line"><span class="comment">			所以需要这么做：先检查tail节点不为空时且tail节点不是head节点，说明此时有阻塞队列且有线程节点队列里面，这样就可以safely从链表尾部开始遍历，直到t指针指向head节点时说明t的前驱节点已经来到head位置即可结束遍历，</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">       Node t = tail;</span><br><span class="line">       Thread firstThread = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (t != <span class="keyword">null</span> &amp;&amp; t != head) &#123;</span><br><span class="line">           Thread tt = t.thread;</span><br><span class="line">         	<span class="comment">// firstThread不断更新指向途中经过的“非取消”的线程节点的线程引用</span></span><br><span class="line">         	<span class="comment">// 或者说跳过“取消排队”的线程节点</span></span><br><span class="line">           <span class="keyword">if</span> (tt != <span class="keyword">null</span>)</span><br><span class="line">               firstThread = tt;</span><br><span class="line">           t = t.prev;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> firstThread;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * Returns true if the given thread is currently queued.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This implementation traverses the queue to determine</span></span><br><span class="line"><span class="comment">    * presence of the given thread.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> thread the thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given thread is on the queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the thread is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// 判断给定线程是否在阻塞队列里面</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isQueued</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (thread == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     	<span class="comment">// 从链表尾部开始遍历（safely traversing from tail back to head），只要遍历节点的thread==给定的thread引用，返回true。</span></span><br><span class="line">       <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">           <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 还有其他共享模式下的队列方法，这里不在讨论范围。</span></span><br></pre></td></tr></table></figure>
<h4 id="5、解锁过程"><a href="#5、解锁过程" class="headerlink" title="5、解锁过程"></a>5、解锁过程</h4><p>其实只要掌握了加锁lock.lcok() 过程，也即<code>renntrantlock</code>和AQS之间的交互，那么解锁过程则相对节点</p>
<p>调用者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock() </span><br></pre></td></tr></table></figure>
<p><code>reentrantlock内部的</code>unlock`：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">// 加锁每次对state加1，释放锁则对state减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS内部的<code>release</code>方法：这里说明真正释放锁的所有操作都是在AQS内部完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的tryRelease就是子类Sync具体要实现的方法：将state值进行CAS减1操作</span></span><br><span class="line">    <span class="comment">// (1)如果子类的tryRelease更新state同步状态且state值为0，就会返回true，那么说明外面有线程能够释放锁资源，此时就需要将阻塞队列里面的第一个线程节点唤醒</span></span><br><span class="line">   <span class="comment">// (2) 如果子类的tryRelease更新state同步状态成功且state值不为0，则会返回false，说明当前有同一线程多次重入的锁并准备多次释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	取出头节点（辅助节点），如果阻塞队列存在或者头节点的后驱节点非取消非初始化，则该后驱节点需要被h唤醒</span></span><br><span class="line"><span class="comment">        ①对于h=null，说明阻塞队列已经不存在或者还未创建，或者刚创建Head=null，但是还未有线程节点入队，显然这些情况都不需要再做“唤醒操作”</span></span><br><span class="line"><span class="comment">        ②对于h不是null，说明头节点已经是一个new Node()辅助节点，此时如果h.waitStatus == 0，说明阻塞队列刚完成初始化，仅有一个head辅助节点，单还未有其他线程节点入队，因此也不需要再做“唤醒操作”</span></span><br><span class="line"><span class="comment">        ③对于h不是null，h.waitStatus != 0取值有哪些呢，因为reentrant是独占模式，waitStatus的取值分别是1，-1，而-2，-3是共享模式不在讨论范围，因此当h.waitStatus=-1，那么恰好head的后驱节点就是需要唤醒的节点当然使用unparkSuccessor逻辑，而h.waitStatus=1，说明head节点的后驱节点是一个“取消排队”的节点，那么需要借助unparkSuccessor方面里面找到一个真正的非取消状态节点（the actual non-cancelled successor）作为要唤醒的节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AQS内部的<code>release</code>方法中的<code>tryRelease</code>调用子类的Sysc的<code>tryRelease</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 读取最新的state值并扣减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  	<span class="comment">// 因为是独占模式，要求必须持有锁资源的线程才能去释放锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"><span class="comment">// 表示是否成功释放资源</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">// 如果c=0，说明当前state值已经是0，说明没有其他线程占用锁资源，将独占线程引用设为null即可，并将释放资源标志设为true</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 将state更新为扣减后的c值：state=getState() - releases</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free; <span class="comment">// true或者false将影响AQS的release流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、唤醒线程节点后的执行流"><a href="#6、唤醒线程节点后的执行流" class="headerlink" title="6、唤醒线程节点后的执行流"></a>6、唤醒线程节点后的执行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 这里是线程节点在acquireQueued里面被阻塞自己的地方，</span></span><br><span class="line">      	<span class="comment">// 唤醒后，将会执行下面这一句：返回线程是否中断状态</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于Thread.interrupted();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span></span><br><span class="line"><span class="comment">     * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment">     * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment">     * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment">     * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">     * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">     * returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">		<span class="comment">//  返回当前线程是否被中断过,线程第一次调用将返回true，表示被中断，若线程两次调用，则第二次返回没被中断过，所以要注意其源码注释说明：after the first call had cleared its interrupted</span></span><br><span class="line">     * status and before the second call had examined it</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里因为线程被唤醒，显然之前在阻塞队列等待的过程就等于“被中断过”，故<code>parkAndCheckInterrupt</code>返回为true，将继续<code>acquireQueued</code>以下的for流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 线程唤醒后parkAndCheckInterrupt返回true，回到for循环，当线程能够获取锁资源成功后，这个线程中断状态interrupted = true就会acquireQueued返回外部的acquire调用者。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上流程，<code>acquireQueued</code>返回true，回到调用<code>acquireQueued</code>的流程 <code>lock.lock()--&gt;acquire(1)--&gt;acquireQueued--&gt;selfInterrupt</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么将继续执行<code>selfInterrupt</code>逻辑：也即线程进入阻塞队列，被阻塞然后唤醒后（自己被中断过）拿到锁，最后线程自己中断一下，为何拿到锁后还要设计线程中断自己？这是什么逻辑？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>（1）先考察一个线程使用<code>lock.lock</code>且在<code>compareAndSetState</code>就直接拿到锁资源的情况（意味着它没有进入阻塞队列），显然整个过程线程自己没有被<code>LockSupport.park(this)</code>阻塞，因此这种线程无需执行<code>selfInterrupt</code> 操作，这样外界有其他逻辑检查这个线程的中断状态时就会知道它未中断过。</p>
<p>（2）由于Doug Lea采用这样的设计：Acquires in exclusive uninterruptible mode for thread already in queue（已在阻塞队列中的线程节点以独占且不可中断（不响应中断）的模式去等待获取锁资源）。只要有一个线程进入阻塞队列然后阻塞自己最后被唤醒且拿到锁的过程显然线程自己是有“中断过”的情况，因此拿到锁后，需要给自己补充一个“中断过”的标记，这样外界有其他逻辑检查这个线程的中断状态时就会知道它曾经中断过。</p>
<h4 id="7、reentrantlock的公平锁模式"><a href="#7、reentrantlock的公平锁模式" class="headerlink" title="7、reentrantlock的公平锁模式"></a>7、reentrantlock的公平锁模式</h4><p>有了以上基础，那么分析公平锁则显得简单一些。内部使用的是 FairSync内部同步器实现相关逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);  <span class="comment">// 构造器指定公平锁方式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>FairSync</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 以下是体现公平锁的设计思想：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">      	<span class="comment">//若state同步状态变量此时为0，那么说明线程可以直接去竞争锁资源</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/* ① 请求独占锁前先问问阻塞队列有无阻塞线程正在等待锁（这就体现公平的原则，后者当然要等先到者）</span></span><br><span class="line"><span class="comment">          如果阻塞队列有正在排队的线程节点，那么当前新来的线程就无法设置state值，只能去到③（假设非重入线程） 返回false，最终可能是需要进入acquireQueued逻辑把自己入队处理，因此这里的逻辑正是体现了获取锁资源的“公平性”</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ② 如果当前线程就是持有锁的线程，当然可以让它多次重入，只要不超过重入次数最大值即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加锁请求锁资源为<code>acquire(1)</code>是AQS的内部的<code>acquire</code>方法，再调用子类的<code>tryAcquire</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此完整过程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock() --&gt; lock内部的acquire(1) --&gt; FairSync内部的tryAcquire--&gt; 查询阻塞队列是否有线程节点正在排队 --&gt; 如果tryAcquire失败则进入AQS的acquireQueued内部逻辑</span><br></pre></td></tr></table></figure>
<p>hasQueuedPredecessors的设计逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Queries whether any threads have been waiting to acquire longer than the current thread.</span></span><br><span class="line"><span class="comment">     查询是否有线程节点的等待获取锁资源时间长于当前线程。</span></span><br><span class="line"><span class="comment">     或者用以下表达式也可以达到相同目的，但是hasQueuedPredecessors比它更高效</span></span><br><span class="line"><span class="comment"> 		 An invocation of this method is equivalent to (but may be more efficient than):</span></span><br><span class="line"><span class="comment">     获取第一个线程节点 != 当前节点且阻塞队列不为空，则返回true，说明当前节点排还不能马上去抢锁资源需要排在阻塞队列的线程节点之后</span></span><br><span class="line"><span class="comment">     如果阻塞队列为空，则返回false，当前节点可以马上去获取锁资源</span></span><br><span class="line"><span class="comment">     getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     由于中断或者timeout导致线程节点的“取消排队”的情况在任何时候都可以发生，因此返回true也不能保证其他线程就是比当前线程更早申请锁资源</span></span><br><span class="line"><span class="comment">     同理，返回false也不能说明现在阻塞队列是空，因为return false的瞬间可能会有其他线程成功竞争到进入排队</span></span><br><span class="line"><span class="comment">     Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">     timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">     guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">     thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">     race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">     due to the queue being empty.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hasQueuedPredecessors方法用于公平同步器使用以避免线程之间的碰撞竞争。</span></span><br><span class="line"><span class="comment">This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer&#x27;s tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:</span></span><br><span class="line"><span class="comment">公平的、可重入的、独占模式的同步器内部定义的tryAcquire应该是以下流程：</span></span><br><span class="line"><span class="comment"> protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">   		// 表示同一线程重入获取锁资源，只需要增加state值即可</span></span><br><span class="line"><span class="comment">     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">     return true;</span></span><br><span class="line"><span class="comment">   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">   	//如果阻塞队列里面有线程节点那么当前线程不能马上acquire到锁资源，要等其他线程节点，因此返回false</span></span><br><span class="line"><span class="comment">     return false;</span></span><br><span class="line"><span class="comment">   &#125; else &#123;</span></span><br><span class="line"><span class="comment">   	 // 其他情况说明锁资源没有其他线程竞争，当前线程节点可以直接去acquire</span></span><br><span class="line"><span class="comment">     // try to acquire normally</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> 以上的设计流程就是Reentrantlock里面公平锁FairSync的tryAcquire实现流程</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     （1）如果有一个排队线程在当前线程之前则返回true，例如公平锁的FairSync，外面新来的当前线程使用tryAcquire则需要判断阻塞队列是否有阻塞线程，如果有，那么当前线程就没办法马上拿到锁，只能等，这就体现公平原则：先来先得，等得越久的那个线程节点优先获取锁资源</span></span><br><span class="line"><span class="comment">     （2）如果当前线程恰好位于第一个线程节点或者阻塞队列没有线程节点，则返回false</span></span><br><span class="line"><span class="comment">true if there is a queued thread preceding the current thread, and false if the current thread is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">      </span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">      	<span class="comment">// 返回true条件： </span></span><br><span class="line">      	<span class="comment">// 情况1：head辅助节点已经完成初始化也即：compareAndSetHead(new Node())  且 head的后驱节点第一个线程节点是null</span></span><br><span class="line">        <span class="comment">// 情况2：head辅助节点已经完成初始化也即：compareAndSetHead(new Node())  且 head的后驱节点第一个线程节点不是当前节点</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8、到此可以总结公平和非公平的锁的区别"><a href="#8、到此可以总结公平和非公平的锁的区别" class="headerlink" title="8、到此可以总结公平和非公平的锁的区别"></a>8、到此可以总结公平和非公平的锁的区别</h4><p>非公平：直接CAS竞争state这个锁资源，不需要询问阻塞队列是否有线程节点正在等待获取锁资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平：当state为0时，需要询问阻塞队列是否有线程节点正在等待获取锁资源，如果有则无法马上获取锁资源，需要等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>非公平的优点：线程并发性能高，因为所有新来的线程先通过<code>compareAndSetState(0, 1)</code>竞争锁资源，如果成功就能马上返回，无需经过排队。</p>
<p>非公平的缺点：因为新来的线程很快通过<code>compareAndSetState(0, 1)</code>提前获得锁资源，导致阻塞队列的线程节点可能一直没有机会出队获取锁资源，也即出现“线程饥饿”</p>
<p>线程饿死的解释：</p>
<blockquote>
<p>If a thread is not granted CPU time because other threads grab it all, it is called “starvation”. The thread is “starved to death” because other threads are allowed the CPU time instead of it. The solution to starvation is called “fairness” - that all threads are fairly granted a chance to execute.</p>
</blockquote>
<p>公平的优点：不会出现线程饿死，保证每个新来的线程都有机会获得竞争锁资源</p>
<p>公共的缺点：线程并发性能可能比非公平锁低一些。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/" rel="prev" title="Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现">
      <i class="fa fa-chevron-left"></i> Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/09/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9AUnsafe%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84JUC%E6%A1%86%E6%9E%B6free-lock%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%AE%A8%E8%AE%BA/" rel="next" title="Java高级主题：Unsafe类实现的JUC框架free-lock设计原理讨论">
      Java高级主题：Unsafe类实现的JUC框架free-lock设计原理讨论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%86%85%E9%83%A8%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">单线程使用可重入锁的内部简单工作机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8ESync%E7%B1%BB%E4%BA%86%E8%A7%A3AQS"><span class="nav-number">2.</span> <span class="nav-text">从Sync类了解AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81AQS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">1、AQS工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">2、从构造方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E2%80%9DQueuing%E2%80%9D-%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">3、关于线程是如何被”Queuing” 入队操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-NonfairSync"><span class="nav-number">5.1.</span> <span class="nav-text">3.1 NonfairSync</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-acquire-1"><span class="nav-number">5.2.</span> <span class="nav-text">3.2 acquire(1)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-nonfairTryAcquire"><span class="nav-number">5.3.</span> <span class="nav-text">3.3 nonfairTryAcquire</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AQS-%E7%9A%84acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><span class="nav-number">6.</span> <span class="nav-text">4、AQS 的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-addWaiter-Node-EXCLUSIVE"><span class="nav-number">6.1.</span> <span class="nav-text">4.1 addWaiter(Node.EXCLUSIVE)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-enq-node"><span class="nav-number">6.2.</span> <span class="nav-text">4.2 enq(node)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-acquireQueued-addWaiter-Node-EXCLUSIVE-1"><span class="nav-number">6.3.</span> <span class="nav-text">4.3 acquireQueued(addWaiter(Node.EXCLUSIVE),1))</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-shouldParkAfterFailedAcquire-p-node"><span class="nav-number">6.4.</span> <span class="nav-text">4.4 shouldParkAfterFailedAcquire(p, node)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-acquireQueued%E9%87%8C%E9%9D%A2%E7%9A%84cancelAcquire-node"><span class="nav-number">6.5.</span> <span class="nav-text">4.5  acquireQueued里面的cancelAcquire(node)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6unparkSuccessor"><span class="nav-number">6.6.</span> <span class="nav-text">4.6unparkSuccessor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7%E5%85%B3%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%EF%BC%9A-Queue-inspection-methods"><span class="nav-number">6.7.</span> <span class="nav-text">4.7关于阻塞队列本身的其他方法： Queue inspection methods</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">5、解锁过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B%E8%8A%82%E7%82%B9%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">6、唤醒线程节点后的执行流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81reentrantlock%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">7、reentrantlock的公平锁模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E5%88%B0%E6%AD%A4%E5%8F%AF%E4%BB%A5%E6%80%BB%E7%BB%93%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">8、到此可以总结公平和非公平的锁的区别</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://www.linuxprobe.com/wp-content/uploads/2018/06/QQ%E5%9B%BE%E7%89%8720180625205006.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">一个聪明的、友好的且专注于高水平技术总结的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yield-bytes</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
