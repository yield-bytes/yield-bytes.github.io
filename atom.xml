<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yield-bytes</title>
  
  <subtitle>沉淀、分享与无限进步</subtitle>
  <link href="https://yield-bytes.github.io/atom.xml" rel="self"/>
  
  <link href="https://yield-bytes.github.io/"/>
  <updated>2022-05-10T03:36:18.789Z</updated>
  <id>https://yield-bytes.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java高级主题：深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（下）</title>
    <link href="https://yield-bytes.github.io/2022/01/30/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84ConcurrentSkipListMap%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://yield-bytes.github.io/2022/01/30/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84ConcurrentSkipListMap%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-05-10T03:36:18.789Z</updated>
    
    <content type="html"><![CDATA[<p>文章说明：因为CSM解析内容较多，因此全文分为“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）”和“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（下）”两篇文章<br>上篇：CSM数据结构设计原理、doGet、doPut核心方法解析<br>下篇：doRemove核心方法解析、总结</p><p><img src="https://img-blog.csdnimg.cn/015a4701c67246769fa08e411c3c9896.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>《gitee 博客文章封面》</p><h4 id="remove方法："><a href="#remove方法：" class="headerlink" title="remove方法："></a>remove方法：</h4><h5 id="删除操作的设计原理"><a href="#删除操作的设计原理" class="headerlink" title="删除操作的设计原理"></a>删除操作的设计原理</h5><p>这里先介绍Doug Lea在源代码注释给出算法设计说明：n.helpDelete(b,f)的设计原理</p><p>上一篇文章的doGet、doPut方法中都有涉及到遇到被标记”删除“的节点时都会加入<code>n.helpDelete(b,f)</code>的处理逻辑，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* In addition to using deletion markers, the lists also use</span><br><span class="line">* nullness of value fields to indicate deletion, in a style</span><br><span class="line">* similar to typical lazy-deletion schemes.  If a node&#x27;s value is</span><br><span class="line">* null, then it is considered logically deleted and ignored even</span><br><span class="line">* though it is still reachable. This maintains proper control of</span><br><span class="line">* concurrent replace vs delete operations -- an attempted replace</span><br><span class="line">* must fail if a delete beat it by nulling field, and a delete</span><br><span class="line">* must return the last non-null value held in the field. (Note:</span><br><span class="line">* Null, rather than some special marker, is used for value fields</span><br><span class="line">* here because it just so happens to mesh with the Map API</span><br><span class="line">* requirement that method get returns null if there is no</span><br><span class="line">* mapping, which allows nodes to remain concurrently readable</span><br><span class="line">* even when deleted. Using any other marker value here would be</span><br><span class="line">* messy at best.)</span><br><span class="line">* n是当前要删除的节点，b是n的前驱节点，f是n的后继节点，开始删除前，(b,n,f)的指向关系如下</span><br><span class="line">* Here&#x27;s the sequence of events for a deletion of node n with</span><br><span class="line">* predecessor b and successor f, initially:</span><br><span class="line">*</span><br><span class="line">*        +------+       +------+      +------+</span><br><span class="line">*   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...</span><br><span class="line">*        +------+       +------+      +------+</span><br><span class="line">*</span><br><span class="line">* 1. CAS n&#x27;s value field from non-null to null.</span><br><span class="line">*    From this point on, no public operations encountering</span><br><span class="line">*    the node consider this mapping to exist. However, other</span><br><span class="line">*    ongoing insertions and deletions might still modify</span><br><span class="line">*    n&#x27;s next pointer.</span><br><span class="line">*</span><br><span class="line">* 1、 将删除节点n的value使用cas设成null，表示此刻起，n节点处于待删除状态，虽然其value为null，对于public相关方法如get等，在执行遇到此类型节点时不会将该节点视为有效节点（也即会被跳过处理），但是如果对于正在执行的插入和删除操作的方法来说，可能也可以去更改“此待删除节点n”的后继节点。</span><br><span class="line">* 2. CAS n&#x27;s next pointer to point to a new marker node.</span><br><span class="line">*    From this point on, no other nodes can be appended to n.</span><br><span class="line">*    which avoids deletion errors in CAS-based linked lists.</span><br><span class="line">*</span><br><span class="line">*        +------+       +------+      +------+       +------+</span><br><span class="line">*   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...</span><br><span class="line">*        +------+       +------+      +------+       +------+</span><br><span class="line">* 2、使用cas将n节点的next字段指向一个marker节点后，从此刻起，任何节点都不会被放在n的后继节点位置，也即不可能出现n-&gt;n1、n-&gt;n2等，只有n-&gt;marker</span><br><span class="line">* 3. CAS b&#x27;s next pointer over both n and its marker.</span><br><span class="line">*    From this point on, no new traversals will encounter n,</span><br><span class="line">*    and it can eventually be GCed.</span><br><span class="line">*        +------+                                    +------+</span><br><span class="line">*   ...  |   b  |-----------------------------------&gt;|   f  | ...</span><br><span class="line">*        +------+                                    +------+</span><br><span class="line">* 3、通过cas将b的next指针（越过n节点以及n的后继marker节点）指向f节点，从此刻起，n节点不会被相关操作遍历到，n最终会被GC。</span><br></pre></td></tr></table></figure><p>可以看出CSM删除操作方面，借用marker节点来实现，将待删除节点的value设为null值来表示该节点处在删除状态但还未真正删除，这种设计风格就像“惰性删除语义(lazy-deletion schemes)”，先标记删，等某个时机再真正执行之。如果CSM的一个节点的value是null，说明该节点在逻辑上已经被删除。</p><a id="more"></a><p>以下是remove方法的源代码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);<span class="comment">//注意只需要比较key即可，不需要考虑value相等才删除！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体逻辑由doRemove实现"><a href="#具体逻辑由doRemove实现" class="headerlink" title="具体逻辑由doRemove实现"></a>具体逻辑由doRemove实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 1、和doGet、findNode类似设计，首先找到key的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">          <span class="comment">// 经典的(b,n,f)三指针</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">          <span class="comment">// 2、n已不是b的后继节点，也即读n节点前后不一致，则重试</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 3、数据节点n节点被标记为删除状态，那么使用helpDelete把n节点删除，然后重试。</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 4、key的前驱节点b被标记删除状态，只能重试，读取新的b</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//5、 给定的key不在数据链表里面，直接结束</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">          <span class="comment">//6、 给定的key比当前数据节点n还大，那么更新b、n向右继续检索</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 以下找到与key相等的n节点</span></span><br><span class="line">            <span class="comment">//7、doRemove的入参value默认是null，因此以下会被跳过，若指定value，则还需判断给定的value和当前找到n.value是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//8、执行流运行到这里，说明满足删除n节点的条件也即key=n.key,n就是要删除的目标数据节点，因此将n.value设为null，cas失败则重试，注意这是是标记删除，不是直接把n节点删除。</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*9、执行流运行到这里，说明n成功被标记删除状态</span></span><br><span class="line"><span class="comment">          条件1：将 b → n → f 变成  b → n → marker → f</span></span><br><span class="line"><span class="comment">          条件2：将 b → n → f 变成 b → f</span></span><br><span class="line"><span class="comment">          如果条件1CAS失败或者条件2CAS失败，都会调用findNode(key)来删除数据节点n</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*10、不妨假设条件1成立，也即将 b → n → f 变成  b → n → marker → f</span></span><br><span class="line"><span class="comment">              需要n节点上方的索引节点都清除（包括清除索引节点的前后指向关系），恰好findPredecessor就是在索引层干这事。</span></span><br><span class="line"><span class="comment">              */</span> </span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然在doGet方法中有给出findPredecessor，它是用在查询场景中，而在本小节中findPredecessor被用来删除n节点对应的上方索引节点场景中，现在结合上方doRmove的源代码理解，将更能掌握其中设计逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don&#x27;t postpone errors</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">          <span class="comment">//在当前索引层检索，只要不是来到链表尾部，就继续在该层里面遍历</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">// 此处对应的是上方doRemove内部将n.value标记为null的情况</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">/* 既然数据层的n节点被删除，那么n节点对应上方关联的索引节点r也要删除:</span></span><br><span class="line"><span class="comment">                    索引层：将 q → r → r.right 变成  q → r.right </span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                  <span class="comment">// 索引节点r成功删除后，将r指向q的新right节点，此时q → r 两个索引节点都处于正常状态，继续下一轮遍历。</span></span><br><span class="line">                    r = q.right;         <span class="comment">// reread r</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 继续在该层索引向右检索，直到cpr(cmp, key, k) =0</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 当q位于第1层索引层位置时，此时q.down指向的是idx=null，因此可退出，到此从入口head到出口q.down=null沿途找到的与n对应的每层索引节点idx都被删除掉。可直接退出</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">          <span class="comment">// 执行流运行到这里，说明还未到达第1层索引层，以上逻辑完成当前层的idx节点删除，那么继续需要处理n节点对应的更低层的索引节点idx。</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在doRemove方法的角度来看， findPredecessor(key, cmp) 实际意义是单纯用于clean index，而不是为key找到前驱节点b这么简单，这里的clean index功能就是Doug Lea提到的“side-effect”，也即下面这句话的含义：</p><blockquote><p>Callers rely on this side-effect of clearing indices to deleted nodes.</p></blockquote><p>doRemove作为调用方，能够从调用findPredecessor过程获得额外收益：清除那些已被标记为“删除状态”的数据节点上方对应的每层索引节点idx。</p><p>关于doRemove的图解这里不再给出，想要深入理解的同学务必自行将删除逻辑对应的图做出来，否则将难以理解其过程的动态处理。</p><h5 id="tryReduceLevel-方法"><a href="#tryReduceLevel-方法" class="headerlink" title="tryReduceLevel()方法"></a>tryReduceLevel()方法</h5><p>在doRemove方法的第10个逻辑中，清理完索引节点后，还需要检查是否需要“降层处理”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*10、不妨假设条件1成立，也即将 b → n → f 变成  b → n → marker → f</span></span><br><span class="line"><span class="comment">  需要n节点上方的索引节点都清除（包括清除索引节点的前后指向关系），恰好findPredecessor就是在索引层干这事。</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">    findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">    <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">        tryReduceLevel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryReduceLevel设计，在一个if里面塞进去8个条件，而且只有h.level超过3层才进行“降层”处理，等于3层不对索引层“减层”，以下不妨考察h.level=4的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryReduceLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HeadIndex&lt;K,V&gt; h = head; </span><br><span class="line">    HeadIndex&lt;K,V&gt; d;</span><br><span class="line">    HeadIndex&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (h.level &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// h</span></span><br><span class="line">        (d = (HeadIndex&lt;K,V&gt;)h.down) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (e = (HeadIndex&lt;K,V&gt;)d.down) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        e.right == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        d.right == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        h.right == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        casHead(h, d) &amp;&amp; <span class="comment">// try to set</span></span><br><span class="line">        h.right != <span class="keyword">null</span>) <span class="comment">// recheck</span></span><br><span class="line">        casHead(d, h);   <span class="comment">// try to backout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将具有level=4的HeadIndex结构图：<br>h（原位于level=4的HeadIndex） → null<br>↓<br>d → null<br>↓<br>e → null<br>变成level=3的HeadIndex结构：<br>h(d) (原位于level=3的d节点作为新的HeadIndex)→ idx<br>↓<br>e → idx</p><h5 id="关于n-helpDelete-b-f-的解析："><a href="#关于n-helpDelete-b-f-的解析：" class="headerlink" title="关于n.helpDelete(b, f)的解析："></a>关于n.helpDelete(b, f)的解析：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helps out a deletion by appending marker or unlinking from</span></span><br><span class="line"><span class="comment"> * predecessor. This is called during traversals when value</span></span><br><span class="line"><span class="comment"> * field seen to be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b predecessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f successor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// b是n的前驱节点，n是待删除节点，f是n的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Rechecking links and then doing only one of the</span></span><br><span class="line"><span class="comment">     * help-out stages per call tends to minimize CAS</span></span><br><span class="line"><span class="comment">     * interference among helping threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 当前线程前后读取的b、n、f保持不变时，就可以实施cas操作</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">this</span>.next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">     条件1：对于b → n → null这种情况，f=n.next,显然f为null</span></span><br><span class="line"><span class="comment">     条件2：对于b → n → f，且f节点不是marker节点，那么给n添加一个marker节点：</span></span><br><span class="line"><span class="comment">     b → n → marker → f，注意：marker指向f节点指向关系不是因为next指针，而是由marker的value指针指向f完成。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">            casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/*否则f节点一定是marker节点，且b、n、f以及marker的指向关系如下：</span></span><br><span class="line"><span class="comment">          b → n → f(marker)→ f.next 变成 b → f.next</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">             b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解marker节点的实际设计意义"><a href="#理解marker节点的实际设计意义" class="headerlink" title="理解marker节点的实际设计意义"></a>理解marker节点的实际设计意义</h5><p>解析器设计意义需要基于图解，因为涉及到多线程并发删除的非原子性操作。</p><ul><li>无maker节点的删除设计</li></ul><p>假设线程的cpu时间片分配顺序如下：<br><img src="https://img-blog.csdnimg.cn/7a0fb41cb348491aa6ed71a852d6f746.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>结果是明显的，线程B以为自己成功插入了该节点，但对于读线程C来说，新插入节点newNode不可能被从b开始遍历到。</p><p>核心原因在于在第4个cpu时间片时，线程B使用<code>n.casNext(f,new Node&lt;&gt;(k,v,next=f))</code>,只用f节点作为CAS比较并不能感知到链表结构已经发生变化，导致线程B前后读取f是一致，然后casNext成功插入的新节点。</p><p>这种删除设计使得插入操作不能正确执行，因此不采用。</p><ul><li>有maker节点的删除设计</li></ul><p>只要让插入线程能根据<code>n.casNext(cmp,new Node&lt;&gt;(k,v,next=cmp))</code> 感知cmp作为cas比较的节点已经发生改变，那么插入线程自然会cas失败，然后继续下一轮重试，直到读取的n节点不是删除状态，方可能正确插入节点。<br><img src="https://img-blog.csdnimg.cn/015a4701c67246769fa08e411c3c9896.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>对于图中的3和4的说明，因为cpu时间片执行顺序不确定，注意面临两种情况：</p><p>1、3执行CAS成功，4失败，迫使插入线程B的CAS插入失败后重新循环读取新的n节点</p><p>2、4执行CAS成功，3失败，迫使删除线程A的添加marker节点失败，只能重新循环读取新的n节点</p><p>只需一个marker即可实现写线程和写线程之间是线程安全的竞争。</p><h5 id="findFirst方法"><a href="#findFirst方法" class="headerlink" title="findFirst方法"></a>findFirst方法</h5><p>需要知道的一点是：数据层链表的HeadIndex的构成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcurrentSkipListMap()构造方法里面initialize()</span></span><br><span class="line"><span class="keyword">new</span> HeadIndex&lt;K,V&gt;(<span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, BASE_HEADER, <span class="keyword">null</span>),</span><br><span class="line">                                  <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>因此对于数据链表层的“头节点”可不是数据节点Node，而是索引头节点HeadIndex，因此构造阶段时：</p><p>HeadIndex(BASE_HEADER) → null，也即h.node → null，也即h.node =next=null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Specialized variant of findNode to get first valid node.</span></span><br><span class="line"><span class="comment"> * @return first node or null if empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">findFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; b, n;;) &#123;</span><br><span class="line">      <span class="comment">//如上面所解析，如果当前数据层链表仅有一个HeadIndex节点，还没有任何数据节点时，显然只能返回null，这里的b=new Node&lt;K,V&gt;(null, BASE_HEADER, null)</span></span><br><span class="line">        <span class="keyword">if</span> ((n = (b = head.node).next) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// n作为数据节点第一个头节点没有被标记位删除，那么n节点就是所早的FirstNode</span></span><br><span class="line">        <span class="keyword">if</span> (n.value != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">      <span class="comment">// 如果发现n已经被标记位删除，那么当前线程就去帮助删除该n节点。</span></span><br><span class="line">        n.helpDelete(b, n.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findFirst方法一般被其他方法调用，例如size()方法，通过找到数据层链表的数据头节点，然后即可在当成链表去遍历：</p><p>不过可以确定的是，此size方法的返回值不能正确反映当前数据层链表的长度，因为是并发环境，其他删除线程可以删除数据节点节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 通过findFirst返回首个数据节点，然后在此头节点遍历链表去统计即可。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; n = findFirst(); n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n.getValidValue() != <span class="keyword">null</span>)</span><br><span class="line">            ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>) count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>removeFirstEntry类似doRemove，基于(b,n,f)三节点去操作。</p><p>只要你掌握CSM的数据结构设计原理以及上面解析的doGet、doPut、doRemove、findPredecessor、findNode的具体实现逻辑，那么CSM其他方法都可以非常快的突破。</p><h4 id="CSM的小结内容"><a href="#CSM的小结内容" class="headerlink" title="CSM的小结内容"></a>CSM的小结内容</h4><h5 id="1、空间复杂度计算"><a href="#1、空间复杂度计算" class="headerlink" title="1、空间复杂度计算"></a>1、空间复杂度计算</h5><p>按照本文给出的图示，不妨假设当前数据层链表节点个数为$n$， 根据源代码文件的注释说明，一个新插入的数据节点它被作为上方一层的索引节点的概率为0.5，因此有以下非严格数学归纳过程（考虑理想情况下的分布）</p><p>level=1，该层索引层对应的索引节点数量 $\frac{n}{2}$</p><p>level=2，该层索引层对应的索引节点数量$\frac{n}{2^2}$</p><p>level=3，该层索引层对应的索引节点数量$\frac{n}{2^2}$</p><p>…</p><p>level=k，该层索引层对应的索引节点数量$\frac{n}{2^k}$</p><p>不妨假设第k层就是该跳表的最顶层索引层且假设仅有1个索引节点</p><p>那么有$\frac{n}{2^k}=1$ ，可算出k的值为：$k=log_2n$ ，习惯性写法为$k=log(n)$</p><p>到这里应该可以联想k的含义类似二叉树的高度h，h的推算也是类似的思路。</p><p>那么k层的跳表需要额外存储多少索引节点呢？（这里说的额外是指不计数据层节点）总共k层的索引节点相加如下</p><p>$\frac{n}{2}+\frac{n}{2^2}+\frac{n}{2^3}+\frac{n}{2^4}+…+4+2+1$ 共有k项，等比为0.5，求和：$sum=n-1$，也即当成为索引节点的概率取值为0.5时，需要额外存储n-1个索引节点，例如数据层节点16个，那么对应四层索引层的索引节点数为8，4，2 ，1</p><p>同理若成为索引节点的概率取值为$\dfrac{1}{4}$时，需要存储$\frac{n-1}{3}$  个索引节点。例如数据层节点16个，那么对应两层索引层的索引节点数为4，1 。</p><p>容易推出：当成为索引节点的概率取值为0.5时，需要额外存储n-1个索引节点，再加数据节点数量n个，也即CSM总共存储2n-1个节点，故空间复杂度为$o(n)$，当前去其他概率值也有类似结论，这里不再给出说明。一般使用概率p=0.5，作为CSM数据节点被选中作为索引节点的概率，如果概率选太小例如$\frac{1}{128}$，那么每次查询都几乎都要下沉到数据层去查找，那么查询时间复杂度就会退化到解决$o(n)$</p><h5 id="2、时间复杂度"><a href="#2、时间复杂度" class="headerlink" title="2、时间复杂度"></a>2、时间复杂度</h5><p>根据空间复杂度的索引节点：</p><p>最好情况：最高层索引节点就是目的节点，搜索次数1</p><p>最坏情况：若一个新插入的数据节点它被作为上方一层的索引节点的概率为0.5，那么每一层索引层都需要遍历两次索引节点（最高层仅有一个索引节点就1次，若有两个索引节点就两次），不妨假设现在有跳表结构如下，共4层索引：</p><p>1 （level=4）</p><p>1，9  （level=3）</p><p>1，5，9，13 （level=2）</p><p>1，3，5，7，9，11，13，15 （level=1）</p><p>1，2，3，4，，，，，，，，15，16 （数据层链表）</p><p>现在需要查找16这个节点，从level=4开始，</p><p>（1）level=4，只需查找1次：比较1，下移</p><p>（2）level=3，只需查找2次：比较1，比较9，从9垂直下移到level=2的索引9节点</p><p>（3）level=2，只需查找2次：比较9，比较13，从13垂直下移到level=1的索引13节点</p><p>（3）数据层：因为每两个节点就有一个是索引节点，因此在数据层检索比较也是最多比较2两次</p><p>由上面空间复杂度计算过程可知，若数据层节点有n个前提下，索引层高度为$k=log(n)$ ,</p><p>那么时间复杂度的计算为：$k层*（每层索引搜索次数2）+数据层搜索次数2$，也即$log (n) \times 2 +2$，简化最终可知，跳表的查询复杂度为$log(n)$</p><p>同理，插入、删除节点都需要先从最顶层索引层开始检索定位，最后再下移到数据层链表进行插入和删除操作，因此插入、删除的时间复杂度也是和查找get的复杂一致：$log(n)$</p><p>关于SkipList的严格数学证明，学有余力的同学可以去翻阅跳表发明者William Pugh原著论文，<a href="https://klevas.mif.vu.lt/~ragaisis/ADS2006/skiplists.pdf">论文地址</a><br>以下是Dung Lea对SkipList性能的简要说明，可以看出其实跟TreeMap性能很接近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* Indexing uses skip list parameters that maintain good search</span><br><span class="line">* performance while using sparser-than-usual indices: The</span><br><span class="line">* hardwired parameters k&#x3D;1, p&#x3D;0.5 (see method doPut) mean</span><br><span class="line">* that about one-quarter of the nodes have indices. Of those that</span><br><span class="line">* do, half have one level, a quarter have two, and so on (see</span><br><span class="line">* Pugh&#39;s Skip List Cookbook, sec 3.4).  The expected total space</span><br><span class="line">* requirement for a map is slightly less than for the current</span><br><span class="line">* implementation of java.util.TreeMap.</span><br></pre></td></tr></table></figure></p><h5 id="3、对比ConcurrentHashMap"><a href="#3、对比ConcurrentHashMap" class="headerlink" title="3、对比ConcurrentHashMap"></a>3、对比ConcurrentHashMap</h5><p>CSM：ConcurrentSkipListMap，CHM：ConcurrentHashMap</p><ul><li>场景方面：</li></ul><p>CSM适用于要求key有序存放的场景，CHM适用于key无序存放的场景</p><ul><li>写操作性能</li></ul><p>高并发写（插入、删除）操作方面，CSM采用CAS无锁+更改节点指向实现写操作，插入不会阻塞删除操作，而CHM采用CAS+Synchronized独占锁方式，对于同一桶位进行插入操作会阻塞删除操作（反向也成立），那么这两种数据结构的插入、删除新能如何呢？</p><p>关于插入和删除的占用内存的比较如下：对象占用比较方面，这里使用lucene的一个工具类RamUsageEstimator</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.util.RamUsageEstimator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipListMapPerf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentSkipListMap&lt;Integer,Integer&gt; csm=<span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMap&lt;Integer,Integer&gt; chm=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scales=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> loops=<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> scale : scales) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程数：&quot;</span>+scale);</span><br><span class="line">            System.out.println(<span class="string">&quot;put:&quot;</span>);</span><br><span class="line">            csmPut(scale,loops);</span><br><span class="line">            chmPut(scale,loops);</span><br><span class="line">            System.out.println(<span class="string">&quot;ramUsage:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;csm:&quot;</span>+RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOfMap(csm)));</span><br><span class="line">            System.out.println(<span class="string">&quot;chm:&quot;</span>+RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOfMap(chm)));</span><br><span class="line">            System.out.println(<span class="string">&quot;remove:&quot;</span>);</span><br><span class="line">            csmRemove(scale,loops);</span><br><span class="line">            chmRemove(scale,loops);</span><br><span class="line">            System.out.println(<span class="string">&quot;ramUsage:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;csm&quot;</span>+RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOfMap(csm)));</span><br><span class="line">            System.out.println(<span class="string">&quot;chm&quot;</span>+RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOfMap(chm)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">csmPut</span><span class="params">(<span class="keyword">int</span> threadNums,<span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    csm.put(loop,loop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;csmPut：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chmPut</span><span class="params">(<span class="keyword">int</span> threadNums, <span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    chm.put(loop,loop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;chmPut：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">csmRemove</span><span class="params">(<span class="keyword">int</span> threadNums, <span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    csm.remove(loop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;csmRemove：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chmRemove</span><span class="params">(<span class="keyword">int</span> threadNums, <span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    chm.remove(loop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;chmRemove：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">线程数：1</span><br><span class="line">put:</span><br><span class="line">csmPut：线程数为1,计算1000000次,总用时2285ms</span><br><span class="line">chmPut：线程数为1,计算1000000次,总用时1446ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm:511.2 MB</span><br><span class="line">chm:511.2 MB</span><br><span class="line">remove:</span><br><span class="line">csmRemove：线程数为1,计算1000000次,总用时217ms</span><br><span class="line">chmRemove：线程数为1,计算1000000次,总用时111ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm48 bytes</span><br><span class="line">chm64 bytes</span><br><span class="line">线程数：4</span><br><span class="line">put:</span><br><span class="line">csmPut：线程数为4,计算1000000次,总用时676ms</span><br><span class="line">chmPut：线程数为4,计算1000000次,总用时520ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm:511.2 MB</span><br><span class="line">chm:511.2 MB</span><br><span class="line">remove:</span><br><span class="line">csmRemove：线程数为4,计算1000000次,总用时522ms</span><br><span class="line">chmRemove：线程数为4,计算1000000次,总用时296ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm48 bytes</span><br><span class="line">chm64 bytes</span><br><span class="line">线程数：16</span><br><span class="line">put:</span><br><span class="line">csmPut：线程数为16,计算1000000次,总用时1873ms</span><br><span class="line">chmPut：线程数为16,计算1000000次,总用时1687ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm:511.2 MB</span><br><span class="line">chm:511.2 MB</span><br><span class="line">remove:</span><br><span class="line">csmRemove：线程数为16,计算1000000次,总用时789ms</span><br><span class="line">chmRemove：线程数为16,计算1000000次,总用时234ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm48 bytes</span><br><span class="line">chm64 bytes</span><br><span class="line">线程数：64</span><br><span class="line">put:</span><br><span class="line">csmPut：线程数为64,计算1000000次,总用时5564ms</span><br><span class="line">chmPut：线程数为64,计算1000000次,总用时2879ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm:511.2 MB</span><br><span class="line">chm:511.2 MB</span><br><span class="line">remove:</span><br><span class="line">csmRemove：线程数为64,计算1000000次,总用时2505ms</span><br><span class="line">chmRemove：线程数为64,计算1000000次,总用时321ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm48 bytes</span><br><span class="line">chm64 bytes</span><br><span class="line">线程数：128</span><br><span class="line">put:</span><br><span class="line">csmPut：线程数为128,计算1000000次,总用时9665ms</span><br><span class="line">chmPut：线程数为128,计算1000000次,总用时4396ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm:511.2 MB</span><br><span class="line">chm:511.2 MB</span><br><span class="line">remove:</span><br><span class="line">csmRemove：线程数为128,计算1000000次,总用时4548ms</span><br><span class="line">chmRemove：线程数为128,计算1000000次,总用时880ms</span><br><span class="line">ramUsage:</span><br><span class="line">csm48 bytes</span><br><span class="line">chm64 bytes</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>从输出结果可以得到以下推论：</p><p>1、插入1百万个节点后，CSM和CHM在jvm的大小都很接近</p><p>2、在高并发插入场景下，CHM的性能比CSM快两倍左右，解释：</p><p>CSM插入大量节点时，每插入一个数据节点都判断是否要在此数据节点上方建立多层索引节点，若需要添加索引节点，那么创建索引节点后将索引节点链入该层索引层中。而CHM插入大量节点时，如果key的hash足够分散，那么大量节点其实是分布在底层的table桶位上，或者在部分桶位形成冲突链链表，在同一桶位上需要升级为红黑树结构的概率小，因此CHM通过不断扩容底层table让节点直接插入在桶位上，显然比CSM的插入逻辑要快很多。</p><p>3、在高并发删除方面，CHM的性能比CSM快5到6倍左右。</p><p>考察CSM并发删除，虽然它是基于CAS+marker的无锁方式去删除节点，但CSM删除一个节点前，首先需要去多层索引去检索该key的前驱节点，然后再删除该节点以及它对应的索引节点（调整所在层的前后指向），还得判断是否需要“降层处理”，而CHM方面，由于key是数值型，百万的key分布在桶位上相对均匀，因此对于底层table的桶位节点删除操作时非常快速的，少量桶位会涉及到冲突链表删除、红黑树转为链表或者红黑树删除平衡调整等但这些情况不多，因此整体上CHM的删除效率高很多。</p><p>4、查找效率方面对比</p><p>不用对比也知道，CHM因为是hashMap的$o(1)$查找效率，显然比CSM的$log(n)$要快，如下面数据对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csmGet：线程数为64,计算1000000次,总用时3949ms</span><br><span class="line">chmGet：线程数为64,计算1000000次,总用时572ms</span><br><span class="line"></span><br><span class="line">csmGet：线程数为128,计算1000000次,总用时8276ms</span><br><span class="line">chmGet：线程数为128,计算1000000次,总用时1150ms</span><br></pre></td></tr></table></figure><h5 id="4、CSM初始化时在new阶段还是在put阶段完成？"><a href="#4、CSM初始化时在new阶段还是在put阶段完成？" class="headerlink" title="4、CSM初始化时在new阶段还是在put阶段完成？"></a>4、CSM初始化时在new阶段还是在put阶段完成？</h5><p>CSM是在new阶段完成初始化：<code>initialize()</code>，而CHM是在第一次put才会初始化：<code>tab = initTable()</code></p><p>首先在new阶段已经完成初始化，CSM初始化逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    descendingMap = <span class="keyword">null</span>;</span><br><span class="line">    head = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(<span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, BASE_HEADER, <span class="keyword">null</span>),</span><br><span class="line">                              <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个new HeadIndex 是位于level=1的索引层，而这个<code>new Node&lt;K,V&gt;(null, BASE_HEADER, null)</code> 是位于最底层数据层链表，对应的图示如下：<br><img src="https://img-blog.csdnimg.cn/8e3faf34ba424df6aff13fa578779005.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h5 id="5、CSM最高有多少层索引"><a href="#5、CSM最高有多少层索引" class="headerlink" title="5、CSM最高有多少层索引"></a>5、CSM最高有多少层索引</h5><p>根据size方法，CSM的数据层链表最多可以链接个节点<code>Integer.MAX_VALUE</code>个节点，也即$2^{31}-1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; n = findFirst(); n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n.getValidValue() != <span class="keyword">null</span>)</span><br><span class="line">            ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>) count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据前面的上面1提到的空间复杂度计算，p=0.5，也即新插入的数据节点上升为索引节点的概率，那么最大索引层数为$k= log_2(2^{31}-1)$，计算结果为k=31，注意这个31层是指最大索引层数量（第31层有2个索引节点），不包括最底层的数据链表这一层！</p><p>那么CSM的节点数量和底层数组最大是多少呢？</p><p>节点数量最大值也是$2^{31}-1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层数组最大为$2^{30}$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The largest possible table capacity.  This value must be</span></span><br><span class="line"><span class="comment">   * exactly 1&lt;&lt;30 to stay within Java array allocation and indexing</span></span><br><span class="line"><span class="comment">   * bounds for power of two table sizes, and is further required</span></span><br><span class="line"><span class="comment">   * because the top two bits of 32bit hash fields are used for</span></span><br><span class="line"><span class="comment">   * control purposes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// top two bits of 32bit hash fields are used for control purposes ，第31和32位被用于相关“控制”，因此底层table的桶位数量最大值为2^30次方</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章说明：因为CSM解析内容较多，因此全文分为“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）”和“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（下）”两篇文章&lt;br&gt;上篇：CSM数据结构设计原理、doGet、doPut核心方法解析&lt;br&gt;下篇：doRemove核心方法解析、总结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/015a4701c67246769fa08e411c3c9896.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;
&lt;h4 id=&quot;remove方法：&quot;&gt;&lt;a href=&quot;#remove方法：&quot; class=&quot;headerlink&quot; title=&quot;remove方法：&quot;&gt;&lt;/a&gt;remove方法：&lt;/h4&gt;&lt;h5 id=&quot;删除操作的设计原理&quot;&gt;&lt;a href=&quot;#删除操作的设计原理&quot; class=&quot;headerlink&quot; title=&quot;删除操作的设计原理&quot;&gt;&lt;/a&gt;删除操作的设计原理&lt;/h5&gt;&lt;p&gt;这里先介绍Doug Lea在源代码注释给出算法设计说明：n.helpDelete(b,f)的设计原理&lt;/p&gt;
&lt;p&gt;上一篇文章的doGet、doPut方法中都有涉及到遇到被标记”删除“的节点时都会加入&lt;code&gt;n.helpDelete(b,f)&lt;/code&gt;的处理逻辑，&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* In addition to using deletion markers, the lists also use&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* nullness of value fields to indicate deletion, in a style&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* similar to typical lazy-deletion schemes.  If a node&amp;#x27;s value is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* null, then it is considered logically deleted and ignored even&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* though it is still reachable. This maintains proper control of&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* concurrent replace vs delete operations -- an attempted replace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* must fail if a delete beat it by nulling field, and a delete&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* must return the last non-null value held in the field. (Note:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Null, rather than some special marker, is used for value fields&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* here because it just so happens to mesh with the Map API&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* requirement that method get returns null if there is no&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* mapping, which allows nodes to remain concurrently readable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* even when deleted. Using any other marker value here would be&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* messy at best.)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* n是当前要删除的节点，b是n的前驱节点，f是n的后继节点，开始删除前，(b,n,f)的指向关系如下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Here&amp;#x27;s the sequence of events for a deletion of node n with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* predecessor b and successor f, initially:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+       +------+      +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   ...  |   b  |------&amp;gt;|   n  |-----&amp;gt;|   f  | ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+       +------+      +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 1. CAS n&amp;#x27;s value field from non-null to null.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    From this point on, no public operations encountering&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    the node consider this mapping to exist. However, other&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    ongoing insertions and deletions might still modify&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    n&amp;#x27;s next pointer.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 1、 将删除节点n的value使用cas设成null，表示此刻起，n节点处于待删除状态，虽然其value为null，对于public相关方法如get等，在执行遇到此类型节点时不会将该节点视为有效节点（也即会被跳过处理），但是如果对于正在执行的插入和删除操作的方法来说，可能也可以去更改“此待删除节点n”的后继节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 2. CAS n&amp;#x27;s next pointer to point to a new marker node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    From this point on, no other nodes can be appended to n.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    which avoids deletion errors in CAS-based linked lists.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+       +------+      +------+       +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   ...  |   b  |------&amp;gt;|   n  |-----&amp;gt;|marker|------&amp;gt;|   f  | ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+       +------+      +------+       +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 2、使用cas将n节点的next字段指向一个marker节点后，从此刻起，任何节点都不会被放在n的后继节点位置，也即不可能出现n-&amp;gt;n1、n-&amp;gt;n2等，只有n-&amp;gt;marker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 3. CAS b&amp;#x27;s next pointer over both n and its marker.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    From this point on, no new traversals will encounter n,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*    and it can eventually be GCed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+                                    +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   ...  |   b  |-----------------------------------&amp;gt;|   f  | ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*        +------+                                    +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 3、通过cas将b的next指针（越过n节点以及n的后继marker节点）指向f节点，从此刻起，n节点不会被相关操作遍历到，n最终会被GC。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出CSM删除操作方面，借用marker节点来实现，将待删除节点的value设为null值来表示该节点处在删除状态但还未真正删除，这种设计风格就像“惰性删除语义(lazy-deletion schemes)”，先标记删，等某个时机再真正执行之。如果CSM的一个节点的value是null，说明该节点在逻辑上已经被删除。&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）</title>
    <link href="https://yield-bytes.github.io/2022/01/07/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84ConcurrentSkipListMap%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://yield-bytes.github.io/2022/01/07/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84ConcurrentSkipListMap%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2022-01-06T16:00:00.000Z</published>
    <updated>2022-05-10T03:35:54.918Z</updated>
    
    <content type="html"><![CDATA[<p>在单线程场景下，HashMap适用于key为无序的键值对存放场景，而TreeMap适用于key为有序的键值对存放场景。</p><p>在高并发场景下，ConcurrentHashMap适用于key为无序的键值对存场景，但对于高并发且要求key有序的场景下，TreeMap非线程安全显然无法满足此场景， 在Concurrent包里面只有跳表：ConcurrentSkipListMap可以满足”基于乐观锁高性能的并发读写、key有序”的需求，而且其设计不会像ConcurrentHashMap这么复杂，但确有着恰当的应用场景，例如对于时序流式数据的存放（最近比较热门的物联网大数据引擎TDengine），可以将乱序的记录以时间戳作为key插入到跳表中，跳表内部处理插入时会比较key的hash值大小以找到节点合适的插入位置，那么在读取时跳表返回的记录就是有序了。</p><p>jdk1.8的ConcurrentSkipListMap在本文简写为CSM，Dung Lea在源代码开头的注释详细介绍了CSM总体设计思路并给出字符型展示的CSM结构图，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* Head nodes          Index nodes</span><br><span class="line">* +-+    right        +-+                      +-+</span><br><span class="line">* |<span class="number">2</span>|----------------&gt;| |---------------------&gt;| |-&gt;<span class="keyword">null</span></span><br><span class="line">* +-+                 +-+                      +-+</span><br><span class="line">*  | down              |                        |</span><br><span class="line">*  v                   v                        v</span><br><span class="line">* +-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">* |<span class="number">1</span>|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;<span class="keyword">null</span></span><br><span class="line">* +-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">*  v              |    |         |              |         |</span><br><span class="line">* Nodes  next     v    v         v              v         v</span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br><span class="line">* | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;<span class="keyword">null</span></span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br></pre></td></tr></table></figure><p>CSM源代码解析文章说明：由于CSM解析内容较多，因此全文分为“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）”和“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（下）”两篇文章<br>上篇关注的重点：CSM数据结构设计原理、doGet、doPut核心方法解析<br>下篇关注的中断：doRemove核心方法解析、总结</p><p><img src="https://img-blog.csdnimg.cn/0eb498c68cbb4bf1999927e150db78b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>《gitee 博客文章封面》</p><a id="more"></a><h4 id="CSM的基本用法"><a href="#CSM的基本用法" class="headerlink" title="CSM的基本用法"></a>CSM的基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ConcurrentHashMap&lt;String,Integer&gt; sm= new ConcurrentHashMap&lt;&gt;();     </span></span><br><span class="line">        ConcurrentSkipListMap&lt;String,Integer&gt; sm=<span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">        List&lt;Thread&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    sm.put(Thread.currentThread().getName(),(<span class="keyword">int</span>)Thread.currentThread().getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">           thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list) &#123;</span><br><span class="line">           thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CHM输出的结果为无序结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Thread-3&#x3D;12, Thread-4&#x3D;13, Thread-5&#x3D;14, Thread-6&#x3D;15, Thread-7&#x3D;16, Thread-8&#x3D;17, Thread-9&#x3D;18, Thread-0&#x3D;9, Thread-1&#x3D;10, Thread-2&#x3D;11&#125;</span><br></pre></td></tr></table></figure><p>使用CSM输出的结果为有序结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Thread-0&#x3D;9, Thread-1&#x3D;10, Thread-2&#x3D;11, Thread-3&#x3D;12, Thread-4&#x3D;13, Thread-5&#x3D;14, Thread-6&#x3D;15, Thread-7&#x3D;16, Thread-8&#x3D;17, Thread-9&#x3D;18&#125;</span><br></pre></td></tr></table></figure><h4 id="CSM-数据结构图"><a href="#CSM-数据结构图" class="headerlink" title="CSM 数据结构图"></a>CSM 数据结构图</h4><p><img src="https://img-blog.csdnimg.cn/0933286e19b245f29e6f9067fedf6ae2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>这个跳表结构有四层，其中base-level层是完整的数据节点链表，在base-level层上面的三层都是索引节点构成的索引链，从图中可以直观看到：上层的索引链表是下层索引链表的“快车道”</p><p>从这种图也可以总结出跳表（这里是泛指跳表结构不是指Java的CSM）的基本特征：</p><ul><li>由最底层的完整数据节点链表层+上面的多层索引层组成。</li><li>每一层都是一个有序的链表</li><li>如果一个key出现在第n层中，则它在最底层以及1到第n-1层也都会出现</li></ul><p>而对于jdk1.8实现的功能完整的ConcurrentSikpListMap，可按上面的结构图进行简单说明各个元素的构成（最底层到最顶层）：</p><ul><li><p>Node节点：存放数据的节点，只在最底层的数据层链表出现，在插入操作时，可能会被随机算法选中上升为“index索引节点”</p></li><li><p>base-level：指代数据层链表的位置，此层存放的是完整数据节点链表，该层的所有节点都是Node类型，不含有Index类型节点！</p></li><li><p>BASE_HEADER：这个节点不是数据层链表的第一个数据节点，它是辅助节点，可以看做是数据层链表的“索引节点”，但它是Node类型：<code>new Node&lt;K,V&gt;(null, BASE_HEADER, null)</code></p></li><li><p>Index节点：位于索引层的节点，采用随机算法把它插入在数据层上方的索引层链表上。</p></li><li>HeadIndex节点：作为辅助节点，非数据节点，是当前索引层链表的头节点，它也会指向下一层index节点索引链表的头节点。Dung Lea称它是dummy node</li><li>level：索引节点所在层序号，从level=1开始计数，最高不超过31（含31层），文章后面给出了计算解释。</li><li>right指针：HeadIndex、Index节点专有字段，可以使得遍历链表的方向向右移动</li><li>down指针：HeadIndex、Index节点专有字段，可以使得遍历链表的方向向下移动</li><li>head节点：所有线程的读写操作都是这个头节点开始作为遍历入口，就像“迷宫的入口点，然后根据向右边还是向下移动，直到走到适合索引节点位置”，它指向最顶层索引层的HeadIndex节点。</li><li>node指针：此指针最特殊！！ 因为每个数据节点，它垂直上方的所有索引节点的node指针都指向数据节点本身，<code>new Index&lt;K,V&gt;(node=新插入的数据节点,down=下一层索引节点, right=当前索引节点的后继索引节点)</code>，注意到上图结构图中，level=1层的索引节点与base-level数据层的数据节点之间不是通过down指针连接的，而是通过node指针连接的，这点务必在后面源码分析反复想起，否则理解错了CSM结构图，那么就无法正确解析源代码设计。</li></ul><p>还有marker标记型节点，它在删除节点的时机会被使用。</p><h4 id="相关节点的定义："><a href="#相关节点的定义：" class="headerlink" title="相关节点的定义："></a>相关节点的定义：</h4><h5 id="数据节点："><a href="#数据节点：" class="headerlink" title="数据节点："></a>数据节点：</h5><p>Node类除了构造器，还定义了一些基本读写方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** node是数据节点，内部存放了key和value，node节点能构成有序链表</span></span><br><span class="line"><span class="comment"> * Nodes hold keys and values, and are singly linked in sorted</span></span><br><span class="line"><span class="comment"> * order, possibly with some intervening marker nodes. The list is</span></span><br><span class="line"><span class="comment"> * headed by a dummy node accessible as head.node. The value field</span></span><br><span class="line"><span class="comment"> * is declared only as Object because it takes special non-V</span></span><br><span class="line"><span class="comment"> * values for marker and header nodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// 注意final修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> Object value;  <span class="comment">// 注意volatile修饰，因为cas会操作它</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;<span class="comment">// 注意volatile修饰，因为cas会操作它</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于创建正常的数据节点，可以看到它没有right字段和down字段，因为它就是位于底层的数据链表中，是最熟悉链表普通节点</span></span><br><span class="line"><span class="comment">     * Creates a new regular node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new marker node. A marker is distinguished by</span></span><br><span class="line"><span class="comment">     * having its value field point to itself.  Marker nodes also</span></span><br><span class="line"><span class="comment">     * have null keys, a fact that is exploited in a few places,</span></span><br><span class="line"><span class="comment">     * but this doesn&#x27;t distinguish markers from the base-level</span></span><br><span class="line"><span class="comment">     * header node (head.node), which also has a null key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 使用Node类型创建marker节点（在删除操作会被使用），和数据节点的区别：无key，且value指向自己。</span></span><br><span class="line">    Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用cas更改当前节点value的值</span></span><br><span class="line"><span class="comment">     * compareAndSet value field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用cas更改当前节点的next指向</span></span><br><span class="line"><span class="comment">     * compareAndSet next field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this node is a marker. This method isn&#x27;t</span></span><br><span class="line"><span class="comment">     * actually called in any current code checking for markers</span></span><br><span class="line"><span class="comment">     * because callers will have already read value field and need</span></span><br><span class="line"><span class="comment">     * to use that read (not another done here) and so directly</span></span><br><span class="line"><span class="comment">     * test if value points to node.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if this node is a marker node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">//因为HeadIndex的key也null，因此使用value==this才能唯一区别出这是marker节点</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isMarker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于判断node节点是否就是base-level的HeadIndex节点</span></span><br><span class="line"><span class="comment">     * Returns true if this node is the header of base-level list.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if this node is header node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBaseHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == BASE_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用cas将一个marker节点放在当前节点的后面,其中f节点是当前节点的后继节点</span></span><br><span class="line"><span class="comment">    将：</span></span><br><span class="line"><span class="comment">    node-&gt;f-&gt;...</span></span><br><span class="line"><span class="comment">    变成：</span></span><br><span class="line"><span class="comment">    node-&gt;marker-&gt;f-&gt;...</span></span><br><span class="line"><span class="comment">     * Tries to append a deletion marker to this node.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f the assumed current successor of this node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">appendMarker</span><span class="params">(Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前节点通过添加marker节点来帮助删除操作或者用于将当前节点脱离前驱节点。</span></span><br><span class="line"><span class="comment">     * Helps out a deletion by appending marker or unlinking from</span></span><br><span class="line"><span class="comment">     * predecessor. This is called during traversals when value</span></span><br><span class="line"><span class="comment">     * field seen to be null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b predecessor  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f successor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 如果在这里不能理解其含义，可在后面的删除操作中关于(b,n,f)三个节点调整解析中得到回答。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Rechecking links and then doing only one of the</span></span><br><span class="line"><span class="comment">         * help-out stages per call tends to minimize CAS</span></span><br><span class="line"><span class="comment">         * interference among helping threads.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回数据节点key对应的value，如果当前节点value字段指向自己说明是一个mark节点，则返回null，如果当前节点value字段BASE_HEADER，说明是底层的HeadIndex节点也是返回null</span></span><br><span class="line"><span class="comment">     * Returns value if this node contains a valid key-value pair,</span></span><br><span class="line"><span class="comment">     * else null.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> this node&#x27;s value if it isn&#x27;t a marker or header or</span></span><br><span class="line"><span class="comment">     * is deleted, else null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">getValidValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object v = value;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == BASE_HEADER)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="索引节点Index"><a href="#索引节点Index" class="headerlink" title="索引节点Index"></a>索引节点Index</h5><p>Index节点位于“快车道——索引层链表”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/* ---------------- Indexing -------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Index nodes represent the levels of the skip list.  Note that</span></span><br><span class="line"><span class="comment">   * even though both Nodes and Indexes have forward-pointing</span></span><br><span class="line"><span class="comment">   * fields, they have different types and are handled in different</span></span><br><span class="line"><span class="comment">   * ways, that can&#x27;t nicely be captured by placing field in a</span></span><br><span class="line"><span class="comment">   * shared abstract class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 可以看到Index索引节点的下一个节点指针不是next字段而是right字段，但他们作用都是指向后继节点，取用不同的名称是为了区别Node的next字段、方便理解和阅读。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*  相关指针的局部指向示意图：</span></span><br><span class="line"><span class="comment">          this → right → indexNode  → indexNode → null  </span></span><br><span class="line"><span class="comment">          ↓</span></span><br><span class="line"><span class="comment">          down (Index&lt;K,V&gt;类型)</span></span><br><span class="line"><span class="comment">          ↓</span></span><br><span class="line"><span class="comment">          node (最底层的数据节点)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;K,V&gt; node;  <span class="comment">//索引节点在垂直方向上指向的最底层的对应数据节点，Node类型</span></span><br><span class="line">      <span class="keyword">final</span> Index&lt;K,V&gt; down; <span class="comment">//注意 down指针是Index索引节点类型，不是数据节点Node类型</span></span><br><span class="line">      <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//注意 right指针是Index索引节点类型，不是数据节点类型</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Creates index node with given values.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="comment">// Index位于索引层的链表，那么它的down字段指向下层的Index节点（或者最底层的node数据节点），right字段指向后继索引节点</span></span><br><span class="line">      Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">          <span class="keyword">this</span>.node = node;</span><br><span class="line">          <span class="keyword">this</span>.down = down;</span><br><span class="line">          <span class="keyword">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 使用cas设置Index节点的right节点：在插入操作和删除操作使用</span></span><br><span class="line"><span class="comment">       * compareAndSet right field</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Returns true if the node this indexes has been deleted.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> true if indexed node is known to be deleted</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      参考后文</span></span><br><span class="line"><span class="comment">       * Tries to CAS newSucc as successor.  To minimize races with</span></span><br><span class="line"><span class="comment">       * unlink that may lose this index node, if the node being</span></span><br><span class="line"><span class="comment">       * indexed is known to be deleted, it doesn&#x27;t try to link in.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> succ the expected current successor</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> newSucc the new successor</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">          Node&lt;K,V&gt; n = node;</span><br><span class="line">          newSucc.right = succ;</span><br><span class="line">          <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      参考后文</span></span><br><span class="line"><span class="comment">       * Tries to CAS right field to skip over apparent successor</span></span><br><span class="line"><span class="comment">       * succ.  Fails (forcing a retraversal by caller) if this node</span></span><br><span class="line"><span class="comment">       * is known to be deleted.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> succ the expected current successor</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Unsafe mechanics，Index类内部的Unsafe实例创建</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">              Class&lt;?&gt; k = Index.class;</span><br><span class="line">              rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                  (k.getDeclaredField(<span class="string">&quot;right&quot;</span>));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="HeadIndex节点"><a href="#HeadIndex节点" class="headerlink" title="HeadIndex节点"></a>HeadIndex节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Head nodes -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  从结构图也可以看出：该层HeadIndex的right指针指向的就是该层链表的头节点，down指针指向下一层的HeadIndex节点，关键的level属性：表示该层的序号，最小值是1，也即第一层</span></span><br><span class="line"><span class="comment"> * Nodes heading each level keep track of their level.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(node, down, right);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法解析"><a href="#get方法解析" class="headerlink" title="get方法解析"></a>get方法解析</h4><p>有了以上基本数据结构说明后，理解查找节点的过程来进一步解析CSM核心设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> doGet(key); <span class="comment">// get方法内部封装的私有的doGet方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGet总体思路：使用comparator比较器，先找到key对于的前驱节点b，此刻起，有(b,n,f)三个节点关系（b:当前节点n的前驱节点，f:当前节点n的后继节点），这三个指针非常重要，要想读到准确n节点的value，显然在第一次读到(b,n,f)时，还需要再次检查b节点、n节点有无被其他线程修改或者删除，确保前后两次读一致，才可以正常地把key和n节点进行比较，若key==n.key，则可查询到key对应的值。</p><p>b节点：给定key的前驱节点，一般有b.key&lt;key；n节点：要与key作为比较，f节点：n节点后驱节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">  <span class="comment">/* 外层循环的outer非常有用：若当前读线程在内部循环找到(b,n,f)且准备读取数据节点n，有其他写线程（如删除操作）抢先一步将正常的数据n节点标记为marker或者更改了n节点，那么就需要要求当前读线程重新跳回外层循环再次定位(b,n,f)这个三个特殊节点，或者说：如果在内层循环，当前线程前后读取的(b,n,f)三个节点中的b节点、n节点有出现不一致读，则需要再次遍历，直到前后读取的(b,n,f)中的b、n都未改动时，返回的value才是key对应的value。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// ① 在内循环开始时，找到给定key的前驱节点b，以及b节点的next节点：n节点，b节点key一定是小于给定的key，否则b节点就不是给定key的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c; <span class="comment">// c是comparator的比较结果，0，小于0，大于0</span></span><br><span class="line">          <span class="comment">//② 来到数据层链表的尾部位置如： b → null，因此n指向null，说明key未能在数据层链表找到，可直接返回。</span></span><br><span class="line">          <span class="comment">// 这里也对应下面③b=n;n=f后移操作，也是作为外层循环首要考虑的程序出口条件。</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer; <span class="comment">// 注意：break outer是指结束结束外层循环来到return null语句</span></span><br><span class="line">          <span class="comment">// n节点的后继节点为f节点</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">          <span class="comment">// 当前时刻n节点已经不是b节点的后继节点，说明n节点被其他线程改过(前、后不一致性读)，那么当前线程回到内层for循环① 位置继续下一轮重试。</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 若线程执行到这里发现n节点value变为null，说明n节点被标记为“删除”，当前线程进入helpDelete帮助删除n节点，然后回到内层for循环①位置继续下一轮重试。</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 若线程执行到这里发现b节点value变为null，此时说明前驱节点b被其他线程删除，或者n节点被其他线程标记为marker节点，当前线程只能回到内层for循环①位置继续下一轮重试。</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 代码执行到这里说明b节点和n节点前后两次读取一致，那么可以开始比较key和n.key,若相等，n节点就是要找的key对应的节点，返回其value即可</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// b节点已经是给定key的前驱节点，有：b.key&lt;key,若c&lt;0,说明key&lt;n.key,因为b节点和n节点之间已经没有节点，既然key对应的不是b节点也不是n节点，说明key节点不在跳表里面，那么当前读线程只能跳出外层循环并结束读取操作，返回null。</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">          <span class="comment">//③ 代码执行到这里，说明要查找的key大于n节点的key，所以要继续向当前链表右边方向遍历，b和n指针同时向右边移动一个节点位置的指向，可以想象：当b来到链表尾部最后一个节点时，此时n=b.next=null 回到for循环就会进入②位置的分支：满足if (n == null)，然后break outer退出外层循环后return null</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGet方法的设计整体相对清晰，最关键的一个点是如何找到key的前驱节点b？通过findPredecessor实现。</p><h5 id="findPredecessor方法实现："><a href="#findPredecessor方法实现：" class="headerlink" title="findPredecessor方法实现："></a>findPredecessor方法实现：</h5><p>此方法有两个功能：</p><p>功能 1：找到给定key对应的前驱节点node</p><p>功能2：also unlinks indexes to deleted nodes found along the way，此功能具体分析放在后文的doRemove方法，在本小节中只需关注功能1即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* ---------------- Traversal -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a base-level node with key strictly less than given key,</span></span><br><span class="line"><span class="comment">     * or the base-level header if there is no such node.  Also</span></span><br><span class="line"><span class="comment">     * unlinks indexes to deleted nodes found along the way.  Callers</span></span><br><span class="line"><span class="comment">     * rely on this side-effect of clearing indices to deleted nodes.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predecessor of key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don&#x27;t postpone errors</span></span><br><span class="line">      <span class="comment">// 两层循环，若当前线程在遍历索引节点过程中，当前遍历节点被修改，说明读不一致，那么当前线程必须回到外层循环重新遍历</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            注意q、r、d的指向方向，如下所示</span></span><br><span class="line"><span class="comment">            q → r → indexNode  → indexNode → null  </span></span><br><span class="line"><span class="comment">            ↓</span></span><br><span class="line"><span class="comment">            d</span></span><br><span class="line"><span class="comment">            先将q指向head节点，那么r和d自然就出来了，如下所示</span></span><br><span class="line"><span class="comment">            q(head) → r (q.right) → indexNode  → indexNode → null  </span></span><br><span class="line"><span class="comment">            ↓</span></span><br><span class="line"><span class="comment">            d(q.down)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">          <span class="comment">// 这里很关键：q、r、d三个指针都是Index索引节点类型，说明findPredecessor方法只会在索引层去找key的前驱节点，而不会去到最底层的数据节点链表去找。</span></span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">              <span class="comment">//①分支：从上面的q、r位置关系可知，q、r都在同一层索引层移动，如果r节点不为空，说明可以继续向右遍历索引链表，若r来到索引链表尾部null位置，那么执行流跳过①分支来到④分支</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//取出索引节点指向的数据节点node，此节点的key将和给定key比较</span></span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    K k = n.key;</span><br><span class="line">                   <span class="comment">/*② 此分支建议深度理解了doRemove方法后，再回来理解它则简单很多。</span></span><br><span class="line"><span class="comment">                  在remove方法中有其他写线程使用n.casValue(v, null)将目标删除节点n的value字段设为null，因此只要读线程进入此分支，说明r索引节点指向的数据节点node已经被其他写线程标记为删除状态，此时要将q节点和r节点断开链接，也即将q → r → r.right 变成q → r.right</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;           <span class="comment">// 若unlink内部的cas失败，则继续重试</span></span><br><span class="line">                      <span class="comment">// 如果上面unlink成功，旧r节点断开q节点，此时重新读取q的right节点，然后继续下一轮循环。</span></span><br><span class="line">                        r = q.right;         <span class="comment">// reread r</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">//③分支：给定的key比r.key大，说明只好向右继续查找：q、r指针同时右边移动一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/*④分支：findPredecessor结束点：找到了key的前驱节点。注意这里q已经是第一层的目标索引节点，q.down指向null，q.node指向数据节点node，所以不要误解为q.down指向node，而node不为空，参考后面图文解释！</span></span><br><span class="line"><span class="comment">            q (索引层leve=1的索引节点) </span></span><br><span class="line"><span class="comment">            ↓</span></span><br><span class="line"><span class="comment">            d (最底层数据节点)，显然此时d是Node节点类型，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.node;</span><br><span class="line">              <span class="comment">//⑤分支：遍历到当前索引层链表尾部r=null也没找到key的前驱节点，那么只能垂直在向下移动，在下一层索引层的链表头部继续重复以上逻辑。务必记住：此“向下移动一层”的操作只在索引层操作，不会“下移到数据链表层”！</span></span><br><span class="line">                q = d;</span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>q.unlink(r))</code>的定义：</p><p>unlink方法是Index索引节点内部方法，设计目的是：当Index.node指向的数据节点已经被标记删除，那么此Index节点也需要被删除，假设r是当前处理索引节点：</p><p>将q → r → r.right 变成q → r.right，对应到unlink的相关变量则为：</p><p>将q → succ → succ.right 变成q → succ.right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Tries to CAS right field to skip over apparent successor</span></span><br><span class="line"><span class="comment"> 若调用此方法时，q恰好被标记为删除状态，那么cas会失败，要求unlink调用者再次循环重试，这就是findPredecessor方法里面的②分支设计为重试的原因。 </span></span><br><span class="line"><span class="comment"> * succ.  Fails (forcing a retraversal by caller) if this node</span></span><br><span class="line"><span class="comment"> * is known to be deleted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ the expected current successor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里node.value是指q.node.value，不是r.node.value！要求q指向的数据节点node还没被删除才能进行cas</span></span><br><span class="line">    <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findPredecessor方法最关键的一个设计点——返回逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*④分支：findPredecessor结束点：找到了key的前驱节点</span></span><br><span class="line"><span class="comment">            q (索引层leve=1的索引节点) </span></span><br><span class="line"><span class="comment">            ↓</span></span><br><span class="line"><span class="comment">            d (最底层数据节点)，显然此时d是Node节点类型，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.node;</span><br></pre></td></tr></table></figure><p>以上代码很容易让人产生错误理解（如果提前理解了doPut方法中idx插入索引节点的设计，则能正确理解④分支的设计逻辑），具体说明人下面两张图所示</p><p>正确的理解：<br><img src="https://img-blog.csdnimg.cn/65f7be0bca5246dfa5f518aa5a4898a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>错误的理解：</p><p><img src="https://img-blog.csdnimg.cn/7f2a17ac64e2460386eb38952646841e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>虽然在前面CSM的数据结构图中 level=1的索引层节点画的图是直接指向下方数据层节点，但必须要清楚在真正的CSM设计中，是不存在这个down指向关系，你可以理解是第一层索引节点通过q.node指针实现指向最底层的数据节点。</p><h5 id="图示doGet方法查找图"><a href="#图示doGet方法查找图" class="headerlink" title="图示doGet方法查找图"></a>图示doGet方法查找图</h5><p>分为两步理解：<br><img src="https://img-blog.csdnimg.cn/0eb498c68cbb4bf1999927e150db78b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>doGet方法和findPredecessor的执行流程能够让你理解了CSM，但要想深入掌握它，还得从put方法和remove方法中找到答案</p><h4 id="put方法解析"><a href="#put方法解析" class="headerlink" title="put方法解析"></a>put方法解析</h4><p>Main insertion method. Adds element if not present, or replaces value if present and onlyIfAbsent is false.</p><p>如果key不在csm中可插入key，onlyIfAbsent默认为false，表示如果该key已经在csm中，则替换旧value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doPut的主要设计思路：</p><p>1、找到合适位置插入key节点</p><ul><li><p>1.1 找到key在数据层链表中前驱节点b（这个逻辑在doGet已经解析过），并给出(b,n,f)这三个指针的指向</p></li><li><p>1.2 将新插入的节点z用cas设置到b的next中，也即将节点z插入到 b → n，也即变成  b → z → n </p></li></ul><p>2、通过随机算法来决定是否要在新插入的节点z上（垂直方向上）构建索引节点（若层数n，就构建n个索引节点），</p><p>3、将这些索引节点在各自的索引层链接好左右关系指向。</p><p>建议先用单线程的角度去理解doPut主体逻辑，也即假设b节点、n节点不会被其他写线程删除或者更改，这样可以快速理解doPut设计逻辑。</p><h5 id="doPut方法第一部分："><a href="#doPut方法第一部分：" class="headerlink" title="doPut方法第一部分："></a>doPut方法第一部分：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 注意：以下内层循环所有逻辑（除了findPredecessor）只发生在最底层的数据链表层中进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">          <span class="comment">// 1.1 若不是在数据链表尾部，则可以继续遍历，否则也即来到链表尾部就跳到1.2分支</span></span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">              <span class="comment">// f暂存n节点之后子链，用于后续遍历</span></span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">              <span class="comment">//1.1.1 单线程情况下，n还是b的next节点，若高并发写情况下，n节点可能被其他线程更改，那么当前线程第一次读取的b.next和现在读取的b.next显然不一致，也即“inconsistent read”</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//1.1.2 n的值为null，说明被其他线程标记位删除状态，只能先去helpDelete，然后再回到内层循环重试。</span></span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//1.1.3 前驱节点b被删除或者n节点value是指向自己（说明n是一个mark节点），前驱节点都被其他线程删除，只能退出本轮回到内层for循环继续重试。</span></span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//1.1.4 给定的key比n节点还大，那么只能继续向右比较</span></span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 更新b、n指针向后移动一步</span></span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//1.1.5 如果key==n.key,说明已找到该key。</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">/* 1.2</span></span><br><span class="line"><span class="comment">          第一种情况：根据1.1 n不为空，那么在 b → n 之间插入  b → z → n </span></span><br><span class="line"><span class="comment">          第二种情况：如果1.1 的n节点为空说明来到链表尾部，也即b前驱节点后面就是null，那么b → null 变成b → z → null</span></span><br><span class="line"><span class="comment">           */</span>   </span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);  <span class="comment">//创建key这个插入节点，然后有 z → n </span></span><br><span class="line">          <span class="comment">// 1.3 </span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z)) <span class="comment">// cas: 在n节点前、后时刻读一致性时，z节点才能成功CAS插入b前驱节点后面</span></span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b若cas失败，只能回到内循环重试</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="doput方法第二部分："><a href="#doput方法第二部分：" class="headerlink" title="doput方法第二部分："></a>doput方法第二部分：</h5><p>在第一部分逻辑插入号z节点后，那么接下里就得考虑z节点垂直方向是否需要创建索引层节点。</p><p>如何决定是否需要？ 当然是根据随机数算法满足test条件来决定是否需要执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/* 这里随机数的生成考虑很细致：ThreadLocalRandom.nextInt也可以实现线程自己本地随机数，而nextSecondarySeed能做到生成和“当前线程业务代码调用的ThreadLocalRandom.nextInt”不冲突的随机数。</span></span><br><span class="line"><span class="comment">     * To produce random values without interference across threads,</span></span><br><span class="line"><span class="comment">     * we use within-JDK thread local random support (via the</span></span><br><span class="line"><span class="comment">     * &quot;secondary seed&quot;, to avoid interference with user-level</span></span><br><span class="line"><span class="comment">     * ThreadLocalRandom.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x80000001是16进制数：1000 0000 0000 0000 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment">考察rnd &amp; 0x80000001 == 0成立时rnd的取值特征：</span></span><br><span class="line"><span class="comment">0nnn nnnn nnnn nnnn nnnn nnnn nnnn nnn0</span></span><br><span class="line"><span class="comment">其中，n表示0或者1，其实就是表达rnd只要是偶数就可使得测试条件通过，所以概率为50%。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">            <span class="comment">/* 1、根据rnd的比特位值为1的特征先计算一个“level值”，</span></span><br><span class="line"><span class="comment">            例如0nnn nnnn nnnn nnnn nnnn nnnn nnnn nnn0，30个n全部为1，那么</span></span><br><span class="line"><span class="comment">            level=1+30=31，计算出31层，是否就是真的要在跳表上加31层索引节点呢？ 显然没那么简单，具体看第2点逻辑</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                ++level;</span><br><span class="line">          <span class="comment">// 这一句非常关键：第一层的索引节点Index，它的down指向idx=null，而不是指向其下方的node数据节点。 </span></span><br><span class="line">            Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head; <span class="comment">// head指向的是最顶层的HeadIndex节点，不是最底层的数据链表头节点</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          2、如果计算的level未超过现有索引层数，那么好处理：在z节点上方建立level个索引节点</span></span><br><span class="line"><span class="comment">          例如，假设当前h.level=3，也即有三层索引层，rnd=2,那么level计算结果为2，因此根据以下逻辑，</span></span><br><span class="line"><span class="comment">          在z节点垂直上方创建2个index节点,且每个index的right还是null，换句话说，这些索引节点还未与其所在层的前后索引节点建立指向关系，如下：</span></span><br><span class="line"><span class="comment">          index2</span></span><br><span class="line"><span class="comment">          ↓</span></span><br><span class="line"><span class="comment">          index1</span></span><br><span class="line"><span class="comment">          |</span></span><br><span class="line"><span class="comment">          z</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                    idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>); </span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3、如果level&gt;现有层数，例如level计算值为7，现有层数为3，那么也只能给它加一层，而不是加（7-3）层，</span></span><br><span class="line"><span class="comment">          以下max按3作为案例说明</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level </span></span><br><span class="line">              <span class="comment">// level=3+1=4</span></span><br><span class="line">                level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">              <span class="comment">// 存放要添加的索引节点数组，level为4，那么idxs容量为5</span></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                    (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>]; </span><br><span class="line">              <span class="comment">// 注意：这里从idxs的下标1开始放入idx索引节点，idxs[0]不参与实际逻辑。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                  <span class="comment">/* 跟上面2部分类似，但它这里每次创建好的节点放到idxs数组中，方便后面新创建HeadIndex使用：</span></span><br><span class="line"><span class="comment">                   newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                    idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">              <span class="comment">// 3.1 </span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    h = head;</span><br><span class="line">                  <span class="comment">// 根据3的假设，原来由3层索引层</span></span><br><span class="line">                    <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                  <span class="comment">// 假设当前时刻仅有当前线程添加索引层，那么4&lt;=3，不需要重试。</span></span><br><span class="line">                    <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level:有其他插入线程抢先一步升高了索引层，当前线程只能下一轮重试,因此在3.1使用了for循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                  <span class="comment">// 3.2 </span></span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                  <span class="comment">// 创建新添加的索引层的头节点，新增多少层，就添加多少个头节点，</span></span><br><span class="line">                  <span class="comment">// 由于oldLevel=3，level=4,因此以下计算后只在第4层添加一个HeadIndex，并且该HeadIndex的四个字段都有了指向关系。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                        newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j); <span class="comment">// 这就是为何前面需要创建idxs数组的原因。</span></span><br><span class="line">                  <span class="comment">// 3.3 将跳表头节点Head指向新添加的HeadIndex</span></span><br><span class="line">                    <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                        h = newh;</span><br><span class="line">                      <span class="comment">// 这里level = oldLevel=3，也即将idx指向第3层新增索引节点，为何不是第4层新增的索引节点呢？因为在3.2中，在第4层新增的HeadIndex节点已经将right指针指向对应新增的索引节点。因此之后要处理的索引节点是从旧level层数开始处理down、right指向关系</span></span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第2部分的逻辑对应下图：</p><p>根据key计算的level未超过现有索引层数3时的逻辑图<br><img src="https://img-blog.csdnimg.cn/0bbafd8d861a46d08af5e813c9a13562.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>第3部分的逻辑对应下图：</p><p>根据key计算的level超过现有索引层数3时的逻辑图，不管是计算level=4大于level=3还是其他比3值更大，也只能增加一层索引层：level = max + 1<br><img src="https://img-blog.csdnimg.cn/aa0ae26faa314d75bec56d81b08fd0ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>在新增加的level=4的索引层，需要添加一个新的HeadIndex节点，根据以下逻辑可知：新增的HeadIndex节点已经将right指针指向对应新增的索引节点，如图位置1所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(old base, newh, idxs[j], j);</span><br></pre></td></tr></table></figure><h5 id="doput方法第三部分："><a href="#doput方法第三部分：" class="headerlink" title="doput方法第三部分："></a>doput方法第三部分：</h5><p>在doput方法第二部分完成新插入数据节点z对应的多层索引节点创建，但索引节点idx还未与前后已有节点建立指向关系，因此接下里代码逻辑中负责完成此事。</p><p>为了能具体化分析以下逻辑，不妨假设插入z节点后，计算出的level=4高于当前跳表oldLevel=3，根据上面3.3的逻辑可知，此时h执行第4层的headIndex，根据<code>idx = idxs[level = oldLevel]</code> ，有idx指针指向第3层的待处理索引节点idx，level=oldLevel=3，根据这些变量代入以下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find insertion points and splice in.</span></span><br><span class="line"><span class="comment">// splice in 是指拼接的意思，也即将idx加入所在层的链表关系中</span></span><br><span class="line"><span class="comment">//insertionLevel = level =3，</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">          <span class="comment">// 关于insertionLevel的理解，结合上图可知，insertionLevel=3，说明第3层idx加入此层索引层链表中，也称为待插入层。</span></span><br><span class="line">            <span class="keyword">int</span> j = h.level; <span class="comment">// 这个j表征执行流走向第几层（也称为当前处理层），h.level的值为4</span></span><br><span class="line">          <span class="comment">// 类似doGet方法，从顶层的左上方head位置开始遍历而且只在索引层去检索，目的是把每个需要insertionLevel层的idx节点t链入q → r之间，变成：q → t → r 。注意：t的方向是从高层idx向低层的idx移动指向，idx：新增加的索引阶段</span></span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">              <span class="comment">//3.1 两种情况可以说明idx链入工作完成：条件1：说明q来到当前索引层的链表末尾位置，q会指向null 2、当t指向null时，垂直方向多个idx节点全部链入对应索引层。</span></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">              <span class="comment">//3.2 对于q → r → r.right...情况，r不是null时，也即q不是尾节点时</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// q → r → r.right，也即熟悉的（b,n,f）子链</span></span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key); </span><br><span class="line">                  <span class="comment">// 如果当前索引节点r指向的数据节点n被标记删除，说明索引节点r也需要删除，此时要将q节点和r节点断开链接，也即将q → r → r.right 变成q → r.right。前面findPredecessor方法内部也用到了该unlink方法，此逻辑被称为side-effect！</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))<span class="comment">// q、r断开失败则需要重试</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                      <span class="comment">// 取出q新的右节点继续遍历重试</span></span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// r.key&lt;key,只能在同一层继续向右找到key插入的位置。 </span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             <span class="comment">/*3.3 如果当前处理层指针恰好移动到位于需要对新增索引节点建立前后指向关系的待插入层</span></span><br><span class="line"><span class="comment">              那么将待处理的索引节点 t=idx 链入q → r 之间，变成：q → t → r </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart t=idx 链入失败只能回到循环重试。</span></span><br><span class="line">                    <span class="comment">// 索引节点idx指向的新插入数据节点z已被其他写线程标为删除状态，那么当前线程就不需要给z节点建立垂直方向的索引，相反当前线程利用findNode去帮助把z节点删除，同时findNode里面的findPredecessor方法也会在find过程中沿途清理z节点上方的idxs索引节点，这就是findNode的“side-effect” 思想：去删除数据节点z的同时顺便沿途把与z对应新建的索引节点idxs都删除了</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 如果q.link(r, t)成功，且新插入的数据节点z未被删除，那么当前待插入层insertionLevel已完成，如果insertionLevel自减1等于0，说明insertionLevel指向最底层的数据层，显然数据层不需要处理，说明所有idxs都在各自所在的索引层链表里面，可结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125; <span class="comment">// </span></span><br><span class="line">           </span><br><span class="line">              </span><br><span class="line">         <span class="comment">// 这里的理解相对有点绕：若当前待插入层已经处理完，则t指向下一个层的待处理索引节点idx。什么场景不需要执行 t = t.down呢？当遍历层指针j在一开始就指向新增的最高层时，t此时是指向（最高层-1）的idx，因此只有当遍历层指针j来到当前待插入层insertionLevel且t已经链入该层的q → r之间，说明当前insertionLevel层已处理完，那么t可以移动下一层的idx</span></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">         <span class="comment">// 1、当前遍历层指针j指向最高层时 2、当前遍历层指针j指向当前待插入层insertionLevel且insertionLevel层的t节点已经链入该层的q → r之间。这两个条件都会使得q，r下移一层</span></span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>q.link(r, t)</code> 的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (!q.link(r, t))</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这里的node节点就是索引节点q.node指向的数据节点,succ就是r，newSucc就是t（新增的idx节点）</span></span><br><span class="line">        Node&lt;K,V&gt; n = node; </span><br><span class="line">      <span class="comment">// t.right=r </span></span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">      <span class="comment">/* link能成功的两个条件同时成立：</span></span><br><span class="line"><span class="comment">      1、要求q指向的node数据节点一定不能处于被标记为&quot;删除状态&quot;</span></span><br><span class="line"><span class="comment">      2、q的后继节点r索引节点未被其他写线程标记为&quot;删除状态&quot;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="findNode的作用"><a href="#findNode的作用" class="headerlink" title="findNode的作用"></a>findNode的作用</h5><p>此方法在doPut的“第三部分逻辑：新建的索引链表如何插入到该层链表中”起到关键作用，此外它还被doRemove、computeIfPresent、merge、replace等方法在内部调用，因此需要对其设计逻辑进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// findNode的源代码注释其实写得很清楚，需要看完一下源码再解析</span></span><br><span class="line"><span class="comment">// 以下逻辑一定要带着这样的前提：新插入的z节点被标记删除后，需要对其上方的新建索引节点都一起删除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don&#x27;t postpone errors</span></span><br><span class="line">      Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line"> </span><br><span class="line">      outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//1、找到key在数据层链表的前驱节点b，从b开始向右遍历。这里最关键：findPredecessor，除了找到z节点的前驱节点b，它的额外收益还把沿途找到的z对应的索引节点都删除了</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">              Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//2、 来到链表末尾则可结束</span></span><br><span class="line">              <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                  <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// 又是经典的（b,n,f）三节点指针</span></span><br><span class="line">              Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//3、 n已不是b的后继节点，重试</span></span><br><span class="line">              <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//4、 n被标记为删除状态，则使用helpDelete真正删除n节点，然后重试</span></span><br><span class="line">              <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                  n.helpDelete(b, f);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//5、 b被标记为删除状态，或者b被标记位删除且b.next是一个marker节点，也只能重试</span></span><br><span class="line">              <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//6、 执行到这里：说明n节点就是z节点本身，显然它在已经在4步骤被删除掉，因此可直接返回该n节点，需要注意：返回的n节点只有key不为空，其value是null的。</span></span><br><span class="line">              <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> n;</span><br><span class="line">            <span class="comment">// 说明key原本就不在链表上，可以直接返回。</span></span><br><span class="line">              <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// b、n同时后移一步</span></span><br><span class="line">              b = n;</span><br><span class="line">              n = f;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>“新插入的z节点被标记删除后，需要对其上方的新建索引节点都一起删除”基于这个原因用findNode方法去完成，那么可以这样提问：能否直接调用<code>findPredecessor</code> 删除逻辑呢？如下所示</p><p>findPredecessor是在检索的沿途中会删除那些被标记“删除状态的”索引节点，它只在索引层范围内进行，不会下沉到数据层链表中操作。</p><p>而findNode方法可以进入到数据层链表中，把已经标记为删除状态的数据节点node删除，这个功能是findPredecessor不具备的，同时findNode内部调用findPredecessor方法，完成了额外的索引节点删除功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// findNode(key)</span></span><br><span class="line">    findPredecessor(key, cmp);</span><br><span class="line">    <span class="keyword">break</span> splice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是官方关于findNode方法设计说明及其实现功能：新插入的z节点被标记删除后，需要对其上方的新建索引节点都一起删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">返回一个null（如果给定的key不在数据链表里面）或者一个持有key的node（node的value当然是null）,清除沿途遍历到的所有已标记“node.value&#x3D;null”的数据层节点（注意这里的nodes是数据层链表中的节点，不是指清除索引层节点）</span><br><span class="line">Returns node holding key or null if no such, clearing out any deleted nodes seen along the way.</span><br><span class="line">从key的前驱节点b开始遍历base-level的数据层链表（如有必要则需要重复遍历），向右移动过程中遇到标记位删除的节点就处理它</span><br><span class="line">Repeatedly traverses at base-level looking for key starting at predecessor returned from findPredecessor, processing base-level deletions as encountered. </span><br><span class="line">调用者可以使用findNode方法获得额外收益即沿途过程中能清除被标记为删除状态的数据节点。</span><br><span class="line">Some callers rely on this side-effect of clearing deleted nodes.</span><br><span class="line"></span><br><span class="line">出现以下三种情况之一，都会使得执行流再次回到b节点重新遍历</span><br><span class="line">Restarts occur, at traversal step centered on node n,</span><br><span class="line">（1）考察(b,n,f)三个节点，若n节点已发生改变，不再是b.next执行的原n节点，因此本轮遍历无法处理这种删除操作（cannot unlink），需重试</span><br><span class="line">if: (1) After reading n&#39;s next field, n is no longer assumed predecessor b&#39;s current successor, which means that we don&#39;t have a consistent 3-node snapshot and so cannot unlink any subsequent deleted nodes encountered. </span><br><span class="line"></span><br><span class="line">（2）考察(b,n,f)三个节点，若n.value&#x3D;null，说明n被标记为删除状态，这种情况下，先去n.helpDelete(b, f)删除n节点本身，然后重新遍历</span><br><span class="line">(2) n&#39;s value field is null, indicating n is deleted, in which case we help out an ongoing structural deletion before retrying. Even though there are cases where such unlinking doesn&#39;t require restart, they aren&#39;t sorted out here because doing so would not usually outweigh cost of restarting. </span><br><span class="line"></span><br><span class="line">（3）考察(b,n,f)三个节点，若n是marker节点（说明b被标记）或者b.value&#x3D;null,说明findPredecessor方法返回的是一个被标记删除的数据节点，此时无法正确获得predecessor节点就不能继续执行unlink操作。只能重新回到for循环继续调用findPredecessor，找到新的(b,n,f)</span><br><span class="line">(3) n is a marker or n&#39;s predecessor&#39;s value field is null, indicating (among other possibilities) that findPredecessor returned a deleted node. We can&#39;t unlink the node because we don&#39;t know its predecessor, so rely on another call to findPredecessor to notice and return some earlier predecessor, which it will do. </span><br><span class="line">第3种check只会在循环的开始才会严格执行检查，但每次迭代都会执行此检查，以帮助调用方避免和其他线程发生竞争，如果调用方cas失败，只能retry。</span><br><span class="line">This check is only strictly needed at beginning of loop, (and the b.value check isn&#39;t strictly needed at all) but is done each iteration to help avoid contention with other threads by callers that will fail to be able to change links, and so will retry anyway. </span><br><span class="line"></span><br><span class="line">doPut, doRemove, and findNear方法中loop设计都会有以上三种情况的检查逻辑。findFirst、findLast也有类似的检查逻辑</span><br><span class="line">The traversal loops in doPut, doRemove, and findNear all include the same three kinds of checks. And specialized versions appear in findFirst, and findLast and their variants. They can&#39;t easily share code because each uses the reads of fields held in locals occurring in the orders they were performed.</span><br><span class="line">Params:</span><br><span class="line">key – the key</span><br><span class="line">Returns:</span><br><span class="line">node holding key, or null if no suc</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在单线程场景下，HashMap适用于key为无序的键值对存放场景，而TreeMap适用于key为有序的键值对存放场景。&lt;/p&gt;
&lt;p&gt;在高并发场景下，ConcurrentHashMap适用于key为无序的键值对存场景，但对于高并发且要求key有序的场景下，TreeMap非线程安全显然无法满足此场景， 在Concurrent包里面只有跳表：ConcurrentSkipListMap可以满足”基于乐观锁高性能的并发读写、key有序”的需求，而且其设计不会像ConcurrentHashMap这么复杂，但确有着恰当的应用场景，例如对于时序流式数据的存放（最近比较热门的物联网大数据引擎TDengine），可以将乱序的记录以时间戳作为key插入到跳表中，跳表内部处理插入时会比较key的hash值大小以找到节点合适的插入位置，那么在读取时跳表返回的记录就是有序了。&lt;/p&gt;
&lt;p&gt;jdk1.8的ConcurrentSkipListMap在本文简写为CSM，Dung Lea在源代码开头的注释详细介绍了CSM总体设计思路并给出字符型展示的CSM结构图，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Head nodes          Index nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+    right        +-+                      +-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* |&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;|----------------&amp;gt;| |---------------------&amp;gt;| |-&amp;gt;&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+                 +-+                      +-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*  | down              |                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*  v                   v                        v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+            +-+  +-+       +-+            +-+       +-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* |&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;|-----------&amp;gt;| |-&amp;gt;| |------&amp;gt;| |-----------&amp;gt;| |------&amp;gt;| |-&amp;gt;&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+            +-+  +-+       +-+            +-+       +-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*  v              |    |         |              |         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Nodes  next     v    v         v              v         v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | |-&amp;gt;|A|-&amp;gt;|B|-&amp;gt;|C|-&amp;gt;|D|-&amp;gt;|E|-&amp;gt;|F|-&amp;gt;|G|-&amp;gt;|H|-&amp;gt;|I|-&amp;gt;|J|-&amp;gt;|K|-&amp;gt;&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CSM源代码解析文章说明：由于CSM解析内容较多，因此全文分为“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（上）”和“深度讨论高并发跳表数据结构ConcurrentSkipListMap的源代码实现（下）”两篇文章&lt;br&gt;上篇关注的重点：CSM数据结构设计原理、doGet、doPut核心方法解析&lt;br&gt;下篇关注的中断：doRemove核心方法解析、总结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/0eb498c68cbb4bf1999927e150db78b1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeWllbGQtYnl0ZXM=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深入解析ThreadLocal的数据结构设计原理及其源代码实现</title>
    <link href="https://yield-bytes.github.io/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yield-bytes.github.io/2021/12/05/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ThreadLocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-04T16:00:00.000Z</published>
    <updated>2022-05-18T07:04:24.280Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal可以实现完全基于无锁且也不是基于CAS的线程隔离需求，让每个线程可以有自己的本地实例，但如果对ThreadLocal底层设计不了解，那么对甚至无法正确ThreadLocal及其可能出现的内存泄露问题。可以说ThreadLocal的源代码设计也一种非常优秀的可支持“高并发”的实现。</p><p><img src="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png" alt="在这里插入图片描述"></p><p>《gitee 博客文章封面》</p><a id="more"></a><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ThreadLocal&lt;String&gt; var1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            ThreadLocal&lt;String&gt; var2=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            <span class="comment">// 普通用法</span></span><br><span class="line">            var1.set(<span class="string">&quot;foo A&quot;</span>);</span><br><span class="line">            var2.set(<span class="string">&quot;bar A&quot;</span>);</span><br><span class="line">            System.out.println(var1.get()); <span class="comment">// 输出foo A</span></span><br><span class="line">            System.out.println(var2.get()); <span class="comment">// 输出bar A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ThreadLocal&lt;String&gt; var1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            ThreadLocal&lt;String&gt; var2=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            <span class="comment">// 普通用法</span></span><br><span class="line">            var1.set(<span class="string">&quot;foo B&quot;</span>);</span><br><span class="line">            var2.set(<span class="string">&quot;bar B&quot;</span>);</span><br><span class="line">            System.out.println(var1.get()); <span class="comment">// 输出foo B</span></span><br><span class="line">            System.out.println(var2.get()); <span class="comment">// 输出bar B</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ProducerA().start();</span><br><span class="line">        <span class="keyword">new</span> ProducerB().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里创建了两个线程，每个线程内部有自己的ThreadLocal变量，线程之间ThreadLocal变量内部的set和get互相独立，互不影响，无需使用锁即可实现了线程安全操作。线程内部的变量使用set方法给定初始值、get方法取值，可以猜测其内部有类似HashMap这样的设计，但是否照搬HashMap数据结构设计呢？ 其实不然。</p><p>在这里，ProducerA内部其实是创建了一个称为“ThreadLocalMap”的Map结构用于存放ThreadLocal变量和它的value，ProducerB内部也创建了一个ThreadLocalMap，也即每个线程绑定一个自己内部ThreadLocalMap，这里提到的ThreadLocalMap就是提供了set、get方法的底层Map数据结构，所谓的ThreadLocal数据结构分析其实就是特指其内部的ThreadLocalMap的数据结构分析。</p><h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCount</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;HoldCount&gt; rh=ThreadLocal.withInitial(HoldCount::<span class="keyword">new</span>); <span class="comment">// 设定rh这个ThreadLocal变量的初始值</span></span><br><span class="line">        rh.set(<span class="keyword">new</span> HoldCount());  <span class="comment">// 将计数器放在rh中缓存</span></span><br><span class="line">        HoldCount h= rh.get();</span><br><span class="line">        System.out.println(h.count); <span class="comment">// 这里输出的rh初始值，也即HoldCount的count属性初始值:0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            h.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(h.count);</span><br><span class="line"></span><br><span class="line">        HoldCount newh=rh.get();<span class="comment">// 更新缓存计数器后，再从ThreadLocal重新读取</span></span><br><span class="line">        System.out.println(newh.count); <span class="comment">// 可以读取新的计数值</span></span><br><span class="line">        <span class="comment">// 在rh这个ThreadLocal里面的Map结构中移除HoldCount实例对象</span></span><br><span class="line">        rh.remove();</span><br><span class="line">        System.out.println(rh.get()); <span class="comment">// 此时rh里面Map已经不存在HoldCount对象，因此这里返回NUll</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在demo2中，给出了使用ThreadLocal后需要及时删除其实例对象的情况，这部分原因将在文章后面给出深入分析。</p><h3 id="ThreadLocal内部数据结构简析"><a href="#ThreadLocal内部数据结构简析" class="headerlink" title="ThreadLocal内部数据结构简析"></a>ThreadLocal内部数据结构简析</h3><p>可以看到set方法是由内部ThreadLocalMap实现的set方法，既然是个“Map”，那么当然可以猜测是否跟HashMap的数据结构：数据+链表+红黑树类似呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实ThreadLocalMap的数据结构没有HashMap数据结构复杂，ThreadLocalMap底层仅有一个table数组，这里，也许你会好奇：HashMap为了解决hash冲突，在数组的桶位上加入一条单向链表，冲突的entry自然会放入到此链表中（或者红黑树），那么问题来了，ThreadLocalMap底层仅有一个table数组，它是如何解决hash冲突？以下正式其设计原理之一，这里的数组给出最简单的情况，不包括“stale entry（无效entry）”的情况，以便让读者快速理解ThreadLocalMap设计原理：<br><img src="https://img-blog.csdnimg.cn/692e077da2654f0eb1ec67ff4f54a4cf.png" alt="在这里插入图片描述"><br>可以看到图中所说的“解决冲突的方式：从i=3开始向后遍历出首个空slot，也即i=5，将keyC放入此空slot即可”的逻辑被称为“线性探测法”，所谓的“线性”就是o(n)复杂度的遍历操作，所谓的“探测”就是不断向后“探测、寻找”，直到找到首个空slot位置。</p><p>以上内容为ThreadLocalMap的放入new Entry的简单情况，如果有理解HashMap源代码设计的读者应该可以猜到其他重要设计：例如，当数组容量不够时，如何扩容，也即rehash（注意ThreadLocalMap里面的resize和rehash不是同一个逻辑），再例如ThreadLocalMap里面已经存在的entry，如果它的key已经变成无效（stale），那么如何该清理，或者说在set和get的线性探测过程中遇到有stale entry时，该如何清理？这些问题将在后面逐个深入探讨。</p><h3 id="ThreadLocalMap的基本成员变量"><a href="#ThreadLocalMap的基本成员变量" class="headerlink" title="ThreadLocalMap的基本成员变量"></a>ThreadLocalMap的基本成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// ThreadLocalMap底层数组存放的WeakReference类型的entry，使用弱引用类型是为了能够高效GC，避免内存泄露，文章后面给出此设计的讨论</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"><span class="comment">/* entry的key就是ThreadLocal对象，例如一个线程内部有10个ThreadLocal变量，那么此线程内部的ThreadLocalMap将存放这10个entry，这里的value就是ThreadLocal变量的“值”。</span></span><br><span class="line"><span class="comment">    例如demo1中：</span></span><br><span class="line"><span class="comment">        ThreadLocal&lt;String&gt; var1=new ThreadLocal&lt;&gt;();</span></span><br><span class="line"><span class="comment">        var1.set(&quot;foo A&quot;)</span></span><br><span class="line"><span class="comment">        那么entry的key就是这个名称为var1的ThreadLocal对象，value就是字符串“foo A”</span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 数组的初始容量16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">     * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap的底层数组，这里也采用2的次方，原因在HashMap的源代码讨论已经给出深入的解析，这里不再累赘。</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of entries in the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 数据含有entry的个数，注意即使entry的key处于stale状态，它也算一个entry</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 注意区别于HashMap的扩容阈值是len*3/4</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increment i modulo len.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 返回数组当前位置i的下一个位置i+1,如果下一个位置超过数组长度，那么下一个位置又从下标0开始，这种方式实现了所谓的“环形数组”，在后面get、set方法中或者stale entry清空机制的处理中可以看到它的用处</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decrement i modulo len.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 逻辑同上，方向相反，返回当前位置i的前一个位置i+1，如果来到数组头部，那么前一个位置即回到数组末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="set方法完全解析"><a href="#set方法完全解析" class="headerlink" title="set方法完全解析"></a>set方法完全解析</h3><h4 id="set方法本身"><a href="#set方法本身" class="headerlink" title="set方法本身"></a>set方法本身</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the value associated with key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">      <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">      <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">      <span class="comment">// path would fail more often than not.</span></span><br><span class="line">      </span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="comment">// 1.计算给定key对应的桶位，此hash算法能够最大程度将key平均分布到数组对应的桶位上，具体算法参考文后说明</span></span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      <span class="comment">/* 2.线性探测发的实现</span></span><br><span class="line"><span class="comment">      从定位到i桶位开始遍历，直到遇到一个entry确实是null的空桶位，如果此遍历过程中遇到stale entry那么将其替换即可完成set操作。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">           e != <span class="keyword">null</span>;</span><br><span class="line">           e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 3.如果此桶位的key恰好是给定给定的key，那么更新此桶位的value后可直接返回。</span></span><br><span class="line">          <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">              e.value = value;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">// 4. 当前桶位的entry的key为null（注意这个key是弱引用类型，说明此entry已经被GC），使用replaceStaleEntry放入新entry</span></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">              replaceStaleEntry(key, value, i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 5.在2的线性探测过程中，遇到entry为空的即可来到这流程,直接放入新entry，并且数组的entry数量加1，在这里应该可以猜到，当向数组添加一个新entry后接下来就要判断是否需要扩容</span></span><br><span class="line">      tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">      <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 6.满足扩容的条件：cleanSomeSlots返回False且entry数量达到扩容阈值</span></span><br><span class="line">      <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">          rehash();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于线性探测法的说明</p><p>1.为何会有“环形数组或者环形遍历”的设计:<code>nextIndex</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">     e != <span class="keyword">null</span>;</span><br><span class="line">     e = tab[i = nextIndex(i, len)]) </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9b76747291534dd4b553699e0ea6b551.png" alt="在这里插入图片描述"></p><p>图1所示，假设目前有一个keyX定位到的桶位是i=13，但此桶位已存在entry，只能继续向后探测，来到数组尾部的桶位也不为空，此时经过<code>e = tab[i = nextIndex(i, len)]</code>的计算后，线性探测再次回到数组的头部位置重新遍历，如图2所示，当遍历到i=6时，发现此桶位为空，即可跳出循环接着在此位置放置新的entry，这就是“环形数组或者环形遍历”的底层设计逻辑。</p><h4 id="更加离散的hash计算"><a href="#更加离散的hash计算" class="headerlink" title="更加离散的hash计算"></a>更加离散的hash计算</h4><p>ThreadLocalMap内部的hash计算方式没有采用类似HashMap的计算方式,而是自行设计了一套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">     * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">     * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">     * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">     * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">     * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">     * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">     * less common cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 巧妙利用了原子累加器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// hash值递增步长，每次对新的i计算hash值前先加上此数，计算结果能更加离散,这个值对应的十进制数为1640531527，这个值就是带符号的32位int的最大值的黄金分割值取正</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next hash code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次对新的i计算hash值前先加上此数，计算结果能更加离散</span></span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>模拟ThreadLocalMap的hash计算方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHashCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tableLength=<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">32</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h=i*HASH_INCREMENT+HASH_INCREMENT;</span><br><span class="line">            <span class="keyword">int</span> index=h &amp; (tableLength-<span class="number">1</span>);</span><br><span class="line">            System.out.println(i+<span class="string">&quot;定位的桶位是:&quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察不同桶位计算出的hash值确实足够离散：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0定位的桶位是:7</span><br><span class="line">1定位的桶位是:14</span><br><span class="line">2定位的桶位是:5</span><br><span class="line">3定位的桶位是:12</span><br><span class="line">4定位的桶位是:3</span><br><span class="line">5定位的桶位是:10</span><br><span class="line">6定位的桶位是:1</span><br><span class="line">7定位的桶位是:8</span><br><span class="line">8定位的桶位是:15</span><br><span class="line">9定位的桶位是:6</span><br><span class="line">10定位的桶位是:13</span><br><span class="line">11定位的桶位是:4</span><br><span class="line">12定位的桶位是:11</span><br><span class="line">13定位的桶位是:2</span><br><span class="line">14定位的桶位是:9</span><br><span class="line">15定位的桶位是:0</span><br><span class="line">16定位的桶位是:7</span><br><span class="line">17定位的桶位是:14</span><br><span class="line">18定位的桶位是:5</span><br><span class="line">19定位的桶位是:12</span><br><span class="line">20定位的桶位是:3</span><br><span class="line">21定位的桶位是:10</span><br><span class="line">22定位的桶位是:1</span><br><span class="line">23定位的桶位是:8</span><br><span class="line">24定位的桶位是:15</span><br><span class="line">25定位的桶位是:6</span><br><span class="line">26定位的桶位是:13</span><br><span class="line">27定位的桶位是:4</span><br><span class="line">28定位的桶位是:11</span><br><span class="line">29定位的桶位是:2</span><br><span class="line">30定位的桶位是:9</span><br><span class="line">31定位的桶位是:0</span><br></pre></td></tr></table></figure><h4 id="replaceStaleEntry方法解析（核心内容）"><a href="#replaceStaleEntry方法解析（核心内容）" class="headerlink" title="replaceStaleEntry方法解析（核心内容）"></a>replaceStaleEntry方法解析（核心内容）</h4><p>在set方法中的第4点：替换失效的entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 当前桶位的entry的key为null（注意这个key是弱引用类型，说明此entry已经被GC），使用replaceStaleEntry放入新entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>其源码设计包括两个重要的核心功能：替换对应位置失效的entry和具有顺带功能（As a side effect）的清理其他失效entry，其中清理entry的逻辑设计最为复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、staleSlot是对于给定key用线性探测法“前向遍历”找到的首次出现的stale entry对应的下标</span></span><br><span class="line"><span class="comment">    为何第1步骤的前向遍历没有安排类似第2步骤的“替换操作等逻辑呢”，因为“ThreadLocal本身用的是开发地址法，冲突的key都被放置在后面空的slot，就算来到table末尾再从头遍历，它也是遵循“向后放置发生冲突的key””</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">   <span class="comment">// 2. 从set方法传入的staleSlot下标开始向后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     以下逻辑非常关键：</span></span><br><span class="line"><span class="comment">     3.1 如果从stale slot开始的“后向遍历”的第i下标又出现了key冲突，说明给定的key“本应放在stale slot 下标位置，但是因为冲突，被迫挪到比stale slot 更靠后的位置i”，既然现在stale slot已失效，那么就可以将给定key放回本应该更靠近hash定位的下标位置staleSlot。这里采用交换两者位置即可实现此逻辑。这就是”to swap it with the stale entry to maintain hash table order”所要表达的逻辑。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;  </span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">           <span class="comment">// 3.2 如果slotToExpunge还是staleSlot，说明第1步骤的“前向探测”没有stale entry，那么就将清理起始下标改到i，因为i下标位置存放的是在3.1交换过来的stale entry：tab[i] = tab[staleSlot]</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        <span class="comment">/* 3.3 到此，我们知道，截止到i下标的stale entry情况ß：</span></span><br><span class="line"><span class="comment">         [某个空slot,staleSlot)：从staleSlot的前向位置都没有stale entry</span></span><br><span class="line"><span class="comment">         staleSlot：将i位置的有效entry交换过来tab[staleSlot] = e</span></span><br><span class="line"><span class="comment">         [staleSlot+1,i-1]：后向遍历没有出现stale entry</span></span><br><span class="line"><span class="comment">         i：存放的是从staleSlot交换过来的stale entry</span></span><br><span class="line"><span class="comment">         因此slotToExpunge肯定是从i下标开始做清理工作。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">      <span class="comment">// 3.4 后向遍历在第i下标发现了一个stale entry且在前向遍历没有出现stale entry，那么清理开始下标当然要重置为i，那么staleSlot位置还存放着stale entry且没有也没有像3.1这样的“swap it”的设计，那么staleSlot自己是如何处理呢。它会在接下里的第4步骤中被处理掉！ 那么在这个步骤发现第i号下标新的stale entry又是如何处理呢？ 它会在第5个步骤被清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">   <span class="comment">/* 4. 在整个run都没有找到对应的key且也没有发现stale entry（除了staleSlot本身整个），那么好办，直接将staleSlot这个在set方法一开始就发现的stale entry的位置替换为新 entry即可，这就是为何方法名字命名为replaceStaleEntry。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">  <span class="comment">// 第5步骤：接第3.4步骤出现的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于“A run”的理解（理解run及其内部清理标记逻辑才能透彻理解set背后的原理）</p><p>As a side effect, this method expunges all stale entries in the “run” containing the stale entry(A run is a sequence of entries between two null slots.)<br><img src="https://img-blog.csdnimg.cn/ac10ec60579e410f910401b2ab956b87.png" alt="在这里插入图片描述"><br>如上图所示：</p><p>一个”run”就是在两个空slot之间的slots，例如上图，i=0和i=12之间就是一个“run”。 </p><p>1.为何这“run”是以两个空slot作为边界呢？</p><p>这是因为replaceStaleEntry的第1步骤使用prevIndex前向探测，直到遇到null slot则结束循环，而第2步骤使用nextIndex后向探测，直到遇到null slot则结束循环，因此可以得出一前一后都是null slot作为边界。</p><p>2.结合replaceStaleEntry的源代码分析的第1点：显然经过prevIndex的“前向探测”探测到了首个i=1的stale entry，因此slotToExpunge指向i=1表示此下标是接下expungeStaleEntry清理的起始下标。</p><p>3.根据1可知，如果slotToExpunge下标和staleSlot下标相等，说明“前向探测”根本没发现stale entry，也即slotToExpunge指向没动过。</p><p>4.根据第3.4步骤可知，<code>k == null &amp;&amp; slotToExpunge == staleSlot</code>，说明除了在set方法第一次发现的staleSlot，还在replaceStaleEntry的后向探测中的第i位置又发现了一个stale entry，因此起始清理下标要重置为slotToExpunge=i</p><p><img src="https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png" alt="在这里插入图片描述"></p><p>关于replaceStaleEntry内部最关键的“替换算法”，也即对应第第3.1步骤到第3.3步骤如上图1和图2所示：</p><p>不妨假设i=8就是“给定的key”hash定位时发生的冲突下标，假设i=11的key1等于“给定的key”，也即对应第3.1步骤，</p><p>此时实施3.1步骤的“swap”逻辑：</p><p>将staleSlot=9的stale entry交换到key1的i=11位置，原i=11位置entry交换到staleSlot=9位置并且key不变但value被更新为“给定key对应的value”。</p><p>经过这么处理，“给定的key”所在桶位显然更靠近原本属于它的8号桶位，而不是像之前“被迫挪到”11号桶位，这就是源代码注释说提到的“we need to swap it with the stale entry to maintain hash table order”</p><p>以上的算法设计可以抽象为以下类比逻辑：</p><blockquote><p>A本应坐在1号位，但发现来晚了，1号位置有人坐了，2、3、4也有人坐了，A被迫坐在5号位，某个时刻“新来的B”发现2号位已经变成staleSlot且1号位还有人在坐，那么此时B可以将A交换到2号位且把2号位的stale entry交换到5号位，那么此刻位于2号位的A显然更靠近“本属于自己的1号座位</p></blockquote><h4 id="关于staleSlot的清理逻辑设计"><a href="#关于staleSlot的清理逻辑设计" class="headerlink" title="关于staleSlot的清理逻辑设计"></a>关于staleSlot的清理逻辑设计</h4><p>在4.2 中replaceStaleEntry为我们展示了精密的如何找出“起始清理下标”的算法设计，从</p><p><code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code>可知，清理逻辑被设计为两部分：<br>第一部分：<code>expungeStaleEntry(slotToExpunge)</code>，此方法返回一个i下标。第一部分的清理可称为“线性地清理”——“linear expunge”。注意此过程还包括rehash过程！！</p><p>第二部分：<code>cleanSomeSlots(i, len)</code>，第二部分的清理可以称为“Heuristically expunge”，这里并不打算翻译为“启发性清理”，因为此处不建议使用中文硬翻译。（若要翻译，则可以翻译为“试探性地清理”）</p><p>以下是关于“线性地清理-expungeStaleEntry”的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class="line"><span class="comment"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class="line"><span class="comment"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class="line"><span class="comment"> * Knuth, Section 6.4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> staleSlot index of slot known to have null key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the next null slot after staleSlot</span></span><br><span class="line"><span class="comment"> * (all between staleSlot and this slot will have been checked</span></span><br><span class="line"><span class="comment"> * for expunging).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1.这里入参的staleSlot，就是replaceStaleEntry探测到的slotToExpunge下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 2.首先清空当前slotToExpunge下标的stale entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">  <span class="comment">// 3. 在slotToExpunge+1到恰好遇到null slot之间进行逐个探测清理</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 3.1 又出现stale entry可直接清空</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2 再次计算当前位置i放置的entry对应的hash值，如果hash值和当前i桶位一致，说明没有冲突，此entry恰好就是位于“本属于自己的桶位上”，如果hash值和当前i不一致，说明“此entry因为冲突被迫放到了第i位置，而第i位置不是此entry的直接定位”，可以将位于i桶位的“entry”放在“属于自己的h桶位”，这样就保证了entry能最大程度靠近或者就位于“本属于自己的桶位”范围以内，目的是为了提供线性探测查询效率！</span></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>); </span><br><span class="line">          <span class="comment">// 从向后探测的开放地址法可知，h值更小，i值更大，正是因为原h位置有冲突，e才被放置到更靠后的第i位置</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">              <span class="comment">// 因为发生冲突被迫放置在i位置的entry,后面会被放到它的直接定位h桶位，因此i位置可以置为null</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">   虽然h桶位就是此entry的直接定位，但是考虑到h桶位可能被放置了其他entry，因此需要加入“向后探测”的逻辑，直到发现下一个位置为null slot。</span></span><br><span class="line"><span class="comment">   tab[h] = e  的写法就实现了“因为发生冲突被迫放置在i位置的entry，现在能够最接近地放到本属于自己直接定位的h桶位*/</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 显然此i就是第3步骤for循环里面从slotToExpunge向后探测到下一个null slot下标，此下标会被cleanSomeSlots方法中利用起来。</span></span><br><span class="line"><span class="comment"> for (i = nextIndex(staleSlot, len);</span></span><br><span class="line"><span class="comment">         (e = tab[i]) != null;</span></span><br><span class="line"><span class="comment">         i = nextIndex(i, len))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>expungeStaleEntry难点其实在第3.2步骤中遇到的情况，需要做个简单的rehash，保证entry更加靠近“本属于自己的直接定位h桶位”，过程解析参考以下算法流程：<br><img src="https://img-blog.csdnimg.cn/adb19cd01cd640d7bd8f5fc77a5daf8d.png" alt="在这里插入图片描述"><br>当然，如果在图2的中i=8不是null slot，那么从h位置开始<code>while (tab[h] != null)</code>探测，也会探测到i=10位置是个null slot，结果就是<code>table[h=i=10]=e</code>，e还是位于第i位置上。</p><h4 id="cleanSomeSlots-i-len-方法"><a href="#cleanSomeSlots-i-len-方法" class="headerlink" title="cleanSomeSlots(i, len)方法"></a>cleanSomeSlots(i, len)方法</h4><p>注意，要清楚<code>cleanSomeSlots(i, len)</code> i和len含义，否则无法理解cleanSomeSlots目的，这里的<code>i</code>就是<code>expungeStaleEntry</code>返回的一个空slot，len是table长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 3.</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//4 .</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 5.控制探测的次数</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.首先，考虑最简单的情况，如果第i和len之前都不存在stale entry，那么就相当于在1和len范围内折半探测，时间复杂度为log2(n)</p><p>2.其次，考虑到探测在i和len过程中，出现了stale entry，此时会将n重置为len长度，继续while，再一轮log2(n)次遍历</p><p>这就是所谓的“Heuristically scan”，因为是log2(n)，即使出现如2情况，此试探性的探测动作也是可以很快完成。</p><h4 id="set方法内部的rehash"><a href="#set方法内部的rehash" class="headerlink" title="set方法内部的rehash"></a>set方法内部的rehash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">      <span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 显然如果cleanSomeSlots返回true，表明在table中清理了不少于1个的stale entry，恰好可以腾出不少于1个空slot，显然不需要table扩容。</span></span><br><span class="line"><span class="comment">2. 当!cleanSomeSlots(i, sz) 表示没有遇到stale entry且table的entry数量已经达到了阈值，可以进入扩容逻辑</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">      <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">          rehash();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>rehash内部设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class="line"><span class="comment">   * table removing stale entries. If this doesn&#x27;t sufficiently</span></span><br><span class="line"><span class="comment">   * shrink the size of the table, double the table size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.扩容前，先从头到尾线性清理一下stale entry，运气好的话，清理的stale entry后恰好有足够多的null slot，这样省去真正的扩容操作，效率更高。</span></span><br><span class="line">      expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">      <span class="comment">// 2.此时的size是在1步骤清理完stale entry后的实际entry个数，只有当此时的size达到了0.75threshold才会去扩容，</span></span><br><span class="line">      <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Entry[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">      <span class="comment">// 这里看出是两倍扩容</span></span><br><span class="line">      <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">      Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 1.从旧表开始逐个遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">          Entry e = oldTab[j];</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">              <span class="comment">// 2.旧表当前j位置出现stale entry，那么直接将entry的value强引用设为null，Help the GC</span></span><br><span class="line">              <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 3. 旧表当前遍历位置j是正常的entry，那么用新表newLen计算它在新表的桶位号  </span></span><br><span class="line">                  <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                  <span class="comment">// 4. 开放地址法在新表中为“当前旧表遍历位置下entry”找到对应的null slot新表h位置</span></span><br><span class="line">                  <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                      h = nextIndex(h, newLen); <span class="comment">// 注意这里是在新表计算</span></span><br><span class="line">                  newTab[h] = e; </span><br><span class="line">                  count++; </span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setThreshold(newLen);</span><br><span class="line">      size = count;</span><br><span class="line">      table = newTab; <span class="comment">// table 指向新表引用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rehash的逻辑相对简单。</p><h3 id="get方法解析"><a href="#get方法解析" class="headerlink" title="get方法解析"></a>get方法解析</h3><p>有了set方法完全解析流程后，对于get方法则很好理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="comment">// 1、ThreadLocalMap已经存在时</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getEntry才是正在在底层table去查找给定key对应的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果线程t的ThreadLocal内部ThreadLocalMap还未初始化，直接返回ThreadLocal初始化时设定的初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> getMap的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">  * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">  * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 这里可以看出，原来ThreadLocal并不是独立存在，而是它里面的ThreadLocalMap绑定当前线程的成员变量threadLocals，因此ThreadLocalMap的生命周期和线程同在</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">     t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">      * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">      * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"> ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">         table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">         <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">         table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">         size = <span class="number">1</span>;</span><br><span class="line">         setThreshold(INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>getEntry整体设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment"> * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment"> * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 1. 对应上面源代码注释提到“Only the fast path：a direct hit of existing key” 逻辑，也即给定key对应的i桶位的entry恰好存放的就是key的entry。</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">   <span class="comment">// 2. 说明这个key在之前是发生冲突了，放置到比i更靠后的位置，需要采用“后向探测”去检索。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment"> * its direct hash slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i the table index for key&#x27;s hash code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 从给定的entry开始后向遍历探测</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 1.找到，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 2.遇到stale entry，调用expungeStaleEntry清理它，此时i位置就是slotToExpunge起始清理的下标</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 3.继续向后探测下一个entry  </span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the entry for key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line"><span class="comment">// 目的是主动让entry的父类成员变量置null，那么entry自然就不会存在任何引用了，直接从正常的entry变成stale entry</span></span><br><span class="line">            e.clear(); </span><br><span class="line"><span class="comment">//            </span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> e.clear()关键逻辑：此方法来自<code>import java.lang.ref.Reference；</code>可以看到<code>e.clear()</code>目的是主动让entry的父类成员变量置null，那么entry自然就不会存在任何引用了，直接从正常的entry变成stale entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears this reference object.  Invoking this method will not cause this</span></span><br><span class="line"><span class="comment"> * object to be enqueued.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment"> * clears references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ThreadLocal弱引用和内存泄露问题"><a href="#ThreadLocal弱引用和内存泄露问题" class="headerlink" title="ThreadLocal弱引用和内存泄露问题"></a>ThreadLocal弱引用和内存泄露问题</h3><p>在前面的所有内容中，我们都知道在线性探测中用<code>if (k == null)</code> 去判断当前桶位的entry是否为变为一个stale entry，放入一个正常的entry的为何会在某个时刻变成“失效的entry”？这是因为entry的key被设计为<code>WeakReference ,</code>这是ThreadLocalMap关键设计之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">注意以下源代码的解析</span></span><br><span class="line"><span class="comment">   To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k); <span class="comment">// key 是弱引用类型</span></span><br><span class="line">            value = v; <span class="comment">// value 是强引用类型  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所谓的java弱引用：一旦有gc，那么WeakReference类型的对象就会被回收，用以下demo说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        Entry(String key,String value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Entry&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;key=&#x27;&quot;</span> + key + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Entry entry=<span class="keyword">new</span> Entry(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>); <span class="comment">// entry显然是一个强引用</span></span><br><span class="line">        WeakReference&lt;Entry&gt; entryWeakReference=<span class="keyword">new</span> WeakReference&lt;&gt;(entry); <span class="comment">// entryWeakReference是一个弱引用</span></span><br><span class="line"></span><br><span class="line">        System.gc();<span class="comment">// gc1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc1,entry:&quot;</span>+entry); <span class="comment">// Entry&#123;key=&#x27;foo&#x27;, value=&#x27;bar&#x27;&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc1,entryWeakReference:&quot;</span>+entryWeakReference.get()); <span class="comment">// Entry&#123;key=&#x27;foo&#x27;, value=&#x27;bar&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        entry=<span class="keyword">null</span>; <span class="comment">// 此时entry强引用被置为null，那么会被gc回收</span></span><br><span class="line">        System.gc();<span class="comment">// gc2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after gc2,entryWeakReference:&quot;</span>+entryWeakReference.get()); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">after gc1,entry:Entry&#123;key&#x3D;&#39;foo&#39;, value&#x3D;&#39;bar&#39;&#125;</span><br><span class="line">after gc1,entryWeakReference:Entry&#123;key&#x3D;&#39;foo&#39;, value&#x3D;&#39;bar&#39;&#125;</span><br><span class="line">after gc2,entryWeakReference:null</span><br></pre></td></tr></table></figure><p>注意到ThreadLocalMap中的Entry，key类型是<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code> 弱引用的，因此一旦此key没有指向强引用，那么key显然会变为null，那么gc时作为key的ThreadLocal对象在jvm堆中就会被回收，对应的Entry就是一个<code>stale entry</code>，注意，如果Entry的value此时还不是null也即还是处于强引用类型状态，这会引出另外一个问题：ThreadLocal内存泄露问题，或者说：</p><p>为何ThreadLocal会有内存泄露问题？</p><p>其实比较好理解，首先ThreadLocal内部ThreadLocalMap存放的Entry对象和当前线程的生命周期一致，只要线程不结束，且Entry的value也即给ThreadLocal对象设置的value没有被删除（强引用还在），那么这个Entry就不会被回收，假设一个线程内部的ThreadLocalMap里面有很多这样的Entry，那么就会面临内存泄露的风险，</p><p>考虑线程池的情况，例如有线程使用ThreadlLocal对象，此线程位于线程池中会一直保持运行，对于它的ThreadlLocal对象内部的ThreadLocalMap来说，如果map中Entry的value没有被外界使用完后及时删除，就导致此Entry一直得不到回收，容易发生内存泄露。</p><p>Entry的key采用弱引用类型，value为何不采用同样的弱引用类型设计呢？</p><p>首先，key是线程本地变量ThreadLocal，它本身可以被回收，但是其变量的值value本身是在其他地方被使用着，例如value放着的是一个Session对象或者事务管理中的Connection对象，如果value被设计为弱引用类型，那么在也业务层面被使用“线程本地变量的value”——Session对象或者Connection对象就会随机被回收，导致业务层出错，显然无法接受这种情况。所以value保持强引用的设计才是符合实际情况的。</p><h4 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h4><p>代码中满足一定<code>ThreadLocal.get()、ThreadLocal.set()</code>逻辑设计的情况下，主动调用<code>ThreadLocalMap.remove</code> 来移除Entry对象的引用关系，这种高级且科学用法，其实在<code>ReentrantReadWriteLock</code>的源代码设计有所体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      定义一个给每个线程自己的内部读锁计数器</span></span><br><span class="line"><span class="comment">      * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">      * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * ThreadLocal subclass. Easiest to explicitly define for sake</span></span><br><span class="line"><span class="comment">      * of deserialization mechanics.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">// 如何实现每个线程独立记录的读锁计数器？ 使用ThreadLocal即可保证线程隔离的计数，互不影响。</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  <span class="comment">// 线程自己持有的读锁计数器初始值0</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">      * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">      * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">     Sync() &#123;</span><br><span class="line">         readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">         setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 线程释放自己持有的读锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">         Thread current = Thread.currentThread();</span><br><span class="line">         <span class="comment">// 第一个持有读锁的线程恰好是当前线程，</span></span><br><span class="line">         <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">             <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">             <span class="comment">// “第一个持有读锁的线程” 也准备释放读锁，firstReader不再指向任何读线程</span></span><br><span class="line">             <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                 firstReader = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 否则“第一个持有读锁的线程”重入锁次数减1</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 firstReaderHoldCount--;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             HoldCounter rh = cachedHoldCounter;</span><br><span class="line">             <span class="comment">// 如果线程自己缓存的读锁计数器对象为空，或者线程自己的读锁计数器缓存的线程不是当前线程</span></span><br><span class="line">             <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 当前线程持有读锁的计数器readHolds</span></span><br><span class="line">                 rh = readHolds.get();</span><br><span class="line">             <span class="keyword">int</span> count = rh.count;</span><br><span class="line">             <span class="comment">// 当前线程持有读锁的计小于等于1，说明在本次读锁退出后，当前线程不再持有任何读锁，也即不再使用“计数器ThreadLocalHoldCounter”，因此用在它身上的ThreadLocal&lt;HoldCounter&gt;对象需要马上移除，避免ThreadLocal发生内存泄露。</span></span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                 readHolds.remove();</span><br><span class="line">                 <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">// 线程自己持有读锁自减1</span></span><br><span class="line">             --rh.count;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 总的读锁锁-1</span></span><br><span class="line">             <span class="keyword">int</span> c = getState();</span><br><span class="line">             <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                 <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                 <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                 <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                 <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>从这里<code>ReentrantReadWriteLock</code>的关于ThreadLocal的使用中，再次理解了源代码注释提到的“可以使得状态和线程关联起来”，这里的“状态”就是读线锁中的每个线程持有读锁的数量，显然它和该线程绑定了起来，因此体现ThreadLocal变量使用的完美场景。</p><h4 id="ThreadLocal在类中常见用法"><a href="#ThreadLocal在类中常见用法" class="headerlink" title="ThreadLocal在类中常见用法"></a>ThreadLocal在类中常见用法</h4><p>在ThreadLocal源代码文件的注释开头有提到以下说明：</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p></blockquote><p>尤其这句<code>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</code></p><p>ThreadLocal实例通常是位于类中的私有静态字段，目的是为了实现把“状态”与线程（例如，用户ID或事务ID）绑定起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">   <span class="comment">// 放在类的静态字段位置，这样类的其他方法可以直接使用“此线程局部变量” </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">       <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个例子是在《Thinkinkg in Java 4》提供的demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> idn)</span></span>&#123;id=idn;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            ThreadLocalHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> +id+<span class="string">&quot;:&quot;</span>+ThreadLocalHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作为类ThreadLocalHolder的静态变量，并指定初始值的生成方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.set(value.get()+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value.get();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个线程，每个线程都有ThreadLocalHolder的一个副本，且独立计数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：可以看到5个线程实现自己内部的独立自增计数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#0:7114</span><br><span class="line">#1:2381</span><br><span class="line">#2:7294</span><br><span class="line">#3:3291</span><br><span class="line">#4:5247</span><br><span class="line">#0:7115</span><br><span class="line">#1:2382</span><br><span class="line">#2:7295</span><br><span class="line">#3:3292</span><br><span class="line">#4:5248</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这里也可以引出另外一个问题，ThreadLocal变量放在类中使用时，一般作为类的静态字段使用，为何？</p><p>其实很好理解，类的静态变量确保在类的多次实例化后仍然保持在内存中仅有一份副本，或者说为了避免重复创建thread specific object（与线程相关的变量），例如ThreadLocal变量管理了一个Session对象，那么当然希望在同一个线程中，此Session对象仅有一份实例，如果存在多份，那么就无法实现所谓“在同一session完成相关业务”的设计，导致逻辑出错。</p><h3 id="为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？"><a href="#为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？" class="headerlink" title="为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？"></a>为何ThreadLocal没有直接采用ConcurrentHashMap这样的Map数据结构？</h3><ol><li><p>首先，如果ThreadLocal使用ConcurrentHashMap来达到key-value管理目的，那么是无法实现“线程本地变量即：每个线程持有自己的本地实例”这样的需求，因此对于<code>Josh Bloch and Doug Lea</code>来说，需要给ThreadLocal设计全新一套的数据结构及其一些算法细节，以打造出可以支持和实现“线程本地变量且不需要基于任何锁的支持即可实现线程隔离”功能的数据结构，这显然是非常创新的工作，虽然ConcurrentHashMap的源代码设计已经堪称十分优秀。</p></li><li><p>其次，既然不采用ConcurrentHashMap这样内部复杂设计的Map结构，那么就要设计出非常高效、简约的数据结构，因此设计了底层只有一个数组table的ThreadLocalMap，不再有什么单链表、红黑树等结构，采用开放寻址法解决hash冲突，同时，只基于数组实现相关逻辑的代码会变得更加直观、简单，例如在扩容、清理stale entry方面，仅需基于数组的前后线性遍历即可。</p></li><li><p>ThreadLocal底层只基于一个数组table，结合设计特定的hash魔数，可以使得Entry的hash在数组中分散很均匀，大大降低了冲突概率，提高查询效率。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;ThreadLocal可以实现完全基于无锁且也不是基于CAS的线程隔离需求，让每个线程可以有自己的本地实例，但如果对ThreadLocal底层设计不了解，那么对甚至无法正确ThreadLocal及其可能出现的内存泄露问题。可以说ThreadLocal的源代码设计也一种非常优秀的可支持“高并发”的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/875e7788579d4c779bb5f3cff8ce278f.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：LongAdder高并发计数性能分析</title>
    <link href="https://yield-bytes.github.io/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/10/22/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9ALongAdder%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</id>
    <published>2021-10-21T16:00:00.000Z</published>
    <updated>2022-05-09T14:05:42.259Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于本博客已发布的CHM文章中分析fullAddCount方法基础上，介绍LongAdder这个高并发计数性能，并通过与原子计数器AtomicLong进行比较，最后给出Striped64类相关分析（因其内部真正实现了高并发计数逻辑）。</p><p>为何需要介绍下LongAdder类？<br>因为在fullAddCount方法的定义上，因为在CHM源代码上，Doug Lea有提到：fullAddCount的设计原理可通过LongAdder这个类得到相关解释：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">// 省略部分  ......</span></span><br></pre></td></tr></table></figure><h4 id="1、两种并发计数器的性能比较"><a href="#1、两种并发计数器的性能比较" class="headerlink" title="1、两种并发计数器的性能比较"></a>1、两种并发计数器的性能比较</h4><p>longAdderCost和atomicLongCost的目的：指定一定数量的线程并发执行该逻辑：每个线程计数从0增加到1000*1000</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] scales=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">128</span>,<span class="number">512</span>,<span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> loops=<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> scale : scales) &#123;</span><br><span class="line">            longAdderCost(scale,loops);</span><br><span class="line">            atomicLongCost(scale,loops);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">longAdderCost</span><span class="params">(<span class="keyword">int</span> threadNums,<span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdder longAdder=<span class="keyword">new</span> LongAdder();</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                    longAdder.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;LongAdder：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicLongCost</span><span class="params">(<span class="keyword">int</span> threadNums,<span class="keyword">int</span> loops)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong atomicLong=<span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        List&lt;Thread&gt; threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start= System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++) &#123;</span><br><span class="line">           Thread t= <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; loops; loop++) &#123;</span><br><span class="line">                   atomicLong.incrementAndGet();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">           thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">           thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration=System.currentTimeMillis()-start;</span><br><span class="line">        String s= String.format(<span class="string">&quot;AtomicLong：线程数为%s,计算%s次,总用时%sms&quot;</span>,threadNums,loops,duration);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LongAdder：线程数为<span class="number">1</span>,计算<span class="number">1000000</span>次,总用时205ms</span><br><span class="line">AtomicLong：线程数为<span class="number">1</span>,计算<span class="number">1000000</span>次,总用时17ms</span><br><span class="line">LongAdder：线程数为<span class="number">4</span>,计算<span class="number">1000000</span>次,总用时38ms</span><br><span class="line">AtomicLong：线程数为<span class="number">4</span>,计算<span class="number">1000000</span>次,总用时102ms</span><br><span class="line">LongAdder：线程数为<span class="number">16</span>,计算<span class="number">1000000</span>次,总用时64ms</span><br><span class="line">AtomicLong：线程数为<span class="number">16</span>,计算<span class="number">1000000</span>次,总用时351ms</span><br><span class="line">LongAdder：线程数为<span class="number">128</span>,计算<span class="number">1000000</span>次,总用时503ms</span><br><span class="line">AtomicLong：线程数为<span class="number">128</span>,计算<span class="number">1000000</span>次,总用时2833ms</span><br><span class="line">LongAdder：线程数为<span class="number">512</span>,计算<span class="number">1000000</span>次,总用时2092ms</span><br><span class="line">AtomicLong：线程数为<span class="number">512</span>,计算<span class="number">1000000</span>次,总用时12953ms</span><br><span class="line">LongAdder：线程数为<span class="number">1024</span>,计算<span class="number">1000000</span>次,总用时4007ms</span><br><span class="line">AtomicLong：线程数为<span class="number">1024</span>,计算<span class="number">1000000</span>次,总用时26639ms</span><br></pre></td></tr></table></figure><p>对以上数据进行作图如下：</p><p><img src="https://img-blog.csdnimg.cn/6c72a0eb2a7940a6a934d5cfe2633257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>可以非常清楚看到两者存在性能差异：</p><p>（1）剔除单线程数据，LongAdder并发计数耗时最少，并且随着线程数量增加，并发计数耗时趋势相对稳定</p><p>（2）剔除单线程数据，AtomicLong并发计数耗时长，并且随着线程数量增加，并发计数性耗时基本呈指数上升趋势</p><h4 id="2、两者性能差异的原因分析"><a href="#2、两者性能差异的原因分析" class="headerlink" title="2、两者性能差异的原因分析"></a>2、两者性能差异的原因分析</h4><h5 id="2-1-单线程情况"><a href="#2-1-单线程情况" class="headerlink" title="2.1 单线程情况"></a>2.1 单线程情况</h5><p>首先对于单线程情况下，也即线程数量为1，因为LongAdder的increment方法里面调用add方法且在add方法内部需要做一些基本判断，这些代码的执行需要消耗一定时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adds the given value.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 相当于ConcurrentHashMap的AddCount方法的分支1逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">      Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">      <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">              (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">              !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 相当于ConcurrentHashMap的fullAddCount的逻辑</span></span><br><span class="line">              longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Equivalent to &#123;<span class="doctag">@code</span> add(1)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      add(<span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对比atomicLong.incrementAndGet()方法：该方法直接进行计数，代码执行流程显然比上面要快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此单线程情况下，从实际测试结果来看，AtomicLong肯定会比LongAdder快</p><h5 id="2-2-多线程并发计数情况"><a href="#2-2-多线程并发计数情况" class="headerlink" title="2.2 多线程并发计数情况"></a>2.2 多线程并发计数情况</h5><p>当线程数量开始增加时，LongAdder计数比AtomicLong快，要知道这两个都是使用lockness机制也即Unsafe的CAS去实现的，为何两者性能差距这么明显？</p><p>主要还是两者的设计思路导致的</p><p>（1）对于AtomicLong来说：incrementAndGet方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用的是getAndAddLong方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其设计相对简陋，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/8addaedf6ca74783b40c1e63e963c062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>while自旋+对offset进行CAS加delta值计数，也即当有1000个线程并发去incrementAndGet时，由于线程竞争激烈，导致每轮自旋只能有1个线程成功拿到本轮的CAS，那么最后效果：越多线程参与计数效率就越慢，因为竞争激烈时，可能有一部分线程一直竞争CAS都失败，它们占用cpu时间片不说，还未做“加1计数”的贡献。</p><p>打个通俗比喻：</p><p>有一个窗口放着一个小黑版，上面写着一个count，小黑板每次只让一个人对其加1计数，如果采用AtomicLong的“while自旋+CAS”设计，当有1000个人同时想在小黑板做加1计数时，每轮只能有一个人走到窗口前在小黑板加1，只要这个人还没写完，那么其他999个人就得一起不断来回走到窗口前看看能否抢到“小黑班写的权利”，显然这种“一起来回走动”浪费资源，效率也低。</p><p>（2）对于LongAdder来说：increment内部其实使用是相对高效的、能降低线程竞争的设计：longAccumulate，其实也是ConcurrentHashMap里面的fullAddCount方法，原理图在CHM的源代码已经给出，如下图所示<br><img src="https://img-blog.csdnimg.cn/5c320a9b9aa543d2aa19a0f41840f54c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>设计思想：</p><p>（1）当线程竞争不激烈情况下，通过自旋+cas对baseCount进行加1计数，这一阶段类似AtomicLong的计数逻辑</p><p>（2）当线程竞争十分激烈的情况下，有一部分线程很幸运能够抢到cas权力成功对baseCount加1，而剩下对baseCount加1cas失败的线程，它们就会创建一个CounterCells计数的数组，然后线程给对应自己的桶位Cell对象进行cas加1操作，这样一来就实现了“线程分流”，减少竞争。</p><p>亮点设计在于这个“CounterCells计数的数组”</p><p>打个通俗比喻（同上）：</p><p>当人数量少时，开1个窗口给他们在小黑板写</p><p>当人数量多，多开几个窗口，例如开8个窗口，每个窗口都放置一块小黑板，那么</p><p>每个窗口平均下来也就125个人在竞争，相比于之前1000个人激烈竞争1个窗口，</p><p>这个窗口最大数量跟cpu数量一致，能充分利用每个cpu core，显然性能就上来了。</p><p>其实两者的性能说明在LongAdder的源代码注释已给出：</p><blockquote><p>This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</p></blockquote><p>在线程竞争不激烈的写（更新）操作，两者性能类似。在线程竞争激烈情况下，也即线程并发高时，LongAdder拥有更高的throughput（一般指吞吐量，在这里可以理解为并发计数量），但代价是占用更多内存（上面的例子代价就是多开几个窗口）</p><p>LongAdder是典型的空间换时间的设计！</p><h4 id="3、Striped64类分析"><a href="#3、Striped64类分析" class="headerlink" title="3、Striped64类分析"></a>3、Striped64类分析</h4><p>考虑到CHM的fullAddCount源代码设计其实就是LongAdder里面的longAccumulate方法而该方法来自Striped64类，因此本文不再给出longAccumulate的源代码解析，具体可参考之前的文章：</p><p>关于LongAdder类，因为其源代码设计简单，也不再作为详细说明，本文重点讲解Striped64的设计:</p><p>LongAdder继承自Striped64</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246863182397L</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Striped64继承自Number，源代码总共413行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-1-Cell内部类"><a href="#3-1-Cell内部类" class="headerlink" title="3.1 Cell内部类"></a>3.1 Cell内部类</h5><p>在线程对base cas发生激烈冲突时，线程通过创建Cell数据并对桶位上的Cell进行cas加值操作，可以看到其内部独立使用了Unsafe机制，并且定义了一个更新值的cas方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Padded variant of AtomicLong supporting only raw accesses plus CAS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * JVM intrinsics note: It would be possible to use a release-only</span></span><br><span class="line"><span class="comment"> * form of CAS here, if it were provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Striped64的Cell类对比CHM fullAddCount CounterCell计数类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-其他成员变量"><a href="#3-2-其他成员变量" class="headerlink" title="3.2 其他成员变量"></a>3.2 其他成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bound on table size */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of cells. When non-null, size is a power of 2.也即fullAddCount里面的CounterCell[]数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment"> * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> * 也即fullAddCount里面的baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment"> * 也即fullAddCount里面cellsBusy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Package-private default constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Striped64() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CASes the base field.</span></span><br><span class="line"><span class="comment"> * 更新base的操作已经被独立封装成一个内部方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CASes the cellsBusy field from 0 to 1 to acquire lock.</span></span><br><span class="line"><span class="comment"> 对cellsBusy操作已经被独立封装成一个内部方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casCellsBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the probe value for the current thread.</span></span><br><span class="line"><span class="comment"> * Duplicated from ThreadLocalRandom because of packaging restrictions.</span></span><br><span class="line"><span class="comment"> * probe范围已探针，在这里，可以理解为与当前线程一一对应的随机值，也即键值对：（当前线程，线程对应的随机值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pseudo-randomly advances and records the given probe value for the</span></span><br><span class="line"><span class="comment"> * given thread.</span></span><br><span class="line"><span class="comment"> * Duplicated from ThreadLocalRandom because of packaging restrictions.</span></span><br><span class="line"><span class="comment"> * 当线程未能成功对桶位Cell进行CAS加值时，就给该线程换一个probe值，使得线程hash定位能够尽量定到不同的桶位上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">advanceProbe</span><span class="params">(<span class="keyword">int</span> probe)</span> </span>&#123;</span><br><span class="line">    probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span></span><br><span class="line">    probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">    probe ^= probe &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    UNSAFE.putInt(Thread.currentThread(), PROBE, probe); <span class="comment">// Unsafe操作对象是当前线程，更改的值为probe</span></span><br><span class="line">    <span class="keyword">return</span> probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这里为何这里键值对：（当前线程，线程对应的随机值）中线程对应的随机不是用<code>java.util.Random</code>生成？这是因为ThreadLocalRandom比Random更适合用在高并发情况，这里说的更适合是指“生成随机数性能更高而且与当前线程关联”，关键点为：ThreadLocalRandom，每个线程都有自己seed用于生成随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">    <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread(); <span class="comment">// 当前线程</span></span><br><span class="line">    UNSAFE.putLong(t, SEED, seed); <span class="comment">// 将当前的seed与当前线程关联起来</span></span><br><span class="line">    UNSAFE.putInt(t, PROBE, probe); <span class="comment">// 将当前的probe与当前线程关联起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-longAccumulat"><a href="#3-3-longAccumulat" class="headerlink" title="3.3 longAccumulat"></a>3.3 longAccumulat</h5><p>longAccumulat设计跟CHM里面的fullAddCount设计一致，只不过这里多了参数： update function</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles cases of updates involving initialization, resizing,</span></span><br><span class="line"><span class="comment"> * creating new Cells, and/or contention. See above for</span></span><br><span class="line"><span class="comment"> * explanation. This method suffers the usual non-modularity</span></span><br><span class="line"><span class="comment"> * problems of optimistic retry code, relying on rechecked sets of</span></span><br><span class="line"><span class="comment"> * reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn the update function, or null for add (this convention</span></span><br><span class="line"><span class="comment"> * avoids the need for an extra field or function in LongAdder).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wasUncontended false if CAS failed before call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>这个 update function有什么用呢？如下：</p><p>例如定义个匿名函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; 2 * x +1</span><br></pre></td></tr></table></figure><p>那么每次cas就可以不只是<code>cas(this，value1，value2)</code>这种形式，而是<code>cas(this，value1，fn(value2)</code>能对value2进一步处理后再给到cas放入主存中。</p><p>调用点1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"><span class="comment">// 当前线程对非空桶位Cell进行cas加值操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                     fn.applyAsLong(v, x))))</span><br></pre></td></tr></table></figure><p>调用点2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="comment">// 当前线程又回到对base加值操作，若当前线程能在base身上加值成功就可以退出逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base：这里是说当前线程因为进入longAccumulate没能竞争到对Cell加值操作，如果代码能执行到这个分支，那么线程又回到base变量去竞争cas加值操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与longAccumulat类似逻辑的是double类型的doubleAccumulate高并发计数方法，这里不再累赘。</p><p>个人认为Striped64类里面表达最重要信息之一是：源码内部的详细代码功能注释说明，本文不再一一翻译，所有详细的设计和逻辑都在CHM文章中fullAddCount章节给出非常详细的解析，因此你可以基于源码的理解来对照以下官方源码注释：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#x2F;*</span><br><span class="line">* 1、首先介绍Striped64类数据结构：底层是可原子写操作的table+base变量</span><br><span class="line">* This class maintains a lazily-initialized table of atomically</span><br><span class="line">* updated variables, plus an extra &quot;base&quot; field. The table size</span><br><span class="line">* is a power of two. Indexing uses masked per-thread hash codes.</span><br><span class="line">* Nearly all declarations in this class are package-private,</span><br><span class="line">* accessed directly by subclasses.</span><br><span class="line">*</span><br><span class="line">* 2、Cell类的设计说明</span><br><span class="line">* Table entries are of class Cell; a variant of AtomicLong padded</span><br><span class="line">* (via @sun.misc.Contended) to reduce cache contention. Padding</span><br><span class="line">* is overkill for most Atomics because they are usually</span><br><span class="line">* irregularly scattered in memory and thus don&#39;t interfere much</span><br><span class="line">* with each other. But Atomic objects residing in arrays will</span><br><span class="line">* tend to be placed adjacent to each other, and so will most</span><br><span class="line">* often share cache lines (with a huge negative performance</span><br><span class="line">* impact) without this precaution.</span><br><span class="line">*</span><br><span class="line">* 3、Cells[] 数组的设计目的</span><br><span class="line">* In part because Cells are relatively large, we avoid creating</span><br><span class="line">* them until they are needed.  When there is no contention, all</span><br><span class="line">* updates are made to the base field.  Upon first contention (a</span><br><span class="line">* failed CAS on base update), the table is initialized to size 2.</span><br><span class="line">* The table size is doubled upon further contention until</span><br><span class="line">* reaching the nearest power of two greater than or equal to the</span><br><span class="line">* number of CPUS. Table slots remain empty (null) until they are</span><br><span class="line">* needed.</span><br><span class="line">*</span><br><span class="line">* 4、设计cellsBusy锁的目的</span><br><span class="line">* A single spinlock (&quot;cellsBusy&quot;) is used for initializing and</span><br><span class="line">* resizing the table, as well as populating slots with new Cells.</span><br><span class="line">* There is no need for a blocking lock; when the lock is not</span><br><span class="line">* available, threads try other slots (or the base).  During these</span><br><span class="line">* retries, there is increased contention and reduced locality,</span><br><span class="line">* which is still better than alternatives.</span><br><span class="line">*</span><br><span class="line">* 5、Thread probe用于定位在Cells数组哪个桶位</span><br><span class="line">* The Thread probe fields maintained via ThreadLocalRandom serve</span><br><span class="line">* as per-thread hash codes. We let them remain uninitialized as</span><br><span class="line">* zero (if they come in this way) until they contend at slot</span><br><span class="line">* 0. They are then initialized to values that typically do not</span><br><span class="line">* often conflict with others.  Contention and&#x2F;or table collisions</span><br><span class="line">* are indicated by failed CASes when performing an update</span><br><span class="line">* operation. Upon a collision, if the table size is less than</span><br><span class="line">* the capacity, it is doubled in size unless some other thread</span><br><span class="line">* holds the lock. If a hashed slot is empty, and lock is</span><br><span class="line">* available, a new Cell is created. Otherwise, if the slot</span><br><span class="line">* exists, a CAS is tried.  Retries proceed by &quot;double hashing&quot;,</span><br><span class="line">* using a secondary hash (Marsaglia XorShift) to try to find a</span><br><span class="line">* free slot.</span><br><span class="line">*</span><br><span class="line">* 6、capped翻译为：用...封顶（盖住） Cells数组长度最大只能扩容到和CPU数量相同</span><br><span class="line">* The table size is capped because, when there are more threads</span><br><span class="line">* than CPUs, supposing that each thread were bound to a CPU,</span><br><span class="line">* there would exist a perfect hash function mapping threads to</span><br><span class="line">* slots that eliminates collisions. When we reach capacity, we</span><br><span class="line">* search for this mapping by randomly varying the hash codes of</span><br><span class="line">* colliding threads.  Because search is random, and collisions</span><br><span class="line">* only become known via CAS failures, convergence can be slow,</span><br><span class="line">* and because threads are typically not bound to CPUS forever,</span><br><span class="line">* may not occur at all. However, despite these limitations,</span><br><span class="line">* observed contention rates are typically low in these cases.</span><br><span class="line">*</span><br><span class="line">* 7、在Cells数组有些桶位的Cell可能没被线程命中用于CAS加值计数，但没关系，不用理会它，也不需要去找到这的Cell桶位然后删除之（画蛇添足）。</span><br><span class="line">* It is possible for a Cell to become unused when threads that</span><br><span class="line">* once hashed to it terminate, as well as in the case where</span><br><span class="line">* doubling the table causes no thread to hash to it under</span><br><span class="line">* expanded mask.  We do not try to detect or remove such cells,</span><br><span class="line">* under the assumption that for long-running instances, observed</span><br><span class="line">* contention levels will recur, so the cells will eventually be</span><br><span class="line">* needed again; and for short-lived ones, it does not matter.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文基于本博客已发布的CHM文章中分析fullAddCount方法基础上，介绍LongAdder这个高并发计数性能，并通过与原子计数器AtomicLong进行比较，最后给出Striped64类相关分析（因其内部真正实现了高并发计数逻辑）。&lt;/p&gt;
&lt;p&gt;为何需要介绍下LongAdder类？&lt;br&gt;因为在fullAddCount方法的定义上，因为在CHM源代码上，Doug Lea有提到：fullAddCount的设计原理可通过LongAdder这个类得到相关解释：：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// See LongAdder version for explanation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fullAddCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; wasUncontended)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 省略部分  ......&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1、两种并发计数器的性能比较&quot;&gt;&lt;a href=&quot;#1、两种并发计数器的性能比较&quot; class=&quot;headerlink&quot; title=&quot;1、两种并发计数器的性能比较&quot;&gt;&lt;/a&gt;1、两种并发计数器的性能比较&lt;/h4&gt;&lt;p&gt;longAdderCost和atomicLongCost的目的：指定一定数量的线程并发执行该逻辑：每个线程计数从0增加到1000*1000&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度讨论官方关于jdk1.8ConcurrentHashMap的computeIfAbsent源代码修复逻辑</title>
    <link href="https://yield-bytes.github.io/2021/10/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E5%AE%98%E6%96%B9%E5%85%B3%E4%BA%8Ejdk1.8ConcurrentHashMap%E7%9A%84computeIfAbsent%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91/"/>
    <id>https://yield-bytes.github.io/2021/10/10/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E5%AE%98%E6%96%B9%E5%85%B3%E4%BA%8Ejdk1.8ConcurrentHashMap%E7%9A%84computeIfAbsent%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2022-05-09T14:01:19.521Z</updated>
    
    <content type="html"><![CDATA[<p>在文章中《深度解析官方关于jdk1.8的resizeStamp的bug处理过程》，我们讨论关于CHM的核心设计——resizeStam需要修复的处理过程，本文再次基于openJDK的bugs讨论组提出的CHM源代码另外一个会造成死循环的bug，默认读者已经掌握CHM的核心源代码实现，否则无法从本文的讨论中获益。文章前部分先把computeIfAbsent的bug成因分析清楚，再来介绍官网<code>ConcurrentHashMap.computeIfAbsent stuck in an endless loop</code>的讨论过程，这样更容易看懂相关内容。</p><p>研究openJDK官方公布的相关源码bug有何“收益”：</p><p>虽然这些bug不是特别严重，修复起来也即几行代码，但如果想要解决这种看似“简单的bug”，要求对CHM设计原理、类、方法实现细节足够熟悉，也就是说，你要具备（至少在这个bug上下文的类、方法范围内）和源代码设计者同等思考视角才能去挖掘bug的本质原因并提出合理的修复建议。换句话说，你研究的不是这个bug本身，而是深入精通整个类的源代码实现，这种高级收益在日常业务开发几乎无法获得。</p><p><img src="https://img-blog.csdnimg.cn/e850dc9870704077af0bb9da6e7810c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>《gitee 博客文章封面》</p><h4 id="认识computeIfAbsent用法"><a href="#认识computeIfAbsent用法" class="headerlink" title="认识computeIfAbsent用法"></a>认识computeIfAbsent用法</h4><p>理解computeIfAbsent在一些场合下的用法，有助于帮助切入源代码分析。</p><h5 id="computeIfAbsent使用场景1："><a href="#computeIfAbsent使用场景1：" class="headerlink" title="computeIfAbsent使用场景1："></a>computeIfAbsent使用场景1：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeKeyLength</span><span class="params">(String key)</span></span>&#123; <span class="comment">// 计算key的长度，将其作为该key对应的value</span></span><br><span class="line">        <span class="keyword">return</span> key.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;foobar&quot;</span>,key-&gt;computeKeyLength(key));</span><br><span class="line">        System.out.println(map); <span class="comment">//输出 &#123;foobar=6, foo=1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>computeIfAbsent字面意思：如果key不在map里面，那么就使用给定的匿名函数（也叫映射函数）将key对应的value“计算出来”。（匿名函数也即lambda语法是jdk1.8语法新特性，这一点不必多说）</p><p>按这个思路可以有以下解释：</p><a id="more"></a><p>因为字符串”foobar”这个key不在map里面，因此把它放入map的同时，对应的value要用给定的函数computeKeyLength计算出来，例如这里调用computeKeyLength计算值为6，因此有key=foobar，value=6，将其放入map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;bar&quot;</span>,<span class="number">10</span>);</span><br><span class="line">map.computeIfAbsent(<span class="string">&quot;bar&quot;</span>,key-&gt;computeKeyLength(key));</span><br><span class="line">System.out.println(map); <span class="comment">// 输出：&#123;bar=10&#125;</span></span><br></pre></td></tr></table></figure><p>若key已经在map时，value不会被<code>computeKeyLength(key)</code>的计算值6所覆盖。</p><p>当然此demo做了一个不优雅的示范：既然可用匿名函数的写法去写逻辑，就没必要基于方法computeKeyLength去封装多一层，最简便写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfAbsent(<span class="string">&quot;foobar&quot;</span>,key-&gt;key.length());</span><br></pre></td></tr></table></figure><p>注意这个key可以作为匿名函数的入参去参与到计算value，也可以不作为匿名函数的入参，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfAbsent(&quot;foobar&quot;,key-&gt;10);</span><br></pre></td></tr></table></figure><p>显然foobar=10。</p><h5 id="computeIfAbsent使用场景2："><a href="#computeIfAbsent使用场景2：" class="headerlink" title="computeIfAbsent使用场景2："></a>computeIfAbsent使用场景2：</h5><p>并发场景下的频率统计：该demo方法其实在并发计数器LongAdder这个类的源码注释里面，Doug Lea已经告诉我们一个经典的场景恰好需要使用computeIfAbsent方法</p><blockquote><p>LongAdders can be used with a java.util.concurrent.ConcurrentHashMap to maintain a scalable frequency map (a form of histogram or multiset). For example, to add a count to a ConcurrentHashMap<String,LongAdder> freqs, initializing if not already present, you can use freqs.computeIfAbsent(k -&gt; new LongAdder()).increment();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String,LongAdder&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        String[] strings=&#123;<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>,<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;foo&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String key : strings) &#123;</span><br><span class="line">           map.computeIfAbsent(key,k-&gt; <span class="keyword">new</span> LongAdder()).increment();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map); <span class="comment">//输出 &#123;bar=1, foo=3&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该demo虽然只是用单个线程去执行computeIfAbsent，但逻辑是清晰的：实现对字符串出现次数进行统计</p><ul><li>关于LongAdder的分析，它内部其实有一个像ConcurrentHashMap的fullAddCount并发计数逻辑，这里不再讨论，有关研究可参考本博客的文章《Java并发进阶系列：LongAdder高并发计数性能分析》</li></ul><h5 id="computeIfAbsent方法源码解析"><a href="#computeIfAbsent方法源码解析" class="headerlink" title="computeIfAbsent方法源码解析"></a>computeIfAbsent方法源码解析</h5><p>这部内容要求读者已经掌握jdk1.8的ConcurrentHashMap设计及其关键方法的源代码实现逻辑，否则将难以理解其含义。本节所提的computeIfAbsent是未修复前的版本，这里并不会详细解析computeIfAbsent每一行代码，因为它跟putVal方法逻辑几乎一样，而不同地方可参考以下数字标记的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException()</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode()); </span><br><span class="line">    V val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//看到这个写法应该很熟悉了：自旋+cas机制，为啥要自旋，因为线程不保证自己一次cas就成功，如果和其他线程竞争失败，则需要重试cas，这就是“自旋+cas机制”的黄金搭配。</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>) &#123; </span><br><span class="line">          <span class="comment">//① 如果key对应的桶位为空，先创建一个保留节点用于接下里的占位逻辑</span></span><br><span class="line">            Node&lt;K,V&gt; r = <span class="keyword">new</span> ReservationNode&lt;K,V&gt;();</span><br><span class="line">          <span class="comment">// ②当前线程用保留节点占位当然需要借用独占锁对r对象进行加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (r) &#123;</span><br><span class="line">              <span class="comment">// 在当前桶位放置保留节点用于占位，占位之后就可以给该桶位放入新建的node节点</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, r)) &#123;</span><br><span class="line">                    binCount = <span class="number">1</span>;</span><br><span class="line">                    Node&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">/*putVal在桶位为空时的逻辑，可看到非常简单，直接使用cas给当前桶位设置新节点，value是给定的value，不需要通过函数计算出value</span></span><br><span class="line"><span class="comment">  if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null))) &#123;</span></span><br><span class="line"><span class="comment">  break;  </span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">                      <span class="comment">// 对于computeIfAbsent，value是需要用给定的匿名函数计算出的，正如前面场景1的“bar”这个key对应的“value”就是使用computeKeyLength(key)计算处理的值</span></span><br><span class="line">                        <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>)</span><br><span class="line">                            node = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//虽然在②步骤那里已经在桶位i放置了一个ReservationNode用于占位，到了这个步骤才是真正把数据节点node放入桶位i当中</span></span><br><span class="line">                        setTabAt(tab, i, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 显然②步骤一定能成功在桶位i放入node节点（binCount=1），既然已经将key和value放入map，那么任务完成，当前线程退出自旋</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//③如果key定位到的桶位i恰好是一个ForwardingNode占位节点，那么当前线程要去参与“帮助扩容”的逻辑，这里跟putval一样。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//代码若执行到这，说明桶位i是一个链表或者一棵红色树 </span></span><br><span class="line">            <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 当前线程先给头节点加独占锁，保证当前线程写入节点操作时的独占性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">      <span class="comment">//并发环境，这里当然还要二次检查头节点是不是刚刚加锁前的头节点（也即检查加锁前后的头节点有无被改动过）</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                     <span class="comment">// ④f节点是链表的情况</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek; V ev;</span><br><span class="line">                            <span class="comment">// 在链表中遇到相同的key，那么就不做更新value操作，返回旧value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                val = e.val;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          <span class="comment">// 尾插法：来到链表尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               <span class="comment">// key不在链表时，value则由给定的匿名函数计算而来</span></span><br><span class="line">                                <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    added = <span class="keyword">true</span>;</span><br><span class="line">                                    <span class="comment">//尾插法</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// ④f节点是TreeBin的情况（该桶位是一棵红黑树）</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                     </span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(h, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>)</span><br><span class="line">                            val = p.val;</span><br><span class="line">                       <span class="comment">// key不在树里面时，value则由给定的匿名函数计算而来</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            added = <span class="keyword">true</span>;</span><br><span class="line">                            t.putTreeVal(h, key, val);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (!added)</span><br><span class="line">                    <span class="keyword">return</span> val;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  //以下两行是putVal的逻辑：CHM添加一个节点后，需要对size加1计数</span></span><br><span class="line"><span class="comment">    addCount(1L, binCount);</span></span><br><span class="line"><span class="comment">    return null;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (val != <span class="keyword">null</span>)</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> val;<span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相信经过以上“可理解的场景使用和源代码分析”，computeIfAbsent应该能掌握了，下面进入官方bug解析的流程，具有较高水平的知识点，值得阅读！</p><h4 id="an-endless-loop"><a href="#an-endless-loop" class="headerlink" title="an endless loop"></a>an endless loop</h4><p>具体提交页面参考<a href="https://bugs.openjdk.java.net/browse/JDK-8062841">官方bug描述页面</a></p><p>问题：ConcurrentHashMap.computeIfAbsent stuck in an endless loop</p><p>该提交者提交方式是那种示范性的提问方式，提供较为详细的辅助信息：jdk版本、操作系统信息、问题描述、以及复现bug的测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> at.irian.misc.javabug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.computeIfAbsent(</span><br><span class="line">                <span class="string">&quot;AaAa&quot;</span>,</span><br><span class="line">          <span class="comment">// 建议改写为 k1-&gt; map.computeIfAbsent(&quot;BBBB&quot;,k2-&gt;42)，相对直观易懂</span></span><br><span class="line">                key -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> map.computeIfAbsent(<span class="string">&quot;BBBB&quot;</span>,key2 -&gt; <span class="number">42</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               </span><br></pre></td></tr></table></figure><p>有了前面computeIfAbsent用法的介绍，提交者提交的测试代码其实很好理解：</p><p>“AaAa”对应的value需要根据<code>map.computeIfAbsent(&quot;BBBB&quot;,key2 -&gt; 42)</code>计算出来，易知value返回的是42</p><p>本来期待map的结果是<code>&#123;AaAa=42,BBBB=42&#125;</code>，当执行时，发现程序“卡住了”不能结束，说明bug已复现，但如何一步一步追踪它呢？</p><p>考虑到提交者的测试代码写得比较一般，比如匿名函数写个return显然是多余的，再例如为了制造两个key哈希冲突，写了个“AaAa”、“BBBB”，这当然无大碍，只是看起来有点“Counterintuitive”，因此这里给出相对容易接受的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;Name, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.computeIfAbsent(</span><br><span class="line">                <span class="keyword">new</span> Name(<span class="string">&quot;foo&quot;</span>),</span><br><span class="line">                k1-&gt; map.computeIfAbsent(<span class="keyword">new</span> Name(<span class="string">&quot;bar&quot;</span>),k2-&gt;<span class="number">10</span>)</span><br><span class="line">          <span class="comment">/*或者使用 k1-&gt; map.computeIfAbsent(new Name(&quot;bar&quot;),k2-&gt; k2.key.length()) </span></span><br><span class="line"><span class="comment">          这里的k2是指new Name(&quot;bar&quot;)，那么k2.key就是“bar”这个字符串，那么k2.key.length()就是</span></span><br><span class="line"><span class="comment">          计算k2里面字符串的长度，预期输出结果为&#123;bar=3,foo=3&#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个Name对象，用于作为map的key</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        Name(String key)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 重写hashCode方法，保证每个不同key计算的哈希值都一样，目的是让不同的key直接在同一桶位上发生哈希冲突，以便观察bug的执行流程。显然根据桶位计算方法：i = (16 - 1) &amp; 1，由此可知，不同Name的key都会在桶位1上发生冲突。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>new Name(&quot;foo&quot;)</code>和<code>new Name(&quot;bar&quot;)</code>这两个不同key，其哈希值都是1，期待运行结果：<code>&#123;foo=10,bar=10&#125;</code>,实际运行结果：程序陷入了死循环，复现了源代码的bug。</p><h4 id="深挖原因"><a href="#深挖原因" class="headerlink" title="深挖原因"></a>深挖原因</h4><p>借助IDEA debug即可完成此任务。在computeIfAbsent的以下代码处打上断点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>) &#123; <span class="comment">//这行不是断点位置 </span></span><br><span class="line">    Node&lt;K,V&gt; r = <span class="keyword">new</span> ReservationNode&lt;K,V&gt;(); <span class="comment">// 这行是断点位置</span></span><br></pre></td></tr></table></figure><p>根据Name的固定hash值可知道，当首次执行将<code>new Name(&quot;foo&quot;)</code>放入桶位时，程序第一循环先完成table的初始化创建，即如下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">  <span class="comment">// ① 第1次循环，table为空，因此需要执行初始化逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        tab = initTable();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>table的初始化之后，进行第2次循环，会进入到以下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ② 第2次循环，会进入此逻辑，这好理解，因为new Name(&quot;foo&quot;)这个key的哈希值为1，首次放入key之前，桶位1的头节点f一定是null的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; r = <span class="keyword">new</span> ReservationNode&lt;K,V&gt;(); <span class="comment">//这行是断点位置</span></span><br><span class="line">            <span class="keyword">synchronized</span> (r) &#123; <span class="comment">// ③</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, r)) &#123;</span><br><span class="line">                    binCount = <span class="number">1</span>;</span><br><span class="line">                    Node&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>以上两点是要说明：运行debug时虽然执行流会马上停在断点代码位置，但在暂停前，代码已经执行完第1次循环（初始化操作）和正在进行第2次循环</p><p>因为CHM是并发的，因此进入加锁区后不是先把new Name(“foo”)这个节点直接放入桶位1中，而是先放一个保留节点用于占位（好让其他线程看到该桶位是一个保留节点后就转去做其他事情），然后才进入以下try代码区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>)<span class="comment">// ④</span></span><br><span class="line">        node = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    setTabAt(tab, i, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记④位置的代码就是揭开bug的关键入口点，在try代码块里面，new Name(“foo”)这个key的value是用指定的匿名函数（或者称为映射函数）计算出来，因此④位置代码是调用给定匿名函数去计算value，如果Step Into到这个位置，那么接下来再继续Step Into就会来测试代码这一位置<code>k1-&gt; map.computeIfAbsent(new Name(&quot;bar&quot;),k2-&gt;10)</code>：</p><p>说明new Name(“foo”)这个key要想放入桶位1，得先等<code>map.computeIfAbsent(new Name(&quot;bar&quot;),k2-&gt;10)</code>逻辑执行完成。</p><p>从Frames的线程方法调用栈也可以看出相关逻辑：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6c404db5015738104b55964eeeb0db55.png" alt="computeIfAbsent_1"></p><p>继续Step Into操作当然是再次进入computeIfAbsent方法内部，接下来，对于key为<code>new Name(&quot;bar&quot;)</code>，显然它也能定位到桶位1，接下来好办，进入for循环（自旋）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span> || remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">      V val = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">          <span class="comment">//① table已不为空，所以执行流不会进入此逻辑</span></span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br><span class="line">        <span class="comment">//② 执行第一次computeIfAbsent时，桶位1被放置了一个保留节点，因此桶位1不再为空，所以执行流不会进入此逻辑。注意注意：此桶位1还未放入new Name(&quot;foo&quot;)这个节点！因为new Name(&quot;foo&quot;)还在等new Name(&quot;bar&quot;)这个key计算value</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//③ 桶位1放的是一个保留节点ReservationNode，显然不是ForwardingNode节点，所以执行流不会进入此逻辑。</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)&#123;&#125;</span><br><span class="line">        <span class="comment">//④ 前面三个条件不满足，执行流最终会进入此逻辑，这里解析bug的关键逻辑！</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.1</span></span><br><span class="line">            <span class="comment">//4.2</span></span><br><span class="line">            <span class="comment">//4.3</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>继续深入④逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//④ 前面三个条件不满足，执行流最终会进入此逻辑，这里解析bug的关键逻辑！</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//对桶位上的头节点f加独占锁（这个f节点显然还是new Name(&quot;foo&quot;)放入的保留节点ReservationNode）</span></span><br><span class="line">  <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">    <span class="comment">//4.1 f是ReservationNode节点显然不是链表，所以执行流不会进入此逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                binCount = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                    K ek; V ev;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == key ||</span><br><span class="line">                         (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                        val = e.val;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Node&lt;K,V&gt; pred = e;</span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            added = <span class="keyword">true</span>;</span><br><span class="line">                            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//4.2 f是ReservationNode节点,显然也不是TreeBin节点，所以执行流不会进入此逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                binCount = <span class="number">2</span>;</span><br><span class="line">                TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (p = r.findTreeNode(h, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>)</span><br><span class="line">                    val = p.val;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    added = <span class="keyword">true</span>;</span><br><span class="line">                    t.putTreeVal(h, key, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//4.3 程序执行到这里发现都无法满足以上条件来放入new Name(&quot;bar&quot;)节这个节点，而new Name(&quot;foo&quot;)这个key又在等待new Name(&quot;bar&quot;)计算value的返回值，也即当前桶位还未放入这两个key节点，因此binCount还是初始值0，所以执行流不会进入此逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">            treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (!added)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑤ 执行流回到for循环继续，接下来就是一直死循环了</span></span><br></pre></td></tr></table></figure><p>总结以上流程，用骨架代码解释死循环发生的过程：</p><p>对于new Name(“bar”)这个节点进入computeIfAbsent后，发生以下循环问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">          <span class="comment">//① table已不为空，所以执行流不会进入此逻辑</span></span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br><span class="line">        <span class="comment">//② 执行第一次computeIfAbsent时，该桶位已经是ReservationNode节点，所以执行流不会进入此逻辑！</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">//③ f是ReservationNode节点不是fwd节点，所以执行流不会进入此逻辑</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)&#123;&#125;</span><br><span class="line">        <span class="comment">//④ 前面三个条件不满足，执行流最终会进入此逻辑，这里解析bug的关键逻辑！</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.1 f是ReservationNode节点不是链表，所以执行流不会进入此逻辑</span></span><br><span class="line">            <span class="comment">//4.2 f是ReservationNode节点不是TreeBin节点，所以执行流不会进入此逻辑</span></span><br><span class="line">            <span class="comment">//4.3 binCount还是初始值0，所以执行流不会进入此逻辑</span></span><br><span class="line">            <span class="comment">// 回到for循环：接下里即陷入死循环</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>有没发现当准备为new Name(“bar”)节点找满足条件来插入节点时，发现for循环里面的7个条件（①、②、③、④、4.1、4.2、4.3)）都不满足，那执行流接下里怎么办？ 只能继续下一轮循环，下一轮循依旧出现7个条件都不满足只能再继续循环，因此进入了死循环陷阱。</p><p>本质原因是map写入节点的操作恰好同时满足以下两个条件：</p><p>（1）两个key定位到相同的桶位（hash冲突）</p><p>（2）一个key调用<code>map.computeIfAbsent</code>计算value的过程中又递归调用<code>map.computeIfAbsent</code>计算另外一个key的value</p><h4 id="使用jstack定位死循环位置"><a href="#使用jstack定位死循环位置" class="headerlink" title="使用jstack定位死循环位置"></a>使用jstack定位死循环位置</h4><p>既然已经掌握computeIfAbsent出现无限循环的原理，那么当发生无限循环时，可以使用jstack快速定位位置。</p><p>使用top -u 查看cpu使用率最高的进程号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ top -u </span><br><span class="line">PID    COMMAND      %CPU  TIME     #TH   #WQ  #PORTS MEM    PURG   CMPRS  PGRP  PPID  STATE</span><br><span class="line">40929  java         90.5  00:31.31 18&#x2F;1  1    75     17M    0B     0B     8828  8828  running</span><br></pre></td></tr></table></figure><p>再使用jps打印所有java进程执行，进程号40929对应的主类是Demo3，因此进程号40929就是目标处理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> kevent@MacBookPro  ~  jps</span><br><span class="line">40928 Launcher</span><br><span class="line">40929 Demo3</span><br><span class="line">40967 Jps</span><br><span class="line">8828</span><br></pre></td></tr></table></figure><p>使用jstack打印40929进程里面的所有线程方法调用栈信息并输出文件中（把信息放在文本中方便查阅，否则直接在terminal打印不方便分析）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l 40929 &gt; 40929.txt  # -l选项表示长列表，会打印出更为详细关于锁的信息（如果有死锁被被监测到并打印出来）</span><br></pre></td></tr></table></figure><p>如果程序fork了很多线程，还需要使用<code>top -H -p pid</code>来定位哪个线程的cpu使用率最高，然后再用线程号去jstack 输出文本里面grep到对应线程的调用栈信息。</p><p>打印出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~ jstack -l 40929</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line"># 省略其他输出</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio&#x3D;5 os_prio&#x3D;31 tid&#x3D;0x00007fc89300b000 nid&#x3D;0x1003 runnable [0x0000700009038000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at concurrent.demo.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1747)</span><br><span class="line">at concurrent.demo.Demo3.lambda$main$1(Demo3.java:7)</span><br><span class="line">at concurrent.demo.Demo3$$Lambda$1&#x2F;250421012.apply(Unknown Source)</span><br><span class="line">at concurrent.demo.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1688)</span><br><span class="line">- locked &lt;0x0000000795864ea0&gt; (a concurrent.demo.ConcurrentHashMap$ReservationNode)</span><br><span class="line">at concurrent.demo.Demo3.main(Demo3.java:5)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">- None</span><br><span class="line"># 省略其他输出</span><br></pre></td></tr></table></figure><p>Demo3执行后一直“卡着”并不会结束运行，上面显示main主线程，它的状态是RUNNABLE，这个正是说明当前Demo3一直在运行中没有结束。以下内容是主线程的方法调用栈，可以看到栈顶的computeIfAbsent方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">at concurrent.demo.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1747)</span><br><span class="line">at concurrent.demo.Demo3.lambda$main$1(Demo3.java:7)</span><br><span class="line">at concurrent.demo.Demo3$$Lambda$1&#x2F;250421012.apply(Unknown Source)</span><br><span class="line">at concurrent.demo.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1688)</span><br><span class="line">- locked &lt;0x0000000795864ea0&gt; (a concurrent.demo.ConcurrentHashMap$ReservationNode)</span><br><span class="line">at concurrent.demo.Demo3.main(Demo3.java:5)</span><br></pre></td></tr></table></figure><p>(ConcurrentHashMap.java:1747)信息很关键，它指出死循环发生在ConcurrentHashMap.java源代码文件的1747行，接着你可以在源代码文件相应位置加个打印语句<code>System.out.println(&quot;dead loop&quot;);</code>看看是否是这个是位置有死循环``，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6817b340064cd6fe400a5846be97c467.png" alt="computeIfAbsent_2"></p><p>源代码能编辑的前提是你对IDEA的Sourcepath做了设置，至于如何设置，这些小trick不再说明。</p><p>再次执行Demo3时，则会一直打印<code>dead loop</code>，这种方式看起来也让其死循环行为更为直观。</p><h4 id="openJDK官方的讨论过程"><a href="#openJDK官方的讨论过程" class="headerlink" title="openJDK官方的讨论过程"></a>openJDK官方的讨论过程</h4><p>有了以上对computeIfAbsent全面的解析，则可以更好理解openJDK的官方讨论过程，<a href="https://bugs.openjdk.java.net/browse/JDK-8062841">参考此提交页面</a></p><p>1、<a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dl">Doug Lea</a> added a comment - 2014-11-04 11:21</p><p>Doug Lea说自己没有一个好的方式去诊断CHM就此出现的问题，他猜测是否是线程在执行<code>computing value</code>逻辑时stuck住了，但从提交者的描述来看又无法确定这点。</p><blockquote><p>I do not see a way to diagnose if there is a CHM problem here. The reservation mentioned may exist if some other thread is stuck while computing value, but there is no way to determine this from description.</p></blockquote><p>你可以理解为Doug Lea对此bug暂无解决思路（未能在短时间内想起哪个逻辑出现问题），这是因为提交者首次提bug时没有附上“可复现bug的代码文件”，仅根据贴上的基本描述无法清晰指出问题所在。</p><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=pardesha">Pardeep Sharma</a> added a comment - 2014-12-03 03:58</p><blockquote><p>Response from the submitter:<br>“I’ve been investigating the bug further in the mean time and I have a<br>minimal example (see attachment). </p><p>The problem is that we’re doing a computeIfAbsent within another<br>computeIfAbsent with an object that has accidentally the same hashCode<br>(in the attached example “AaAa” and “BBBB” also have same hashCode). </p><p>The documentation states that this is forbidden (mistake on our side)<br>but it also states that this should throw “IllegalStateException - if<br>the computation detectably attempts a recursive update to this map<br>that would otherwise never complete”. This is not the case. </p><p>I would suggest that either<br>a) the documentation is adjusted to make it more clear that the<br>IllegalStateException is thrown on best effort basis.<br>or<br>b) the implementation is adjusted so that the IllegalStateException is<br>really thrown.”</p></blockquote><p>这部分内容很关键，提交者补充了准确的描述、修复意见和可复现bug的代码文件，补充的内容大概意思如下：</p><p>（1）bug产生的原因：map.computeIfAbsent里面的value再次调用computeIfAbsent，而且两个computeIfAbsent对应的key恰好hash冲突</p><p>（2）提出computeIfAbsent方法官方注释虽然提到禁止使用这种递归调用computeIfAbsent的用法，提交者认为更合理的方式是抛出：IllegalStateException</p><p>（3）提出源代码修复建议  a)注释里面尽可能对IllegalStateException抛出情况写清楚点   b)调整代码逻辑使得遇到此类情况可抛出<code>IllegalStateException</code></p><p>3、<a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dl">Doug Lea</a> added a comment - 2014-12-22 05:46</p><blockquote><p>Ignore my previous comment. We discovered some feasible diagnostic improvements that cover more user errors involving recursive map updates by functions supplied in computeIfAbsent, including the case attached in this report. </p><p>Pending any further discussion on concurrency-interest, we should integrate to JDK9, then 8u.</p></blockquote><p>在距离该bug提交时间（11-04）48天后（当然这里不是指Doug Lea每天思考该问题总共用了48天才找出如何解决），<a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dl">Doug Lea</a> 终于搞懂bug的发生逻辑，也谦虚说忽略他之前给出的评论意见，说他们能找到问题的所在，并有该bug复现的case。提到之后如果有关于concurrency相关的讨论（修复）都应该优先在jdk9完成，然后再去处理jdk8u版本。</p><h4 id="源代码修复说明"><a href="#源代码修复说明" class="headerlink" title="源代码修复说明"></a>源代码修复说明</h4><p>在这里不妨假设还是按照上面<code>an endless loop</code>章节在分析递归调用<code>new Name(&quot;bar&quot;)</code>的computeIfAbsent发生的循环逻辑，把整个执行流程放到以下修复后代码中去考察：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">         Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">         <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">             tab = initTable();</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)&#123;&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)&#123;&#125;      </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                   <span class="comment">//4.1 f是ReservationNode节点不是链表，所以执行流不会进入此逻辑</span></span><br><span class="line">                     <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                         binCount = <span class="number">1</span>;</span><br><span class="line">                         <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                             K ek;</span><br><span class="line">                             <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                                 ((ek = e.key) == key ||</span><br><span class="line">                                  (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                 val = e.val;</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                             Node&lt;K,V&gt; pred = e;</span><br><span class="line">                             <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         <span class="comment">// 新增的修复代码，链表这边也可能会出现递归调用，也需要直接抛出异常。为何这里也会出现</span></span><br><span class="line">                                     <span class="keyword">if</span> (pred.next != <span class="keyword">null</span>)</span><br><span class="line">                                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                                     added = <span class="keyword">true</span>;</span><br><span class="line">                                     pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                   <span class="comment">//4.2 f是ReservationNode节点不是TreeBin节点，所以执行流不会进入此逻辑</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                         binCount = <span class="number">2</span>;</span><br><span class="line">                         TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                         TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                         <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (p = r.findTreeNode(h, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>)</span><br><span class="line">                             val = p.val;</span><br><span class="line">                         <span class="keyword">else</span> <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             added = <span class="keyword">true</span>;</span><br><span class="line">                             t.putTreeVal(h, key, val);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                   <span class="comment">// 4.3 新增的修复代码</span></span><br><span class="line">                   <span class="comment">// 在第一次computeIfAbsent执行时new Name(&quot;foo&quot;) 就是通过独占锁在桶位放置了一个ReservationNode然后等待new Name(&quot;bar&quot;) 的返回，而new Name(&quot;bar&quot;) 执行computeIfAbsent时来到相同桶位，此时桶位显然是一个ReservationNode，满足判断条件，故直接抛出异常使得线程终止运行，而不是继续下一轮遍历，解决了死循环。</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>当然这种有递归更新操作的修复不单单只在computeIfAbsent方法修改，还有其他方法内部都需要修改，具体参考他们给出的<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.258&amp;r2=1.259&amp;sortby=date">修复前后diff链接</a>。</p><p>Doug Lea除了修复这个死循环的问题，他还给出了一个提高computeIfAbsent性能的修复，<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.295&amp;r2=1.296&amp;sortby=date">修复前后diff连接</a></p><p>Improve already-present performance in computeIfAbsent, putIfAbsent</p><blockquote><p>Revision <strong>1.296</strong> - (<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?revision=1.296&amp;view=markup&amp;sortby=date">view</a>) (<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?annotate=1.296&amp;sortby=date">annotate</a>) - <strong>[selected]</strong><br><em>Sun Jul 17 12:09:12 2016 UTC</em> (5 years ago) by <em>dl</em><br>Branch: <a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?view=log&amp;sortby=date&amp;pathrev=MAIN"><strong>MAIN</strong></a><br>Changes since <strong>1.295: +10 -2 lines</strong><br>Diff to <a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.295&amp;r2=1.296&amp;sortby=date">previous 1.295</a></p></blockquote><p>其实也很简单，正如注释所说：check first node without acquiring lock，在无需加锁情况下，快速判断头节点是否和给定key相同，如相同则无须更新value，直接返回头节点原value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fh == h    <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">         &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">         &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> fv;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>有了以上全文内容的理解，再来回顾computeIfAbsent的源代码注释则能理解它要强调的重点！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If the specified key is not already associated with a value,</span></span><br><span class="line"><span class="comment"> * attempts to compute its value using the given mapping function</span></span><br><span class="line"><span class="comment"> * and enters it into this map unless &#123;<span class="doctag">@code</span> null&#125;.  The entire</span></span><br><span class="line"><span class="comment"> * method invocation is performed atomically.  The supplied</span></span><br><span class="line"><span class="comment"> * function is invoked exactly once per invocation of this method</span></span><br><span class="line"><span class="comment"> * if the key is absent, else not at all.  (key不在map的情况下，给定的映射函数只会调用一次用来计算key对应的value)</span></span><br><span class="line"><span class="comment"> *Some attempted update operations on this map by other threads may be blocked while</span></span><br><span class="line"><span class="comment"> * computation is in progress, so the computation should be short</span></span><br><span class="line"><span class="comment"> * and simple.（给key调用映射函数计算value的过程中可能阻塞其他线程，因此这个“映射函数”的计算逻辑尽可能短、简单，例如key对应的value需要用10秒才计算完那么put这个key时显然会导致其他线程需要等待10秒才能继续后续写操作）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The mapping function must not modify this map during computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction the function to compute a value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current (existing or computed) value associated with</span></span><br><span class="line"><span class="comment"> *         the specified key, or null if the computed value is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or mappingFunction</span></span><br><span class="line"><span class="comment"> *         is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the computation detectably</span></span><br><span class="line"><span class="comment"> *         attempts a recursive update to this map that would</span></span><br><span class="line"><span class="comment"> *         otherwise never complete</span></span><br><span class="line"><span class="comment"> （抛出IllegalStateException就是修复的内容：如果检测到递归更新，如本文提供Demo3案例，则会抛出这个异常错误）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException or Error if the mappingFunction does so,</span></span><br><span class="line"><span class="comment"> *         in which case the mapping is left unestablished</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><p>掌握computeIfAbsent实现以及bug修复原理，你可以猜到HashMap、TreeMap、Hashtable等computeIfAbsent是如何处理吗？</p><p>这是一个陷阱式提问，显然HashMap、TreeMap、Hashtable的computeIfAbsent是不可能发生死循环，因为它们的computeIfAbsent源代码实现里面就不存在<code>for循环（自旋）+CAS</code>这套操作，而且HashMap、TreeMap这些也不是设计用于并发环境。</p><p>此外jdk1.8的ConcurrentHashMap的computeIfAbsent死循环的bug还引起阿里的分布式事务Seata框架发生同样的bug，文章为<a href="https://seata.io/zh-cn/blog/seata-dsproxy-deadlock.html">《ConcurrentHashMap导致的Seata死锁问题》</a>，文章发布时间很新，2021年3月13日。写这篇深度分析文章的作者是Seata开发者之一，很不错，该文适合已经具有微服务下的分布式事务开发经验的同学研究。</p><h4 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h4><p>在“源代码修复diff说明”章节，代码修复只解释4.3新增的修复代码，眼尖的同学也许发现了4.1的链表也新增的修复代码而4.2的TreeBin里面确无需修改，这两部分的修复逻辑为何是这么处理呢？</p><h5 id="讨论4-1位置指出的链表片段代码的修复思路"><a href="#讨论4-1位置指出的链表片段代码的修复思路" class="headerlink" title="讨论4.1位置指出的链表片段代码的修复思路"></a>讨论4.1位置指出的链表片段代码的修复思路</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> added = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  <span class="comment">//4.1 f是ReservationNode节点不是链表，所以执行流不会进入此逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                val = e.val;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 新增的修复代码，链表这边也可能会出现递归调用，也需要直接抛出异常。为何这里也会出现</span></span><br><span class="line">                                    <span class="keyword">if</span> (pred.next != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                                    added = <span class="keyword">true</span>;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>首先应该可以猜到，既然Doug Lea 修复了它，说明链表里面肯定存在递归更新（且哈希冲突下的递归更新），但会出现类似ReservationNode的死循环bug吗？还是有其他不一样的情况？这里再次设计相关复现代码以解释之，Demo4如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        ConcurrentHashMap&lt;Name, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Name(<span class="string">&quot;a0&quot;</span>),<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Name(<span class="string">&quot;a1&quot;</span>),<span class="number">2</span>);</span><br><span class="line">        map.computeIfAbsent(<span class="keyword">new</span> Name(<span class="string">&quot;a2&quot;</span>),k1-&gt;map.computeIfAbsent(<span class="keyword">new</span> Name(<span class="string">&quot;a3&quot;</span>),k2-&gt;k2.key.length()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        Name(String key)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上预期打印结果：{a0=1,a1=2,a3=2,a2=2}</p><p>实际输出为：{a0=1, a1=2, a2=2}</p><p>原因分析如下图所示：<br><img src="https://img-blog.csdnimg.cn/f37ea7b269f04b09b9dc2e867aeeb67d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>以上图示说明的是在链表中出现computeIfAbsent递归调用的bug并不会出现类似前面ReservationNode引起的死循环，而是出现“节点被覆盖”的bug，因此需要修复，修复的代码也很好处理：<font color=red>依据上图思路，在Time4时刻先判断此刻<code>pred.next</code>是否还是Time2时刻时的情况，即<code>pred.next=null</code>，如果不为空，说明在Time3时刻，递归调用了computeIfAbsent导致pred.next指向一个新增节点，出现了“inconsistent read”，这种情况很像mysql的“不可重复读”：</font></p><p>事务A在第一次读和第二次读的结果不一样，是因为在第一次和第二次读的中间时刻，有事务B对目标记录修改，导致事务A在一个事务内两次读到的数据不一样，也即不可重复读。</p><p>按这里的思路套入“上图中链表的不可重复读”：线程A第一次computeIfAbsent读取的<code>pred.next</code>为空，接着有线程A第一次computeIfAbsent内部再调用第二个computeIfAbsent对<code>pred.next</code>修改指向了一个非空新增节点，之后当线程A返回到执行第一次computeIfAbsent中断位置继续执行，发现第二次读取的<code>pred.next</code>不为空，那么线程A此时应该抛出异常，这就是Doug Lea对链表出现递归调用computeIfAbsent的修复策略，修复源代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Node&lt;K,V&gt; pred = e;</span><br><span class="line"><span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">//这里可以看做是线程A第一次读取pred.next,显然此刻pred.next是指向null</span></span><br><span class="line">    <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 新增的修复代码：线程A第二次读pred.next，如果此刻pred.next指向为null，说明本次computeIfAbsent内部没递归调用computeIfAbsent，是合法插入节点的操作，此时可以放心让pred.next指向新增节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred.next != <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">// 如果线程A第二次读pred.next不为空，说明本次computeIfAbsent递归调用computeIfAbsent，直接抛出IllegalStateException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">        <span class="comment">// 线程A第二次读pred.next，如果此刻pred.next指向为null，说明本次computeIfAbsent内部没递归调用computeIfAbsent是合法插入节点的操作，此时可以放心让pred.next指向新增节点new Node。</span></span><br><span class="line">        added = <span class="keyword">true</span>;</span><br><span class="line">        pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(h, key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程下的computeIfAbsent递归结果其实跟单线程一样，但肯定不会出现死循环，有余力的同学可以自行分析或者debug。</p><h5 id="讨论4-2-位置TreeBin部分的修复思路"><a href="#讨论4-2-位置TreeBin部分的修复思路" class="headerlink" title="讨论4.2 位置TreeBin部分的修复思路"></a>讨论4.2 位置TreeBin部分的修复思路</h5><p>对比jdk1.8和jdk16的TreeBin片段前后，发现源代码无需修复，这是又是为何呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">//4.2 f是ReservationNode节点不是TreeBin节点，所以执行流不会进入此逻辑</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                  binCount = <span class="number">2</span>;</span><br><span class="line">                  TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                  TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                  <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (p = r.findTreeNode(h, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>)</span><br><span class="line">                      val = p.val;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> ((val = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      added = <span class="keyword">true</span>;</span><br><span class="line">                      t.putTreeVal(h, key, val);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="comment">//4.3 新增的修复，处理ReservationNode引起的死循环bug</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>有了前面链表的分析积累，很好理解为何TreeBin无需担心递归更新带来的问题，因为它不会发生这样的bug，下面给出Demo5以及详细可理解的分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;Name, Integer&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// put64个节点触发扩容并会树化红黑树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> Name(<span class="string">&quot;a&quot;</span>+i),i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 测试b2节点会不会像链表那边被b1节点覆盖</span></span><br><span class="line">        map.computeIfAbsent(<span class="keyword">new</span> Name(<span class="string">&quot;b1&quot;</span>),k1-&gt;map.computeIfAbsent(<span class="keyword">new</span> Name(<span class="string">&quot;b2&quot;</span>),k2-&gt;k2.key.length()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        Name(String key)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>详细图解：<br><img src="https://img-blog.csdnimg.cn/e850dc9870704077af0bb9da6e7810c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>相信能读懂本文的同学，应该会受益匪浅，此外，网上也有coder能写出关于官方处理computeIfAbsent的修复过程解析，但他们基本停留在<code>ReservationNode</code>这一点上，而关于链表片段代码的修复以及红黑树部分片段维持不修复的本质原因却没有给出深度解读，这两点作为computeIfAbsent核心设计，肯定需要深挖为何如何修复或不修复的原因。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在文章中《深度解析官方关于jdk1.8的resizeStamp的bug处理过程》，我们讨论关于CHM的核心设计——resizeStam需要修复的处理过程，本文再次基于openJDK的bugs讨论组提出的CHM源代码另外一个会造成死循环的bug，默认读者已经掌握CHM的核心源代码实现，否则无法从本文的讨论中获益。文章前部分先把computeIfAbsent的bug成因分析清楚，再来介绍官网&lt;code&gt;ConcurrentHashMap.computeIfAbsent stuck in an endless loop&lt;/code&gt;的讨论过程，这样更容易看懂相关内容。&lt;/p&gt;
&lt;p&gt;研究openJDK官方公布的相关源码bug有何“收益”：&lt;/p&gt;
&lt;p&gt;虽然这些bug不是特别严重，修复起来也即几行代码，但如果想要解决这种看似“简单的bug”，要求对CHM设计原理、类、方法实现细节足够熟悉，也就是说，你要具备（至少在这个bug上下文的类、方法范围内）和源代码设计者同等思考视角才能去挖掘bug的本质原因并提出合理的修复建议。换句话说，你研究的不是这个bug本身，而是深入精通整个类的源代码实现，这种高级收益在日常业务开发几乎无法获得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/e850dc9870704077af0bb9da6e7810c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;
&lt;h4 id=&quot;认识computeIfAbsent用法&quot;&gt;&lt;a href=&quot;#认识computeIfAbsent用法&quot; class=&quot;headerlink&quot; title=&quot;认识computeIfAbsent用法&quot;&gt;&lt;/a&gt;认识computeIfAbsent用法&lt;/h4&gt;&lt;p&gt;理解computeIfAbsent在一些场合下的用法，有助于帮助切入源代码分析。&lt;/p&gt;
&lt;h5 id=&quot;computeIfAbsent使用场景1：&quot;&gt;&lt;a href=&quot;#computeIfAbsent使用场景1：&quot; class=&quot;headerlink&quot; title=&quot;computeIfAbsent使用场景1：&quot;&gt;&lt;/a&gt;computeIfAbsent使用场景1：&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; concurrent.demo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ConcurrentHashMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Demo1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;computeKeyLength&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String key)&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 计算key的长度，将其作为该key对应的value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; key.length();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConcurrentHashMap&amp;lt;String,Integer&amp;gt; map=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        map.put(&lt;span class=&quot;string&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        map.computeIfAbsent(&lt;span class=&quot;string&quot;&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;,key-&amp;gt;computeKeyLength(key));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(map); &lt;span class=&quot;comment&quot;&gt;//输出 &amp;#123;foobar=6, foo=1&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;computeIfAbsent字面意思：如果key不在map里面，那么就使用给定的匿名函数（也叫映射函数）将key对应的value“计算出来”。（匿名函数也即lambda语法是jdk1.8语法新特性，这一点不必多说）&lt;/p&gt;
&lt;p&gt;按这个思路可以有以下解释：&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度讨论官方关于jdk1.8ConcurrentHashMap的resizeStamp源代码修复逻辑</title>
    <link href="https://yield-bytes.github.io/2021/09/12/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E5%AE%98%E6%96%B9%E5%85%B3%E4%BA%8Ejdk1.8ConcurrentHashMap%E7%9A%84resizeStamp%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91/"/>
    <id>https://yield-bytes.github.io/2021/09/12/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BA%E5%AE%98%E6%96%B9%E5%85%B3%E4%BA%8Ejdk1.8ConcurrentHashMap%E7%9A%84resizeStamp%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E9%80%BB%E8%BE%91/</id>
    <published>2021-09-11T16:00:00.000Z</published>
    <updated>2022-05-09T13:57:56.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先给出以下open JDK版本的序号说明和Oracle JDK序号说明</p><p>（1）对于JDK8或者Java 8</p><p>即可指代openjdk-8-jdk或者java-1.8.0-openjdk，</p><p>也可指代Oracle家的Java SE 8或者JDK 8u211 and later</p><p>（1）对于JDK16或者Java 16</p><p>即可指代openjdk的JDK 16.0.2 ，也可指代Oracle家的Java SE 16或者 jdk16.0.1，这里为何给出Java 8和Java 16版本说明？</p><p>首先resizeStamp的bug在Java8出现，并在Java 12被修复，因此本文直接给出最新版Java 16作为bug修复前后对比即可。</p><p>以下做个约定：统一以Java X形式作为版本称号，CHM：ConcurrentHashMap的简称，以此减少阅读障碍。</p><p>在前面的文章中，关于Java 8 的CHM addCount方法里面分支2：<code>resizeStamp</code>和<code>sc==rs+1、sc==rs+MAX_RESIZERS</code>的讨论中，已经指出其bug嫌疑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分支1 省略...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分支2 </span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// 注意这里计算出的rs是正值</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// sc是负值，怎么会等于rs+1或者rs + MAX_RESIZERS这个正值呢？ 有可能是个bug</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="官方bug描述"><a href="#官方bug描述" class="headerlink" title="官方bug描述"></a>官方bug描述</h4><p>其实这个bug在open jdk的官方bugs主页已经给出相关解释和修复过程，链接：<a href="https://bugs.openjdk.java.net/browse/JDK-8214427">官方bug描述页面</a>：<br><img src="https://img-blog.csdnimg.cn/img_convert/eb2c433432625b947c9577f66143aa89.png" alt="开发者在官方提交的resizeStamp的bug描述"></p><p>从Detail这一块描述得到信息如下：</p><p>bug的描述：ConcurrentHashMap.addCount()设计逻辑中可能存在bug。（这里虽然提到addCount()方法，但本人更想强调的是扩容分支的resizeStamp的bug）</p><p>级别是：bug</p><p>当前状态：已经修复</p><p>影响的版本：Java 11、Java12</p><p>在哪个版本得到修复：Java 12</p><p>使用操作系统平台：所有</p><p>bug页面创建时间：2018-11-26</p><p>解决bug的最后时间：2018-12-11</p><p>bug所属库：Java的核心库——core-libs</p><h4 id="提交者的修复建议"><a href="#提交者的修复建议" class="headerlink" title="提交者的修复建议"></a>提交者的修复建议</h4><blockquote><p>In the above code, condition of (sc == rs + 1 || sc == rs + MAX_RESIZERS ) would never be true , since the value of rs is positive and the value of sc is negative .</p><p>译：条件 (sc == rs + 1 || sc == rs + MAX_RESIZERS )永远不可能true，因为rs的值为正数，而sc值为负数</p></blockquote><p>并建议修改为：</p><blockquote><p>The correct condition should be (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1 || (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS, which can be used to dedect if resizing process finished or resizing threads reaches maxmium limitation</p><p>译：正常的条件应该是这样： (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1 || (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS，这两个条件表示扩容任务已结束或者参与扩容的线程总数达到最大值</p></blockquote><a id="more"></a><p>确实，这个bug非常明显，以分支2作为说明</p><p>int rs = resizeStamp(n)，以容量n=16作为说明，rs计算为下面的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 1000 0000 0001 1011</span><br></pre></td></tr></table></figure><p>考察低16位，rs+1的结果显然是一个正数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 1000 0000 0001 1100</span><br></pre></td></tr></table></figure><p>rs+MAX_RESIZERS同理也是一个正数，接着判断条件if(sc&lt;0)成立才能进入rs+1等条件，也即此时sc是一个负数（其实是因为首个扩容线程会将sc设为<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code>的一个基础负数），基于此，有提交者在这里发现的了bug：sc是负数，而rs+1是正数，因此sc==rs+1永远不会成立</p><h4 id="官方关于此bug的讨论过程"><a href="#官方关于此bug的讨论过程" class="headerlink" title="官方关于此bug的讨论过程"></a>官方关于此bug的讨论过程</h4><p>JCP  JSR-166 Expert Group （关于Java并发编程的规范提案的专家组）几个相关成员的对话过程即可知道他们对问题的思考和处理方式。</p><p>在Activity这个栏目就是用于提交者已经相关专家bug讨论过程，“All”是显示所有他们的活动记录，一般无需关注，“Comments”显示他们的对话过程，bug的讨论过程就在这里，因此需要重点关注，具体如下：</p><p>以下是来自“Comments”区域的内容：</p><p>(最开始由Webbug Group 这个小组提交了该issue - 2018-11-26 00:53)</p><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=smarks">Stuart Marks</a> 说：</p><blockquote><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=smarks">Stuart Marks</a> added a comment - 2018-11-28 09:10</p><p>Martin, can you take a look at this?</p><p>Martin，来，帮我看看这个bug？</p></blockquote><p>Martin的回答，主要意思是：bug提交者在查一个确实是由addCount产生错误计数，但Martin说他们也没有可以使用的压测案例，并建议使用者用多线程做压测来让addCount的这个bug复现，但这个bug不好复现。</p><blockquote><p>Resizing the internal bucket array is hairy race-prone code, and hard to stress test because resizes are relatively rare.</p><p>The reporter probably investigated an actual occurrence of incorrect count (we could ask!), but we don’t have a stress test reproduction that could be used.</p><p>One should be able to construct a stress test using multiple threads to trigger concurrent attempts to addCount, but it won’t be easy.</p></blockquote><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dholmes">David Holmes</a> 对Martin说：</p><blockquote><p>What is your analysis just based on the code and the report? It certainly appears incorrect to me.</p><p>你的分析只是基于代码以及提交的报告？这个bug在我看来显然是不正确的。</p></blockquote><p>Martin回答<a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dholmes">David Holmes</a> ：</p><p>Martin说自己也看了看源码但研究时间不够长，自己还没能搞懂其设计，然后说Doug应该记得这个设计！</p><blockquote><p>I stared at the code for a while, but not long enough to understand it. Doug will remember!</p></blockquote><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dl">Doug Lea</a> added a comment - 2018-11-28 15:53:</p><p>Doug Lea看到这个bug，做了基本的分析：这个bug会影响到CHM性能也即有些线程不能参与到扩容任务中，并指出这个bug只是影响性能而不是一个引起map发生错误的bug，指出这个bug需要修复。</p><blockquote><p>Yes. Some of this check now includes dead code, because of a change of representation at one point that wasn’t adjusted for. With the possible effect of some threads not helping resize (a performance, not map correctness bug) This should be fixed (and is committed in jdr166 repo):</p></blockquote><p>然后他贴出修复前后的源码diff</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- ConcurrentHashMap.java.~<span class="number">1.314</span>.~ <span class="number">2018</span>-<span class="number">10</span>-<span class="number">05</span> <span class="number">13</span>:<span class="number">42</span>:<span class="number">39.860409607</span> -<span class="number">0400</span></span><br><span class="line">+++ ConcurrentHashMap.java <span class="number">2018</span>-<span class="number">11</span>-<span class="number">28</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">55.998082379</span> -<span class="number">0500</span></span><br><span class="line">@@ -<span class="number">2307</span>,<span class="number">9</span> +<span class="number">2307</span>,<span class="number">9</span> @@</span><br><span class="line">                    (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                 <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                 <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">- <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">- sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">- transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">+ <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + <span class="number">1</span> ||</span><br><span class="line">+ (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS ||</span><br><span class="line">+ (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                         transfer(tab, nt);</span><br></pre></td></tr></table></figure><p>可以看到判断条件变为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + <span class="number">1</span> ||(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS ||(nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>根据修复的条件，可知rs是负数，因此<code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code> 已经没有实际意义，因为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT)是一个正数，rs是一个负数，显然是不相等，因此<code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>是多余的。</p><p>这就是最终定稿修复源码吗？  继续看后面的讨论</p><p>Pallavi Sonal (Inactive)](<a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=psonal">https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=psonal</a>) added a comment - 2018-11-29 01:09</p><p>Pallavi Sonal收到提交者新的描述，</p><blockquote><p>Additional Information from submitter:<br>I need to change the correct conditions given by me in the bug description ï¼š</p><p>The correct condition shuold be</p><p>sc == ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) +1 || sc == ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) + MAX_RESIZERS</p></blockquote><p>其实就是说一开始提交bug的描述中，两个条件应该是这样的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + <span class="number">1</span> || (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS</span><br></pre></td></tr></table></figure><p>现在提交者应该是自己对扩容移位理解深入后，发现按下面这样写更能准确表达：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int rs = resizeStamp(n);</span></span><br><span class="line">sc == ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) +<span class="number">1</span> || sc == ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) + MAX_RESIZERS</span><br></pre></td></tr></table></figure><p>本人也赞同这种建议：因为该if条件考察主体是以rs扩容戳的角度出发，因为rs由resizeStamp(n)计算出是正值:</p><p><code>0000 0000 0000 0000 1000 0000 0001 1011</code></p><p>因此将rs左移RESIZE_STAMP_SHIFT位后，扩容戳关键信息移动到高16位：</p><p><code>1000 0000 0001 1011 0000 0000 0000 000</code> （此时是一个负数）</p><p>然后再去判断<code>sc == ( rs&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) +1</code> 是否成立，这样才能符合rs的移位设计逻辑：高16位存放扩容印记信息，低16位用于存放扩容线程数量。</p><p>而<code>sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT</code> 的写法无法表达出“rs的高16位存放扩容印记信息，rs低16位用于存放扩容线程数量。”这种移位设计理念。</p><h4 id="bug的复现方法"><a href="#bug的复现方法" class="headerlink" title="bug的复现方法"></a>bug的复现方法</h4><p>Pallavi Sonal最关键的贡献是提供了bug的复现方法，如下所示：</p><p>这里有个tricky：将MAX_RESIZERS设为2以及在transfer中挂起进入transfer线程 suspend Threads</p><blockquote><p>This bug could be verifed by a small example :</p><p>1、将ConcurrentHashMap源码拷贝自己测试包目录下</p><p>First, copy the ConcurrentHashMap source code to your own package</p><p>2、还有其他相关的ThreadLocalRandom源码也要拷到自己项目包</p><p>Second, do some necessary modification to make it can be compiled (eg: change package declaration, make Unsafe instance works, copy ThreadLocalRandom to your package as well, since the ConcurrentHashMap used ThreadLocalRandom.probe() function, which is not public )</p><p>3、写个demo测试代码，以及在源码加一些修改（注意源码无法直接修改，可以选择拷到自己包下，个人推荐：最好的方式是在IDEA将SDKs 的<code>Sourcepath</code>替换自定义的源码目录，这样JDK源码就可以直接编辑，比上面提的方式要方便）</p><p>Third, reduce MAX_RESIZERS to 2, as the documentation shows, this should ensure there are at most 2 threads can do resizing concurrently</p><p>// CHM源码将MAX_RESIZERS数量设为2，以便观察进入transfer的线程数量</p><p>private static final int MAX_RESIZERS = 2;</p><p>Fourth, add the following code snippet into the customized ConcurrentHashMap class</p><p>public static void main(String[] args) {</p><p>ConcurrentHashMap hashMap = new ConcurrentHashMap(8);</p><p>for(int i = 0; i&lt; 300; i++)<br>{<br>new Thread() {<br>@Override<br>public void run() {<br>hashMap.put(Thread.currentThread().getId(),”id: “+Thread.currentThread().getId());<br>}<br>}.start();<br>}<br>}</p><p>5、在transfer方法指定埋入一些让线程挂起的代码</p><p>Fifth, add the following code snippet into the transfer function of ConcurrentHashMap . To suspend any thread that entered into transfer</p><p>if (nextTab == null) { // initiating<br>try {<br>@SuppressWarnings(“unchecked”)<br>Node<K,V>[] nt = (Node<K,V>[])new Node&lt;?,?&gt;[n &lt;&lt; 1];<br>nextTab = nt;<br>} catch (Throwable ex) { // try to cope with OOME<br>sizeCtl = Integer.MAX_VALUE;<br>return;<br>}<br>nextTable = nextTab;<br>transferIndex = n;<br>}</p><p>// The following added code here is to suspend Threads !!!! 在这里挂起线程<br>try {<br>String s = new String();<br>synchronized (s)<br>{<br>s.wait();<br>}<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}</p><p>6、在以下 addCount 代码片段加入断点，并使用IDEA的 “Thread” option来测试<br>Six, add the Thread break point in the following code line in addCount function</p><p>( Tip: I used Idea Intellij , choose “Thread” option can suspend each thread in your application , otherwise it will only suspend only the first Thread which executed to the break point)</p><p>​      if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<br>​      transfer(tab, nt);<br>enter image description here</p><p>debug后会发现进入transfer方法的线程数量超过2个，这就可以证明<code>sc==rs+MAX_RESIZERS</code>完全没有起效，因为按原始写法：sc是负值，rs是正值，<code>sc==rs+MAX_RESIZERS</code> 本身不会成立，当然无法限制进入扩容逻辑线程的总数量</p><p>Then run the main function, you will see more than 2 threads entered transfer function, which means MAX_RESIZERS does not take any effect.</p></blockquote><p>复现这个bug设计思路确实操作性很高！</p><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=dl">Doug Lea</a> added a comment - 2018-12-02 08:00</p><p>其实由于上面已经给出bug复现方法，Doug Lea肯定更加清楚问题所在，因此他说helpTransfer方法也有这个问题，最后他用了更加简化的移位表达式来修复这个bug，并且Doug Lea也亲自验证修复后条件是否能起到相关效果。</p><blockquote><p>A similar change is also necessary in helpTransfer. These together with a simplification of the shift expressions are now in jsr166 repo. I also verified that limits are maintained.</p></blockquote><h4 id="bug修复的代码最终提交到仓库："><a href="#bug修复的代码最终提交到仓库：" class="headerlink" title="bug修复的代码最终提交到仓库："></a>bug修复的代码最终提交到仓库：</h4><p><a href="https://bugs.openjdk.java.net/secure/ViewProfile.jspa?name=hgupdate">HG Updates</a> added a comment - 2018-12-11 20:16</p><blockquote><p>URL: <a href="http://hg.openjdk.java.net/jdk/jdk/rev/b4eaf570a588">http://hg.openjdk.java.net/jdk/jdk/rev/b4eaf570a588</a><br>User: martin<br>Date: 2018-12-12 04:13:15 +0000</p></blockquote><p>8214427: probable bug in logic of ConcurrentHashMap.addCount() Reviewed-by: martin, dholmes</p><div class="table-container"><table><thead><tr><th style="text-align:right">author</th><th>dl</th></tr></thead><tbody><tr><td style="text-align:right">date</td><td>Tue, 11 Dec 2018 19:55:27 -0800 (2018-12-12)</td></tr><tr><td style="text-align:right">parents</td><td><a href="http://hg.openjdk.java.net/jdk/jdk/rev/c7c285b0b640">c7c285b0b640</a></td></tr><tr><td style="text-align:right">children</td><td><a href="http://hg.openjdk.java.net/jdk/jdk/rev/a35f7a452257">a35f7a452257</a></td></tr><tr><td style="text-align:right">files</td><td><a href="http://hg.openjdk.java.net/jdk/jdk/file/b4eaf570a588/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java">src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</a></td></tr><tr><td style="text-align:right">diffstat</td><td>1 files changed, 7 insertions(+), 9 deletions(-) <a href="javascript:toggleDiffstat(">[<code>+</code>]</a>)</td></tr></tbody></table></div><p>修复代码提交者应该是Doug Lea，因为dl是(D)oug (L)ea的缩写，Reviewed-by：martin, dholmes</p><p>具体为diff如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">+++ b/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.javaTue Dec 11 19:55:27 2018 -0800</span></span><br><span class="line">// 以下是addCount方法的源码修复 </span><br><span class="line"><span class="meta">@@ -2334,17 +2334,15 @@</span></span><br><span class="line">             Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">             while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">                    (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                 // 删除原先的写法   </span><br><span class="line"><span class="deletion">-                int rs = resizeStamp(n);</span></span><br><span class="line"> // 直接在这里对rs进行左移位操作</span><br><span class="line"><span class="addition">+                int rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;</span></span><br><span class="line">                 if (sc &lt; 0) &#123;</span><br><span class="line"><span class="deletion">-                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span></span><br><span class="line"><span class="deletion">-                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span></span><br><span class="line"><span class="deletion">-                        transferIndex &lt;= 0)</span></span><br><span class="line">// rs左移后，(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs是多余也是无实际意义条件，直接删除</span><br><span class="line"></span><br><span class="line"><span class="addition">+                    if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||</span></span><br><span class="line"><span class="addition">+                        (nt = nextTable) == null || transferIndex &lt;= 0)</span></span><br><span class="line">                         break;</span><br><span class="line">                     if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                         transfer(tab, nt);</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="deletion">-                else if (U.compareAndSetInt(this, SIZECTL, sc,</span></span><br><span class="line"><span class="deletion">-                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span></span><br><span class="line">//显然这样看起来更容易理解：首个进入扩容逻辑的线程，将sizeCtl设为基础值rs+2</span><br><span class="line"><span class="addition">+                else if (U.compareAndSetInt(this, SIZECTL, sc, rs + 2))</span></span><br><span class="line">                     transfer(tab, null);</span><br><span class="line">                 s = sumCount();</span><br><span class="line">             &#125;</span><br><span class="line"><span class="meta">@@ -2358,11 +2356,11 @@</span></span><br><span class="line"> // 以下是helpTransfer方法的源码修复 </span><br><span class="line">         Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">         if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">             (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">             // 同上</span><br><span class="line"><span class="deletion">-            int rs = resizeStamp(tab.length);</span></span><br><span class="line"><span class="addition">+            int rs = resizeStamp(tab.length) &lt;&lt; RESIZE_STAMP_SHIFT;</span></span><br><span class="line">             while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                    (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line"><span class="deletion">-                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span></span><br><span class="line"><span class="deletion">-                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span></span><br><span class="line"><span class="addition">+                if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||</span></span><br><span class="line"><span class="addition">+                    transferIndex &lt;= 0)</span></span><br><span class="line">                     break;</span><br><span class="line">                 if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                     transfer(tab, nextTab);</span><br></pre></td></tr></table></figure><h4 id="在Java-16源码验证其修复的代码"><a href="#在Java-16源码验证其修复的代码" class="headerlink" title="在Java 16源码验证其修复的代码"></a>在Java 16源码验证其修复的代码</h4><p>上面提到bug在Java 12就被修复了，考虑到当前最新的jdk版本为Java 16，因此可在JDK16验证其修复的源码，修改处为下面的三个更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">  CounterCell[] cs; <span class="keyword">long</span> b, s;   </span><br><span class="line">  <span class="comment">// 省略部分...</span></span><br><span class="line">  <span class="comment">// 分支2</span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 更改1</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 更改2</span></span><br><span class="line">                    <span class="keyword">if</span> (sc == rs + MAX_RESIZERS || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 更改3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, rs + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>可以看到，rs移位操作设计简化了，逻辑容易理解，这里再次给出分支2的解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">  CounterCell[] cs; <span class="keyword">long</span> b, s;   </span><br><span class="line">  <span class="comment">// 省略部分...</span></span><br><span class="line">  <span class="comment">// 分支2</span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 更改1:将扩容印记先左移16位，以便低16位用于线程数量累计。显然此时rs是一个负数</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 更改2：原来的条件1已被删除，原因已在前面给出。</span></span><br><span class="line">                  <span class="comment">// 若一个线程遇到以下四种情况之一就会自行break结束：扩容的线程总数达到最大限制值或者扩容任务已结束（所有扩容线程已退出）或者nextTable为空，或者已经没有可分配的桶位。条件1和条件2参考下图加深理解。</span></span><br><span class="line">                    <span class="keyword">if</span> (sc == rs + MAX_RESIZERS || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 除去首个扩容线程，以后每来一个扩容线程就对sc加1，参考下图</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 更改3：首个扩容线程对sc设为基础值为：rs+2后再进入transfer方法参与扩容，这种写法比之前版本要清晰很多，从这里也可以推导出：当sc的值为rs+1时，就能说明当前所有扩容线程都退出了扩容逻辑，CHM扩容完成。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, rs + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 当前线程再次获取CHM的节点总数，然后回到上面while循环检查s有无达下一个阶段扩容阈值sizeCtl，如果需要进行下一阶段扩容，那么当前线程又会回到更改3的位置：作为下一节点扩容的首个扩容线程。</span></span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/97e83ffc401b68273676330e258d2250.png" alt="sc线程计数示意图.001"></p><h4 id="解析本次bug的带来的技术收益"><a href="#解析本次bug的带来的技术收益" class="headerlink" title="解析本次bug的带来的技术收益"></a>解析本次bug的带来的技术收益</h4><p>为何要如此详细的分析官方修复的这个bug呢？ </p><p>最直观明显的技术收益：当你能对源代码的bug有深刻认识，并且知道专家组成员对bug的讨论以及修复过程，那么其实你对CHM的设计理念和源码实现能掌握得相当深入，感觉像是你也参与了CHM的部分源码编写，无形中对提高个人高级开发能力有一定帮助。</p><p>其次，当你知道有这么一个“open JDK bugs官方提交系统”，也许当你在研究难度比较高的源码设计时，若你能发现bug，你也可以提交，以此证明自身掌握高级研发能力程度。</p><p>最后，这个官方bugs提交系统也可以帮助个人快速找到想要深入解析的包或者类的关键设计原理，因为页面含有非常详细的bug描述、bug复现方法、bug出现原因分析、bug的代码修复。</p><p>查询页面如下：</p><p>基本用法也简单：在Projects里面选择你关注的领域，例如JDK，若不想加其他条件，可以直接使用关键字去检索你想要研究的源码</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1166b7e443f330f3baeb476bee50696c.png" alt="openJDKbug查询页面"></p><h4 id="bugs系统还给出另外与resizeStamp相关的bug"><a href="#bugs系统还给出另外与resizeStamp相关的bug" class="headerlink" title="bugs系统还给出另外与resizeStamp相关的bug"></a>bugs系统还给出另外与resizeStamp相关的bug</h4><p>不过是这个bug是提交者自己闹的乌龙，<a href="https://bugs.openjdk.java.net/browse/JDK-8242464">bug页面链接</a></p><p>提交者提交的描述：Bug in the logic of ConcurrentHashMap.addCount() when used in Threads</p><p>他认为主要问题不是sc==rs+1这边负数那边正数，而是应该关注当前数组的容量要两倍于原表</p><p>因此他认为if条件应该这么该：</p><p>将<code>sc==rs+1</code> 应该改为<code>(sc &gt;&gt;&gt;RESIZE_STAMP_SHIFT) == (rs&gt;&gt;&gt;RESIZE_STAMP_SHIFT) + 1</code></p><blockquote><p>A DESCRIPTION OF THE PROBLEM :<br>At java.util.concurrent.ConcurrentHashMap#addCount:2339<br>i think the condition is if the thread is reach maximum or the new table size is twice as before or the nextTable is null or the transferIndex is lesss than zero; the bug in jdk8 is “<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427</a>“ , i think the main thing is not one is positive another is negtive, but the new table size is twice as before.<br>at jdk12 i think is not fix it, “sc == rs + 1” compare the work thread but not array size, i think the code should be </p><p>if (sc == rs + MAX_RESIZERS || (sc &gt;&gt;&gt;RESIZE_STAMP_SHIFT) == (rs&gt;&gt;&gt;RESIZE_STAMP_SHIFT) + 1 ||<br>           (nt = nextTable) == null || transferIndex &lt;= 0)<br>           break;<br>rather than </p><p>if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||<br>           sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||<br>           transferIndex &lt;= 0)<br>           break; </p><p>REGRESSION : Last worked in version 8 </p><p>FREQUENCY : always </p></blockquote><p>到后面，提交者发现原来是自己理解错了，并再次加了以下comments：</p><p>他说很抱歉提交这样的bug，是他自己想错了，他以为<code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1</code> 这两个条件是用于描述检查数组size，其实不是的。他最终理解了<code>sc == rs + 1</code> 这样的条件目的在于对参与线程线程数量的计数</p><blockquote><p>Additional Information from Submiiter:<br>I am so sorry for submiting it. at jdk 1.8 “java.util.concurrent.ConcurrentHashMap#helpTransfer:2304”, i think “(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 “ is check the array size ,but yesterday i found that thinking of “ sc == rs + 1” as checking the count of thread was better.</p></blockquote><p>个人评价：</p><p>首先这个提交者没有真正理解和掌握resizeStamp的设计理念，以及这if中相关条件的用意，</p><p>既然这个提交者说将<code>sc == rs + 1</code> 改为<code>(sc &gt;&gt;&gt;RESIZE_STAMP_SHIFT) == (rs&gt;&gt;&gt;RESIZE_STAMP_SHIFT) + 1</code>才合理，为何他又不会将<code>sc == rs + MAX_RESIZERS</code> 改为:</p><p><code>(sc &gt;&gt;&gt;RESIZE_STAMP_SHIFT) == (rs&gt;&gt;&gt;RESIZE_STAMP_SHIFT) + MAX_RESIZERS</code></p><p>基于此，说明提交者没有真正理解这两个条件的实际目的， 所以他提的描述以及修复是不合理的，从Comments也可以看到那些专家对提交者提到的bug不感冒也可看出，这次提交的bug修复申请似乎意义不大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">We need a clearer explanation of what we&#39;re fixing here</span><br><span class="line">...</span><br><span class="line">but we need better input from the reporter.</span><br></pre></td></tr></table></figure><p>最后由提交者回复<code>I am so sorry for submiting it.</code> 结束。</p><p>从这个案例也告诉大家，对于JDK级别这种bug的提交，首先提交者自己能理解相关源码设计和实现，最好有测试case，然后给出详细的而准确的描述，如果提交者自己还未搞懂相关逻辑就急着提交，最后可能闹个笑话。</p><h4 id="关于sizeCtl一个bug"><a href="#关于sizeCtl一个bug" class="headerlink" title="关于sizeCtl一个bug"></a>关于sizeCtl一个bug</h4><p>这个bug比较简单，<a href="https://bugs.openjdk.java.net/browse/JDK-8202422">描述页面链接</a></p><p>它指出：sizeCtl在构造方法初始化时，选用同一个容量，但用以下不同的构造方法，结果发现两者计算出的sizeCtl不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br></pre></td></tr></table></figure><p>具体bug例子：</p><blockquote><p>The following two statements:</p><p>new ConcurrentHashMap(22,0.75f,1);<br>new ConcurrentHashMap(22). </p><p>The first construct method makes sizeCtl field value to 32, but the second one makes sizeCtl to 64.Both the two construct methods use the same parameter value. I think they should make the ‘sizeCtl’ value to be the same.</p></blockquote><p>对于给定的初始容量22来说，易知计算后sizeCtl正常值为32，但前一个构造方法计算出的sizeCtl是32，后一个构造方法计算出的sizeCtl是64，因此出现bug。</p><p>感兴趣的同学，可以自行研究其修复过程，本文不再给出相关说明。</p><h4 id="resizeStamp的bug复现方法（非常关键）"><a href="#resizeStamp的bug复现方法（非常关键）" class="headerlink" title="resizeStamp的bug复现方法（非常关键）"></a>resizeStamp的bug复现方法（非常关键）</h4><h5 id="源代码修复前的复现过程"><a href="#源代码修复前的复现过程" class="headerlink" title="源代码修复前的复现过程"></a>源代码修复前的复现过程</h5><p>文章最前面提到的JDK-8214427提交者确实是一个有水平且能深入理解源码的人，他还给Doug Lea他们提供了复现问题的6个步骤，思路清晰，因此本节也按其步骤给出IDEA debug过程，如下：</p><p>1、使用IDEA创建一个普通（Java或者Maven）项目，并在java目录下创建包concurrent.demo（或者自行命名），将源码文件ConcurrentHashMap.java、ThreadLocalRandom.java拷贝到包concurrent.demo下，创建ResizeStampBugTest用于测试，最终项目结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── concurrent</span><br><span class="line">│   │   │       └── demo</span><br><span class="line">│   │   │           ├── ConcurrentHashMap.java</span><br><span class="line">│   │   │           ├── ResizeStampBugTest.java</span><br><span class="line">│   │   │           └── ThreadLocalRandom.java</span><br><span class="line">│   │   └── resources</span><br></pre></td></tr></table></figure><p>这两个源码文件在哪里找？简单问题不再回答。</p><p>2、修改ConcurrentHashMap.java和ThreadLocalRandom.java里面的Unsafe代码，使得Unsafe类在自己项目上可以使用</p><p>因为源码文件已经拷贝到自己项目下，因此可以对其进行编辑</p><p>对于ConcurrentHashMap.java的Unsafe代码修改（注意有两个Unsfafe地方都需要修改）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下三行是新增，通过反射获得的Unsafe实例      </span></span><br><span class="line">      Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      U = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是源码获取Unsafe的写法，注释它即可</span></span><br><span class="line">    <span class="comment">// U = sun.misc.Unsafe.getUnsafe();</span></span><br></pre></td></tr></table></figure><p>对于ThreadLocalRandom.java的Unsafe代码修改方法也同上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 以下三行是新增，通过反射获得的Unsafe实例      </span></span><br><span class="line">       Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       UNSAFE = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 以下是源码获取Unsafe实例的写法，注释它即可</span></span><br><span class="line"><span class="comment">// UNSAFE = sun.misc.Unsafe.getUnsafe();</span></span><br></pre></td></tr></table></figure><p>3、在transfer方法的代码片段位置加上能让当然线程挂起的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">    <span class="comment">// 打印挂起的线程      </span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:线程挂起&quot;</span>);</span><br><span class="line">    <span class="comment">// 本文使用的是LockSupport的park方法将当前线程挂起，其实内部调用了UNSAFE.park。this表示当前代码块。这种写法在TreeBin的读写锁竞争设计里面有被运用过。    </span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 以下是提交者提供让线程挂起的写法之一，建议使用park方法来简直明了        </span></span><br><span class="line"><span class="comment">// The following added code here is to suspend Threads !</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                String s = new String();</span></span><br><span class="line"><span class="comment">//                synchronized (s)</span></span><br><span class="line"><span class="comment">//                &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(Thread.currentThread().getName()+&quot;:线程暂停&quot;);</span></span><br><span class="line"><span class="comment">//                    s.wait();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br></pre></td></tr></table></figure><p>4、更改其他常量属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 将桶位分配步长改为2，也即对一个容量为16的CHM，可以同时4个线程并发迁移各种桶位，也即至多有个4个线程能进入transfer方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 注释对应源码</span></span><br><span class="line">  <span class="comment">//private static final int MIN_TRANSFER_STRIDE = 16;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将MAX_RESIZERS设为3，由之前的CHM文章可知，实际参与到扩容线程数量为MAX_RESIZERS-1个，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//注释对应源码</span></span><br><span class="line"><span class="comment">//private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;</span></span><br></pre></td></tr></table></figure><p>5、使用断点位置1复现bug</p><p>JDK-8214427的提交者给出可以在AddCount的分支2以下两行打上断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))&#123;</span><br><span class="line">    transfer(tab, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA执行debug可以查看到以下每个线程方法调用栈的情况：（以下默认读者已经熟悉IDEA多线程调试操作以及相关界面的含义。）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ae8107dce306a9b66a3c2f7cf5d41b85.png" alt="sc+1位置断点debug图1"></p><p>而且是多个线程被观测：从线程Thread-12到Thread63都可以被观测。</p><p>这里需要解释为何是从IDEA捕抓到RUNNING状态的是线程Thread-12开始，而是不是从Thread-0开始？</p><p>因为前面第0号到10号线程总共put 入了11个节点（put结束后，这些线程发现不用扩容故结束），接着线程Thread-11去put节点完后发现此时CHM节点数量达到扩容阈值12（16*0.75），线程Thread-11就开始进入以下代码，可见线程Thread-11是作为首个进入扩容线程，但这里不是IDEA断点位置，这就是前面0到11线程不会在IDEA Frames或者Threads界面出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))&#123;</span><br><span class="line">    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又因为后续来了线程Thread-12put如节点后也发生s达到扩容阈值，会进入以下代码对sc加1计数，而这恰好是断点位置，因此线程Thread-12会IDEA 放入观测Frames中，而且线程Thread-12还是处于RUNNING状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))&#123;</span><br><span class="line">    transfer(tab, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理后续的线程Thread-13、Thread-14…… 直到线程Thread-63都会被IDEA放入观测Frames中，如下图所示：<img src="https://img-blog.csdnimg.cn/img_convert/dea07fce20d299c5818f908ec2acada4.png" alt="sc+1位置断点debug图2"><br>有了以上铺垫，现在如何在Debug界面将bug复现？</p><p>现在回顾文章开头提出源码（如下代码片段）中出现的问题：<code>sc=rs+1</code>以及<code>sc=rs+MAX_RESIZERS</code>不会成立，因此sc本身为负数，rs这边为正数，因此if中的<code>sc == rs + MAX_RESIZERS</code> 限制参与扩容线程的总数量的条件不会起效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">    transferIndex &lt;&#x3D; 0)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot;因无桶位可分配，此线程直接退出&quot;);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何证明呢？很简单，因为我们前面已经将 MAX_RESIZERS设为3，表示最多只允许 (MAX_RESIZERS-1)也即最多只能有2个线程进入扩容逻辑transfer方法，如果在IDEA界面观测到3个以上线程进入扩容逻辑transfer方法，说明bug成功复现，操作过程如下：</p><p>（1）在Frames界面，线程选择下拉框中选中一个线程，例如Thread-12，点击<code>Step Over</code> 跳过断点位置1的sc+1计数，接着点击<code>Step Into</code> 让线程在断点位置2进入transfer方法 ，此时在Thread-12的方法调用栈上出现transfer方法帧：<br><img src="https://img-blog.csdnimg.cn/img_convert/a045b2a6bb8c69277c4c7c465050d5d8.png" alt="sc+1位置断点debug图3"></p><p>（2）同理选中其他线程按（1）的“Step Over—&gt;（多次）Step Over—&gt;Step Into”操作,你发现超过2个线程都能进入transfer方法，其实后面的线程都可以进入transfer方法。这里不再一一给出图示。</p><p>这里为何说是（多次）Step Over呢，因此Thread-12 抢到CAS对sc加1，那么Thread-13只能回到<code>While</code>处再次来到断点位置去竞争CAS，所以需要对Thread-13（多次）Step Over。</p><p>（3）经过以上环节可以看到总共有64号到11号共24个线程能进入扩容逻辑，bug得到完美复现。</p><p>6、使用断点位置2复现bug</p><p>在5提到的方法中，需要手动Step Over—&gt;（多次）Step Over—&gt;Step Into操作将线程执行流进入到transfer方法，线程数量多，这么一个个操作去观察，显然方式很不smart。考虑另外一种方式：</p><p>去掉原来两个断点，新增一个断点，打在以下位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;  <span class="comment">// 断点位置</span></span><br></pre></td></tr></table></figure><p>给断点设置线程“Suspend条件”：<br><img src="https://img-blog.csdnimg.cn/img_convert/d4ac26eb1ebad97848cdb06a4845158b.png" alt="transfer内部位置断点debug图1"></p><p>断点条件：<code>tab.length==16 &amp;&amp; nextTab !=null</code> ，表示CHM还在容量为16阶段的扩容流程中，那么此时一定会有线程进入到transfer方法里面，通过查看Frames，你可以发现有很多扩容线程，也再次使得bug完美复现，这里不再累赘。</p><h5 id="源代码修复后的验证过程"><a href="#源代码修复后的验证过程" class="headerlink" title="源代码修复后的验证过程"></a>源代码修复后的验证过程</h5><p>本小节尝试将源代码修复后，观测进入transfer线程的数量是否与（MAX_RESIZERS-1）设定的总数一致，如果一致，说明源码修改的逻辑可接受：将AddCount方法的分支2改为正常的写法后，断点位置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123; <span class="comment">// 断点</span></span><br><span class="line">    transfer(tab, nt); <span class="comment">// 断点</span></span><br></pre></td></tr></table></figure><p>在transfer方法中加入线程挂起代码<code>LockSupport.park(this)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        nextTab = nt;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">        sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextTable = nextTab;</span><br><span class="line">    transferIndex = n;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>观测过程：根据前面分析可知，从线程Thread-12到Thread-63都会同一时刻来到sc+1计数逻辑进行CAS竞争，接下来的IDEA Debug步骤如下：</p><p>（1）选中Thread-12，对其执行sc+1计数逻辑进行CAS竞争，因此Thread-12优先来sc+1这个位置并CAS竞争成功，它可进入transfer内部。</p><p>（2）接着选中Thread-13，对其执行sc+1计数逻辑进行CAS竞争，因为竞争失败，因此回到While循环继续：</p><p>图中可以清晰看见：sc==rs+MAX_RESIZERS 为true，表名当前参与到扩容线程的数量达到最大的限定值，Thread-13将会进入break然后退出</p><p><img src="https://img-blog.csdnimg.cn/img_convert/33aa00f8570788a8f611b7a38b8b4ed0.png" alt="rs修复后debug图1"></p><p>（3）同理选中Thread-14等后续线程也会跟Thread-13同一逻辑，</p><p>也即，Thread-13到Thread-63线程都会break掉</p><p>（4）在（1）中只有1个线程Thread-12进入transfer内部，不是说好会有（MAX_RESIZERS-1），也即2个线程能进入transfer内部吗？  </p><p>别忘记线程Thread-11已经通过以下逻辑作为第1个扩容线程进入了transfer方法内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, rs + <span class="number">2</span>))&#123;</span><br><span class="line">    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此总共有2个线程：Thread-11和线程Thread-12进入到transfer方法内部，说明修复之后的代码逻辑正确。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;首先给出以下open JDK版本的序号说明和Oracle JDK序号说明&lt;/p&gt;
&lt;p&gt;（1）对于JDK8或者Java 8&lt;/p&gt;
&lt;p&gt;即可指代openjdk-8-jdk或者java-1.8.0-openjdk，&lt;/p&gt;
&lt;p&gt;也可指代Oracle家的Java SE 8或者JDK 8u211 and later&lt;/p&gt;
&lt;p&gt;（1）对于JDK16或者Java 16&lt;/p&gt;
&lt;p&gt;即可指代openjdk的JDK 16.0.2 ，也可指代Oracle家的Java SE 16或者 jdk16.0.1，这里为何给出Java 8和Java 16版本说明？&lt;/p&gt;
&lt;p&gt;首先resizeStamp的bug在Java8出现，并在Java 12被修复，因此本文直接给出最新版Java 16作为bug修复前后对比即可。&lt;/p&gt;
&lt;p&gt;以下做个约定：统一以Java X形式作为版本称号，CHM：ConcurrentHashMap的简称，以此减少阅读障碍。&lt;/p&gt;
&lt;p&gt;在前面的文章中，关于Java 8 的CHM addCount方法里面分支2：&lt;code&gt;resizeStamp&lt;/code&gt;和&lt;code&gt;sc==rs+1、sc==rs+MAX_RESIZERS&lt;/code&gt;的讨论中，已经指出其bug嫌疑：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; check)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 分支1 省略...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 分支2 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (check &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Node&amp;lt;K,V&amp;gt;[] tab, nt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, sc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (s &amp;gt;= (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rs = resizeStamp(n); &lt;span class=&quot;comment&quot;&gt;// 注意这里计算出的rs是正值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sc &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  	&lt;span class=&quot;comment&quot;&gt;// sc是负值，怎么会等于rs+1或者rs + MAX_RESIZERS这个正值呢？ 有可能是个bug&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sc == rs + MAX_RESIZERS || (nt = nextTable) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        transferIndex &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSetInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        transfer(tab, nt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSetInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                             (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    transfer(tab, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                s = sumCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;官方bug描述&quot;&gt;&lt;a href=&quot;#官方bug描述&quot; class=&quot;headerlink&quot; title=&quot;官方bug描述&quot;&gt;&lt;/a&gt;官方bug描述&lt;/h4&gt;&lt;p&gt;其实这个bug在open jdk的官方bugs主页已经给出相关解释和修复过程，链接：&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8214427&quot;&gt;官方bug描述页面&lt;/a&gt;：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/eb2c433432625b947c9577f66143aa89.png&quot; alt=&quot;开发者在官方提交的resizeStamp的bug描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;从Detail这一块描述得到信息如下：&lt;/p&gt;
&lt;p&gt;bug的描述：ConcurrentHashMap.addCount()设计逻辑中可能存在bug。（这里虽然提到addCount()方法，但本人更想强调的是扩容分支的resizeStamp的bug）&lt;/p&gt;
&lt;p&gt;级别是：bug&lt;/p&gt;
&lt;p&gt;当前状态：已经修复&lt;/p&gt;
&lt;p&gt;影响的版本：Java 11、Java12&lt;/p&gt;
&lt;p&gt;在哪个版本得到修复：Java 12&lt;/p&gt;
&lt;p&gt;使用操作系统平台：所有&lt;/p&gt;
&lt;p&gt;bug页面创建时间：2018-11-26&lt;/p&gt;
&lt;p&gt;解决bug的最后时间：2018-12-11&lt;/p&gt;
&lt;p&gt;bug所属库：Java的核心库——core-libs&lt;/p&gt;
&lt;h4 id=&quot;提交者的修复建议&quot;&gt;&lt;a href=&quot;#提交者的修复建议&quot; class=&quot;headerlink&quot; title=&quot;提交者的修复建议&quot;&gt;&lt;/a&gt;提交者的修复建议&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;In the above code, condition of (sc == rs + 1 || sc == rs + MAX_RESIZERS ) would never be true , since the value of rs is positive and the value of sc is negative .&lt;/p&gt;
&lt;p&gt;译：条件 (sc == rs + 1 || sc == rs + MAX_RESIZERS )永远不可能true，因为rs的值为正数，而sc值为负数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并建议修改为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The correct condition should be (sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) == rs + 1 || (sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS, which can be used to dedect if resizing process finished or resizing threads reaches maxmium limitation&lt;/p&gt;
&lt;p&gt;译：正常的条件应该是这样： (sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) == rs + 1 || (sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS，这两个条件表示扩容任务已结束或者参与扩容的线程总数达到最大值&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度讨论jdk1.8 ConcurrentHashMap并发环境下transfer方法桶位分配过程</title>
    <link href="https://yield-bytes.github.io/2021/08/15/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.8%20ConcurrentHashMap%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Btransfer%E6%96%B9%E6%B3%95%E6%A1%B6%E4%BD%8D%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B/"/>
    <id>https://yield-bytes.github.io/2021/08/15/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.8%20ConcurrentHashMap%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Btransfer%E6%96%B9%E6%B3%95%E6%A1%B6%E4%BD%8D%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2022-05-09T13:55:32.571Z</updated>
    
    <content type="html"><![CDATA[<p>在前面有多篇关于jdk1.8的ConcurrentHashMap研究是基于源代码给出的深度分析，要知道多线程环境下的ConcurrentHashMap内部运行机制是相对复杂的，好在IDEA提供的相关断点和Debug功能确实好用，使得多线程调试起来直观，通过这种方式能加深多线程操作CHM的执行流程。</p><h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5><p>这部内容请参考文章中的小节部分，本文不再累赘。</p><h5 id="使用埋点打印法观测"><a href="#使用埋点打印法观测" class="headerlink" title="使用埋点打印法观测"></a>使用埋点打印法观测</h5><p>此方法相对繁琐，难度并不大，要求使用者对源代码设计足够理解，否则埋点位置不佳影响观测效果</p><p>1、测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResizeStampBugTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 设置64个线程并发put</span></span><br><span class="line">        <span class="keyword">int</span> maxThreads = <span class="number">64</span>;</span><br><span class="line">      <span class="comment">// 初始容量为8，内部会被调整为16</span></span><br><span class="line">        ConcurrentHashMap&lt;Long, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; map.put(Thread.currentThread().getId(),Thread.currentThread().getName()));</span><br><span class="line">            t.setName(<span class="string">&quot;Thread-&quot;</span>+i);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="comment">// 因为多个线程并发执行不方便查看打印结果，可以让前一个线程领先后面线程一丁点，以便观察打印结果，当然也可以不需要，多执行几次看看打印结果即可。</span></span><br><span class="line">            <span class="comment">// Thread.sleep(1);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里ConcurrentHashMap类用的是项目concurrent.demo包下的ConcurrentHashMap.java 源码文件</p><p>2、更改桶位分配步长，将源码的16改为4，方便观察</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// private static final int MIN_TRANSFER_STRIDE = 16;</span></span><br></pre></td></tr></table></figure><p>3、transfer方法加入打印每个线程分配的桶位区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                  nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">               bound = nextBound;</span><br><span class="line">               i = nextIndex - <span class="number">1</span>;</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 以下三行是新增代码</span></span><br><span class="line">               String s=String.format(<span class="string">&quot;%s分配的捅位区间为:[%d,%d]并挂起&quot;</span>,Thread.currentThread().getName(),bound,i);</span><br><span class="line">               System.out.println(s);</span><br><span class="line">               <span class="comment">// 在这里加一句挂起已经分配好桶位区间的线程，用于观察线程</span></span><br><span class="line">               LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>4、其他地方需要埋入打印语句</p><p>pulVal方法：当key定位到的桶位为空，直接放入key节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                          <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) &#123;</span><br><span class="line">         <span class="comment">// 埋入打印语句</span></span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在桶位[&quot;</span>+i+<span class="string">&quot;]put入Node节点并退出&quot;</span>);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>addCount方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))&#123;</span><br><span class="line">     <span class="comment">// 埋入打印语句</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;后续进入扩容逻辑transfer方法&quot;</span>);</span><br><span class="line">        transfer(tab, nt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))&#123;</span><br><span class="line">  <span class="comment">// 埋入打印语句</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;第1个进入扩容逻辑transfer方法&quot;</span>);</span><br><span class="line">    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>5、预期执行</p><p>打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>在桶位[<span class="number">9</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">1</span>在桶位[<span class="number">10</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">2</span>在桶位[<span class="number">11</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">3</span>在桶位[<span class="number">12</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">4</span>在桶位[<span class="number">13</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">5</span>在桶位[<span class="number">14</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">6</span>在桶位[<span class="number">15</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">7</span>在桶位[<span class="number">0</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">8</span>在桶位[<span class="number">1</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">9</span>在桶位[<span class="number">2</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">10</span>在桶位[<span class="number">3</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">11</span>在桶位[<span class="number">4</span>]put入Node节点并退出</span><br><span class="line">Thread-11第1个进入扩容逻辑transfer方法 # 注意此线程</span><br><span class="line">Thread-<span class="number">12</span>在桶位[<span class="number">5</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">12</span>进入扩容逻辑transfer方法</span><br><span class="line">Thread-<span class="number">13</span>在桶位[<span class="number">6</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">13</span>进入扩容逻辑transfer方法</span><br><span class="line">Thread-<span class="number">14</span>在桶位[<span class="number">7</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">14</span>进入扩容逻辑transfer方法</span><br><span class="line">Thread-<span class="number">15</span>在桶位[<span class="number">8</span>]put入Node节点并退出</span><br><span class="line">Thread-<span class="number">12</span>分配的捅位区间为:[<span class="number">12</span>,<span class="number">15</span>]并挂起</span><br><span class="line">Thread-<span class="number">13</span>分配的捅位区间为:[<span class="number">4</span>,<span class="number">7</span>]并挂起</span><br><span class="line">Thread-<span class="number">14</span>分配的捅位区间为:[<span class="number">0</span>,<span class="number">3</span>]并挂起</span><br><span class="line">Thread-<span class="number">11</span>分配的捅位区间为:[<span class="number">8</span>,<span class="number">11</span>]并挂起</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e2067f18b8c22bc1b20b494096de4fa3.png" alt="transfer埋点打印"></p><p>打印结果说明①</p><p>因为CHM的底层table容量为16也即有16个桶位，  此外使用线程ID作为节点的key，根据桶位定位算法<code>i = (n - 1) &amp; hash</code>，前面16个线程（第0号线程到第15号线程）并发将16个key恰好能放到table16个桶位上，这也是为何将打印点放在putVal对应位置，线程put完后break退出后进入addCount，因此才有以下类似的打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Thread-0在桶位[9]put入Node节点并退出</span><br><span class="line">Thread-1在桶位[10]put入Node节点并退出</span><br><span class="line">Thread-2在桶位[11]put入Node节点并退出</span><br><span class="line">Thread-3在桶位[12]put入Node节点并退出</span><br><span class="line">Thread-4在桶位[13]put入Node节点并退出</span><br><span class="line">Thread-5在桶位[14]put入Node节点并退出</span><br><span class="line">Thread-6在桶位[15]put入Node节点并退出</span><br><span class="line">Thread-7在桶位[0]put入Node节点并退出</span><br><span class="line">Thread-8在桶位[1]put入Node节点并退出</span><br><span class="line">Thread-9在桶位[2]put入Node节点并退出</span><br><span class="line">Thread-10在桶位[3]put入Node节点并退出</span><br><span class="line">Thread-11在桶位[4]put入Node节点并退出</span><br><span class="line"></span><br><span class="line">Thread-12在桶位[5]put入Node节点并退出</span><br><span class="line"></span><br><span class="line">Thread-13在桶位[6]put入Node节点并退出</span><br><span class="line"></span><br><span class="line">Thread-14在桶位[7]put入Node节点并退出</span><br><span class="line"></span><br><span class="line">Thread-15在桶位[8]put入Node节点并退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果说明②</p><p>在打印结果中你会发现Thread-11的特别之处，如下：这个线程在put节点后进入addCount，此时因为前面第0号到10号线程总共put 入了11个节点，当线程Thread-11去put节点完后发现此时CHM节点数量达到扩容阈值12（16*0.75），</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Thread-10在桶位[3]put入Node节点并退出</span><br><span class="line">Thread-11在桶位[4]put入Node节点并退出</span><br><span class="line"><span class="meta">#</span><span class="bash"> Thread-11 写入节点后发现s达到扩容阈值</span></span><br><span class="line">Thread-11第1个进入扩容逻辑transfer方法</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此线程Thread-11进入addCount方法的分支2且进入了扩容逻辑transfer，而且是作为第1个线程进入扩容逻辑</p><p>这就是为何要在addCount以下位置埋入打印点，捕获第1个进入扩容逻辑transfer方法的线程：线程Thread-11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))&#123;</span><br><span class="line">  <span class="comment">// 埋入打印语句</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;第1个进入扩容逻辑transfer方法&quot;</span>);</span><br><span class="line">    transfer(tab, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>打印结果说明③</p><p>因为继线程Thread-11put节点后使得s=12达到扩容阈值，因此后来的线程Thread-12、Thread-13、Thread-14在它们put完节点也发现需要扩容，因此也都进入的transfer方法，显然它们分别作为第2个、第3个、第4个进入transfer的线程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Thread-11在桶位[4]put入Node节点并退出</span><br><span class="line">Thread-11第1个进入扩容逻辑transfer方法</span><br><span class="line">Thread-12在桶位[5]put入Node节点并退出</span><br><span class="line">Thread-12进入扩容逻辑transfer方法</span><br><span class="line">Thread-13在桶位[6]put入Node节点并退出</span><br><span class="line">Thread-13进入扩容逻辑transfer方法</span><br><span class="line">Thread-14在桶位[7]put入Node节点并退出</span><br><span class="line">Thread-14进入扩容逻辑transfer方法</span><br><span class="line">Thread-15在桶位[8]put入Node节点并退出</span><br><span class="line"><span class="meta">#</span><span class="bash"> 线程Thread-15没能进入扩容逻辑transfer方法</span></span><br><span class="line">Thread-12分配的捅位区间为:[12,15]并挂起</span><br><span class="line">Thread-13分配的捅位区间为:[4,7]并挂起</span><br><span class="line">Thread-14分配的捅位区间为:[0,3]并挂起</span><br><span class="line">Thread-11分配的捅位区间为:[8,11]并挂起</span><br></pre></td></tr></table></figure><p>这里为何线程Thread-15没能进入transfer方法？还记得上面将桶位分配步长设为4的说明吗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// private static final int MIN_TRANSFER_STRIDE = 16;</span></span><br></pre></td></tr></table></figure><p>因为一开始CHM容量为16，也即16个桶位，又因为桶位步长设定为4，因此只能有4个线程能成功cas分配到桶位区间。由于线程Thread-11第1个先进入transfer方法、线程Thread-12第2个进入、线程Thread-13第3个进入、线程Thread-14第4个进入，这4个线程恰好“瓜分”完16个桶位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-12分配的捅位区间为:[12,15]并挂起</span><br><span class="line">Thread-13分配的捅位区间为:[4,7]并挂起</span><br><span class="line">Thread-14分配的捅位区间为:[0,3]并挂起</span><br><span class="line">Thread-11分配的捅位区间为:[8,11]并挂起</span><br></pre></td></tr></table></figure><p>之后transferIndex=0，表示全部桶位已经分配出去，那么再来的线程Thread-15，恰好满足下面条件<code>transferIndex &lt;= 0)</code> ，因此Thread-15不能进入transfer并break结束<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">        transferIndex &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>为什么线程Thread-11、Thread-12、Thread-13、Thread-14在transfer方法分配完桶位区间后没有退出？</p><p>这就是为何使用<code>LockSupport.park(this)</code>将线程挂起的原因，以便持续观察CHM的桶位分配机制，同时也能将CHM容量16扩容到32的过程暂停，使得CHM停留在第一轮扩容的过程中，而且暂停在桶位分配完之后，节点迁移之前。<br>“使得CHM扩容处理流程暂停在第一轮扩容的过程中”，这有什么用处呢，请看下面：</p><p>打印结果说明④</p><p>在AddCount方法下面位置埋入打印语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">    transferIndex &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;因无桶位可分配，此线程直接退出&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的就是考察线程Thread-11、Thread-12、Thread-13、Thread-14在transfer方法分配完桶位区间后并挂起，后续的Thread-15到Thread-63是如何安排的</p><p>打印如下：其实无需打印也能知道，因为Thread-15进入AddCount分支2后，transferIndex已经是0，也即无桶位可分配，只好break退出，后面来更多的其他线程也同理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Thread-15在桶位[8]put入Node节点并退出</span><br><span class="line">Thread-15因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-16因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-17因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-18因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-19因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-20因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-21因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-22因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-23因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-24因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-25因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-26因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-27因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-28因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-11分配的捅位区间为:[12,15]并挂起</span><br><span class="line">Thread-13分配的捅位区间为:[4,7]并挂起</span><br><span class="line">Thread-14分配的捅位区间为:[0,3]并挂起</span><br><span class="line">Thread-12分配的捅位区间为:[8,11]并挂起</span><br><span class="line">Thread-29因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-30因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-31因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-32因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-33因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-34因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-35因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-36因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-37因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-38因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-39因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-40因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-41因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-42因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-43因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-44因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-45因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-46因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-47因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-48因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-49因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-50因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-51因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-52因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-53因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-54因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-55因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-56因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-57因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-58因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-59因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-60因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-61因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-62因无桶位可分配，此线程直接退出</span><br><span class="line">Thread-63因无桶位可分配，此线程直接退出</span><br></pre></td></tr></table></figure><p>以上就是使用埋入打印点调试transfer机制，通过“print”来观察其运行机制先对入门，其实debug模式才是真正便捷的调试方式，继续查阅下面内容。</p><h5 id="使用IDEA-断点debug方式观测"><a href="#使用IDEA-断点debug方式观测" class="headerlink" title="使用IDEA 断点debug方式观测"></a>使用IDEA 断点debug方式观测</h5><p>1、只需在transfer以下位置打一个断点即可，也即在桶位区间cas分配的逻辑里的<code>advance=true</code>，如下，<br><img src="https://img-blog.csdnimg.cn/img_convert/b7c5eeb0d924c663a7d5c6750d53e527.png" alt="transfer break point位置"></p><p>并将断点的Suspend设为Thread，如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/5235db69397ebffedd635cdeba214b7a.png" alt="Thread Option断点设定"></p><p>2、启动debug，IDEA进入debug操作，此处无需图。</p><p>3、在Watchs栏目加入要“观测的变量”，这里当然是关注每个线程分配到的桶位区间的左边界bound和右边界i<br><img src="https://img-blog.csdnimg.cn/img_convert/dcb029b159551701428cc0405b8af90a.png" alt="Watchs加入bound和i变量观测"><br>Frames栏目可以显示每个线程的方法调用栈，在点选Thread-11作为观察目标，你可以清晰看到Thread-11的方法调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transfer <span class="comment">// 栈顶</span></span><br><span class="line">addCount</span><br><span class="line">putval</span><br><span class="line">put</span><br><span class="line">main主函数入口  <span class="comment">// 栈底</span></span><br></pre></td></tr></table></figure><p>点选“transfer”方法帧，然后右侧Variables栏目会展示该方法内部的局部变量值，由于我们想观测线程桶位区间的左边界bound和右边界i，因此在Watches加入这两个变量，图中可以非常直观看出Thread-11的桶位区间为[bound=12,i=15]</p><p>若想看其他线程分配的桶位，很简单，在下拉框选中其他线程即可，如Thread-12，可以在Watches栏目看到Thread-12的桶位区间为[bound=8,i=11]<br><img src="https://img-blog.csdnimg.cn/img_convert/4e7a0a685b1365bcff918cc5c3b444b2.png" alt="transfer Thread12桶位区间"><br>同理也可以看出Thread-13、Thread-14的界面，这里不再一一展示。</p><p>5、所观测的方法帧里面的变量和Watches对应<br><img src="https://img-blog.csdnimg.cn/img_convert/98a8833484149545a0b677c51e45cff1.png" alt="方法帧与watches变量对应"></p><p>如上图所示，Watches提示无法找到局部变量i和局部bound变量，这是因为当前观测的是在addCount这个方法帧，显然</p><p>addCount内部没有i和bound变量。此外，也可从addCount的局部变量表Variables栏目看Watches是否在里面。</p><p><strong>为何Frames只显示4个线程在RUNING状态？</strong></p><p>答案已经在第一小节的“使用埋点打印法观测”后面给出了详细的解释，这里也简要说明：</p><p>（1）第0到第15号线程put完节点后，其中第0到第10号线程结束退出，第11号线程发现put完后CHM节点数量达到扩容阈值12，因此进入AddCount分支2，并作为第1个进入扩容逻辑transfer的线程，故Thread-11分配到了桶位区间[12,15]</p><p>（2）线程Thread-12、Thread-13、Thread-14 put完节点也因为s节点数量达到扩容阈值，都进入到transfer方法，也分配到对应的桶位区间</p><p>（3）等线程Thread-15 put完节点后，发现已无桶位可分配，因此Thread-15 结束</p><p>（4）其他剩余的线程第16到第63号线程也同样因为“已无桶位可分配而结束”</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>可以看出，IDEA调试并发环境的CHM确实小有难度，最好能在掌握源代码情况下debug，通过这种实践而非源代码分析的观测方式，你能任意控制多线程并发执行流以及观测其内部协调机制、竞争机制，从而能深入掌握JUC并发设计和源代码实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面有多篇关于jdk1.8的ConcurrentHashMap研究是基于源代码给出的深度分析，要知道多线程环境下的ConcurrentHashMap内部运行机制是相对复杂的，好在IDEA提供的相关断点和Debug功能确实好用，使得多线程调试起来直观，通过这种方式能加深多线程操作CHM的执行流程。&lt;/p&gt;
&lt;h5 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h5&gt;&lt;p&gt;这部内容请参考文章中的小节部分，本文不再累赘。&lt;/p&gt;
&lt;h5 id=&quot;使用埋点打印法观测&quot;&gt;&lt;a href=&quot;#使用埋点打印法观测&quot; class=&quot;headerlink&quot; title=&quot;使用埋点打印法观测&quot;&gt;&lt;/a&gt;使用埋点打印法观测&lt;/h5&gt;&lt;p&gt;此方法相对繁琐，难度并不大，要求使用者对源代码设计足够理解，否则埋点位置不佳影响观测效果&lt;/p&gt;
&lt;p&gt;1、测试代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; concurrent.demo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ResizeStampBugTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	&lt;span class=&quot;comment&quot;&gt;// 设置64个线程并发put&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxThreads = &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	&lt;span class=&quot;comment&quot;&gt;// 初始容量为8，内部会被调整为16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConcurrentHashMap&amp;lt;Long, String&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; maxThreads; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread t = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; map.put(Thread.currentThread().getId(),Thread.currentThread().getName()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t.setName(&lt;span class=&quot;string&quot;&gt;&amp;quot;Thread-&amp;quot;&lt;/span&gt;+i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 因为多个线程并发执行不方便查看打印结果，可以让前一个线程领先后面线程一丁点，以便观察打印结果，当然也可以不需要，多执行几次看看打印结果即可。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Thread.sleep(1);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到这里ConcurrentHashMap类用的是项目concurrent.demo包下的ConcurrentHashMap.java 源码文件&lt;/p&gt;
&lt;p&gt;2、更改桶位分配步长，将源码的16改为4，方便观察&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; MIN_TRANSFER_STRIDE = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// private static final int MIN_TRANSFER_STRIDE = 16;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3、transfer方法加入打印每个线程分配的桶位区间&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSwapInt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, TRANSFERINDEX, nextIndex,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     nextBound = (nextIndex &amp;gt; stride ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  nextIndex - stride : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               bound = nextBound;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               i = nextIndex - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               advance = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下三行是新增代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               String s=String.format(&lt;span class=&quot;string&quot;&gt;&amp;quot;%s分配的捅位区间为:[%d,%d]并挂起&amp;quot;&lt;/span&gt;,Thread.currentThread().getName(),bound,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               System.out.println(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;comment&quot;&gt;// 在这里加一句挂起已经分配好桶位区间的线程，用于观察线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               LockSupport.park(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4、其他地方需要埋入打印语句&lt;/p&gt;
&lt;p&gt;pulVal方法：当key定位到的桶位为空，直接放入key节点。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((f = tabAt(tab, i = (n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;amp; hash)) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (casTabAt(tab, i, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;// 埋入打印语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Thread.currentThread().getName() + &lt;span class=&quot;string&quot;&gt;&amp;quot;在桶位[&amp;quot;&lt;/span&gt;+i+&lt;span class=&quot;string&quot;&gt;&amp;quot;]put入Node节点并退出&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;                   &lt;span class=&quot;comment&quot;&gt;// no lock when adding to empty bin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;addCount方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 埋入打印语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Thread.currentThread().getName()+&lt;span class=&quot;string&quot;&gt;&amp;quot;后续进入扩容逻辑transfer方法&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        transfer(tab, nt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                             (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;// 埋入打印语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(Thread.currentThread().getName()+&lt;span class=&quot;string&quot;&gt;&amp;quot;第1个进入扩容逻辑transfer方法&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transfer(tab, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：基于AQS实现的ReentrantReadWriteLock源代码深入分析</title>
    <link href="https://yield-bytes.github.io/2021/08/07/%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84ReentrantReadWriteLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/08/07/%E5%9F%BA%E4%BA%8EAQS%E5%AE%9E%E7%8E%B0%E7%9A%84ReentrantReadWriteLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</id>
    <published>2021-08-06T16:00:00.000Z</published>
    <updated>2022-05-18T14:12:39.921Z</updated>
    
    <content type="html"><![CDATA[<p>在ReentrantLock的独占模式下，当需要在一个读写高度竞争场景中使用它的<code>lock.lock()</code>时，你会发现这是独占锁，它会让大量同时请求锁的线程们都不得不进入CLH阻塞队列中等待，如果在“读多写少”的场景中，ReentrantLock的这种独占锁方式显然会降低并发性能，因此ReentrantReadWriteLock就是为了解决这种“读多写少”的场景：一个线程正在请求锁进行读操作可以不影响其他线程同时请求读锁（共享锁），意味着多个线程可以并发读。</p><p>这里首先通过Doug Lea在源码注释给出的demo作为对ReentrantReadWriteLock一般用法说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 读线程需要对data读取，写线程可以对data进行更新，那么data显然是线程不安全的，需要借助锁进行相关操作</span></span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid; <span class="comment">// 判断data是否已经被缓存</span></span><br><span class="line">  <span class="comment">// 1、创建一个读写锁</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock(); </span><br><span class="line"> <span class="comment">//该方式的功能就是对已经缓存的数据进行预处理 </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2、由于一开始，我们乐观认为data可能已经被缓存，因此我们不急着申请独占锁，而是申请并发的共享读锁</span></span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="comment">// 3、结果发现：我们太乐观了，原来data没缓存，因此还不能读取数据（如果非得去读，只能读到旧数据）</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      <span class="comment">// 4、既然乐观错估了情况，那么只能用上“强大的独占锁”，保证自己能独占的实施“写操作、更新操作、删除操作”：因为读写锁是互斥的，需先释放读锁，然后在升级为写锁。</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      <span class="comment">// 这就是所谓的“锁升级”。虽然说升级，但这里是当前线程请求独占锁，若同一时刻有其他线程已经拿到写锁，那么在这里当前线程会被阻塞在AQS里面的CLH阻塞队列</span></span><br><span class="line">      rwl.writeLock().lock(); </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="comment">// 5、由于我们获取写锁的时机也许比其他线程晚一步拿到，因此在这里拿到独占锁后，还得重新检查是否data已经提前被其他线程更新过</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ... <span class="comment">// 例如从数据库重新读取最新的data，然后将cacheValid标记为true，表示data已经更新（或已经更新缓存）</span></span><br><span class="line">          cacheValid = <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、由于我们还得使用更新后的data，因此可以申请读锁。注意，由于当前线程还持有写锁，因此其他线程不可能获得写锁进行写操作，因此当前线程此时可以申请读锁</span></span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7、显然data已经被我“独占式”地更新过，可以释放写锁了</span></span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 8、在第6点获得共享的读锁后，在这里可以使用已经缓存的新data</span></span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 9、释放读锁</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于读锁、写锁、读线程、写线程的一些说明"><a href="#关于读锁、写锁、读线程、写线程的一些说明" class="headerlink" title="关于读锁、写锁、读线程、写线程的一些说明"></a>关于读锁、写锁、读线程、写线程的一些说明</h4><p><code>rwl.readLock().lock()</code> `:很明显，线程在请求读锁，此锁是AQS的共享模式</p><p><code>rwl.writeLock().lock()</code>:很明显，线程在请求写锁，此锁是AQS的独占模式</p><p>严格来说：对于ReentrantReadWriteLock这种读写锁的设计，请求读锁的线程直接称为“读线程”可以吗，例如，请求写锁的线程，由于已经获取独占锁的线程可以去请求读锁，那么这个线程是应该称为“写线程”？“读线程”？还是“写、读线程”？还是“读写线程”呢？ 这么看来，请求到读锁的线程似乎也不适合称为读线程？成功请求到写锁的线程也不适合称为写线程。也许换一个角度可以更容易区分：</p><p>在用户代码层面的角度出发：</p><blockquote><p>1、用户设计此方法具有明显“读取”数据的逻辑时，该方法首先使用<code>`rwl.readLock().lock()</code> `，过程中不管是否需要再次请求写锁，都可以把执行用户方法的线程称为“读线程”</p><p>2、用户设计此方法具有明显“更新、删除、改、插入”数据的逻辑时，该方法首先使用<code>`rwl.writeLock().lock()</code> `，过程中不管是否需要再次请求写锁、还是读锁，都可以把执行用户方法的线程称为“写线程”</p></blockquote><p>但是从ReentrantReadWriteLock内部设计来看，可能按以下思路去想会更清晰：</p><blockquote><p>1、仅在ReentrantReadWriteLock内部调用tryAcquire方法来看，调用tryAcquire方法的线程可以看成是写线程，因为它是从<code>rwl.writeLock().lock()</code>来的</p><p>2、仅在ReentrantReadWriteLock内部调用tryAcquireShared方法来看，调用tryAcquireShared方法的线程可以看成是读线程，因为它是从<code>rwl.readLock().lock()</code>来的</p></blockquote><a id="more"></a><p>如果不按”用户代码”或者不按<code>ReentrantReadWriteLock</code>内部设计的角度，那么也可以按以下说明进行统一化描述：</p><p>“请求读锁的线程”、“持有读锁的线程”</p><p>“请求写锁的线程”、“持有写锁的线程”</p><p>在持有写锁的情况下，请求读锁的线程。</p><p>不存在“持有读锁的情况下，还能同时持有写锁的线程”的情形！  （否则此读锁已不是共享锁，而是变相成为了独占锁）或者说不满足“读写互斥设计”</p><h4 id="关于同步状态值的设计"><a href="#关于同步状态值的设计" class="headerlink" title="关于同步状态值的设计"></a>关于同步状态值的设计</h4><p>在ReentrantLock中，如何记录线程已经获得锁资源的次数呢？回顾代码设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 只有state为0时，其他线程才有机会争抢独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 同一线程再次获取独占锁，同一线程重入锁</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock仅有一个state值，对于同一线程执行<code>lock.lock()</code>n次，那么state变为n，表示此线程获取独占锁n次或者说重入n次（当然也要求此线程要释放n次），既然是独占锁，那么就不会出现这种情况：有多个不同线程同时成功更改state，也即同一个时刻，仅能有个线程CAS更改成功。</p><p>而在ReentrantReadWriteLock的同步状态值中，state的设计非常巧妙，使用高16位作为读锁重入的计数，低16位作为线程写锁重入的计数</p><blockquote><p>对于一个int值通过位运算实现不同场景下的计数，在Doug Lea的并发设计里面一个高级的手段：例如在ConcurrentHashMap里面的resizeStamp也采用这种移位计算状态的策略，还有ConcurrentHashMap的TreeBin读写锁设计也是采用位运算策略。</p></blockquote><p>高16位作为读锁重入的计数有两种情况：</p><p>（1）此高16位的数值可表示同一读线程的请求的读锁总数（总重入数）</p><p>（2）此高16位的数值可表示多个读线程同时请求到读锁总数</p><p>低16位作为写锁计数的情况仅有一种：</p><p>因为写锁是独占锁，因此低16位一定是表示同一写线程请求的总独占锁数量（总重入数）</p><p>以下是读写锁的同步计数移位计算的设计</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SHARED_SHIFT   = 16</span><br><span class="line">（1）读锁设计</span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);  用于获取state高16的读锁总数</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">// 1右移16位，对应的就是SHARED_UNIT</span><br><span class="line">0000 0000 0000 0001 0000 0000 0000 0000</span><br><span class="line"></span><br><span class="line">如何获取读锁总数？</span><br><span class="line">0000 0000 0000 0110 0000 0000 0000 0010;某一时刻state的值</span><br><span class="line">对其左移16位：</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0110</span><br><span class="line">因此可以快速得出读锁数量：6个读锁（当然也同时存在某个线程重入2次的写锁）</span><br><span class="line">以上就是sharedCount的设计</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line">如何实现读锁加1呢？如果直接state+1，那么这个加1是加在低位上，显然不合理，其实也很简单：</span><br><span class="line">state+(1&lt;&lt;SHARED_SHIFT)，这就实现在在高16位的读锁加1 </span><br><span class="line"></span><br><span class="line">（2） 写锁设计</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; 用于获取state低16位的写线程数量</span><br><span class="line">任意的state值和这个独占锁掩码相与后即可得到state的低16位置,例如下面</span><br><span class="line">0000 0000 0000 0110 0000 0000 0000 0010 ；;某一时刻state的值</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111 ；独占锁掩码</span><br><span class="line">两者取与后，得到写线程数量：</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">因此可以快速得出写锁数量：2个写锁（当然也同时存在6个读锁）</span><br><span class="line">以上exclusiveCount的设计</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">写锁如何加1？</span><br><span class="line">state+(1 &amp; EXCLUSIVE_MASK),显然state+1就是在state的低16位上做累加，计算公式合理</span><br><span class="line">写锁如何加n?</span><br><span class="line">state+(n &amp; EXCLUSIVE_MASK),显然state+n就是在state的低16位上做累加，计算公式合理</span><br><span class="line"></span><br><span class="line">（3）读锁最大可重入数量为65535，当然写锁也是</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1</span><br><span class="line">0000 0000 0000 0001 0000 0000 0000 0000 减1 也即：</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111 </span><br></pre></td></tr></table></figure><h4 id="写锁实现"><a href="#写锁实现" class="headerlink" title="写锁实现"></a>写锁实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个读写锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock(); </span><br><span class="line"><span class="comment">// 2、请求写锁</span></span><br><span class="line">rwl.writeLock().lock(); </span><br></pre></td></tr></table></figure><p>原来写锁的获取并不像ReentrantLock使用<code>lock.lock()</code>的方式，而是通过<code>writeLock().lock()</code>获取，从方法名就知道这样设计为了方便使用者知道当前使用什么类型的锁。</p><p>首先看其构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">   * default (nonfair) ordering properties.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;  <span class="comment">// 默认构造器使用的是非公平模式</span></span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> ReentrantReadWriteLock&#125; with</span></span><br><span class="line"><span class="comment">   * the given fairness policy.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">      sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">      readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);  <span class="comment">// new时就已经实例化一个readerLock 对象和 writerLock 对象</span></span><br><span class="line">      writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync当然是ReentrantReadWriteLock内部核心实现类，实现了AQS的tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared的关键逻辑，以及其他辅助方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// <span class="title">WriteLock</span>和 <span class="title">ReadLock</span> 都是<span class="title">ReentrantReadWriteLock</span>内部类</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">ReentrantReadWriteLock</span>.<span class="title">WriteLock</span> <span class="title">writeLock</span>() </span>&#123; <span class="keyword">return</span> writerLock; &#125; </span><br><span class="line">  <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h5 id="WriteLock实现类"><a href="#WriteLock实现类" class="headerlink" title="WriteLock实现类"></a>WriteLock实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for use by subclasses</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// WriteLock的调用点是在ReentrantReadWriteLock的构造器中：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public ReentrantReadWriteLock(boolean fair) &#123;</span></span><br><span class="line"><span class="comment">        sync = fair ? new FairSync() : new NonfairSync();</span></span><br><span class="line"><span class="comment">        readerLock = new ReadLock(this);  </span></span><br><span class="line"><span class="comment">        writerLock = new WriteLock(this);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span>     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the write lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the write lock if neither the read nor write lock</span></span><br><span class="line"><span class="comment">     * are held by another thread</span></span><br><span class="line"><span class="comment">     * and returns immediately, setting the write lock hold count to</span></span><br><span class="line"><span class="comment">     * one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread already holds the write lock then the</span></span><br><span class="line"><span class="comment">     * hold count is incremented by one and the method returns</span></span><br><span class="line"><span class="comment">     * immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is held by another thread then the current</span></span><br><span class="line"><span class="comment">     * thread becomes disabled for thread scheduling purposes and</span></span><br><span class="line"><span class="comment">     * lies dormant until the write lock has been acquired, at which</span></span><br><span class="line"><span class="comment">     * time the write lock hold count is set to one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 从这里可以看出：类似的用户程序使用rwl.writeLock().lock()时，其实就是调用AQS的独占锁的获取锁逻辑：acquire(1)，显然既然是独占锁，那么获取逻辑自然跟ReentrantLock的lock()是类似的，也即AQS的acquire方法.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ...<span class="comment">//WriteLock类其他省略部分</span></span><br><span class="line">              </span><br></pre></td></tr></table></figure><p>显然<code>sync.acquire(1)</code>对应内部的AQS逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tryAcquire由ReentrantReadWriteLock的sync实现</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写锁获取-tryAcquire"><a href="#写锁获取-tryAcquire" class="headerlink" title="写锁获取-tryAcquire"></a>写锁获取-tryAcquire</h5><p>要知道所谓的写锁获取，其实就是独占锁的请求，要么仅能一个线程拥有此独占锁，要么同一线程重入独占锁多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Walkthrough:攻略或玩法，也即tryAcquire的成功与否的策略</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 当前同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 当前写锁计数（需要利用移位来计算出）</span></span><br><span class="line">  <span class="comment">// 由于同步状态可以表征读锁计数和写锁计数，因为当前线程想获取写锁，因此它需要判断：同步状态值不为0到底是指有其他线程获取到了写锁还是获取了读锁还是都被获取？</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 1、c != 0且写锁计数为0，说明当前线程持有读锁，不允许请求写锁（否则就是持有读锁情况下拿到写锁，那么这个读锁就不是共享模式读锁，而是变相的独占锁，显然违背了ReentrantReadWriteLock的功能设计初衷）；或者说“当前线程持有读锁且不释放读锁的情况下，不允许升级为写锁，否则读锁就变相的成为了独占锁”</span></span><br><span class="line">       <span class="comment">// 2、写锁计数不为了0，说明是当前线程正在重入独占锁，如果不是同一线程请求，写锁当然请求失败，返回false</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 3、是当前线程重入的写锁请求，但重入次数超过最大值，直接抛出异常提示</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">      <span class="comment">// 4、说明是同一线程的写锁重入，累加计数后，允许通过请求锁。</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 5、执行流来到这里说明c等于0，说明此刻暂时还没其他线程在竞争读、写锁，那么当前线程可以去CAS抢锁</span></span><br><span class="line">  <span class="comment">/* writerShouldBlock() 是用于是否使用公平模式抢锁策略，对于写锁获取策略来说，显然是false，如下所示</span></span><br><span class="line"><span class="comment">static final class NonfairSync extends Sync &#123;</span></span><br><span class="line"><span class="comment">private static final long serialVersionUID = -8159625535654395037L;</span></span><br><span class="line"><span class="comment">  final boolean writerShouldBlock() &#123; return false; // writers can always barge ，写锁获取只能直接争抢</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">因此这里的if第一个writerShouldBlock()返回false然后第二个条件就是去跟其他写线程CAS抢锁了，失败那么只能返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 6、对于c != 0，说明此写线程重入成功，对于c=0，说明此线程是第一个获得独占锁的线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写锁释放-tryRelease"><a href="#写锁释放-tryRelease" class="headerlink" title="写锁释放-tryRelease"></a>写锁释放-tryRelease</h5><p>用户代码层面，只需调用<code>rwl.writeLock().unlock()</code>来释放写锁，需要注意的是，这里指代独占锁的释放，意味着要么已经拥有独占锁的写线程释放此锁，要么已经重入独占锁的写线程退出重入锁 </p><p>（读锁的释放也会使用此方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is the holder of this lock then</span></span><br><span class="line"><span class="comment">     * the hold count is decremented. If the hold count is now</span></span><br><span class="line"><span class="comment">     * zero then the lock is released.  If the current thread is</span></span><br><span class="line"><span class="comment">     * not the holder of this lock then &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * IllegalMonitorStateException&#125; is thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if the current thread does not</span></span><br><span class="line"><span class="comment">     * hold this lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//按照注释提示：</span></span><br><span class="line"><span class="comment">// 1、如果当前线程是重入的，那么每次unlock就是对重入次数减1，也即此线程内部写锁计数hold count 减1 （注意，如果hold count减1后不为0，此写线程是不会释放独占锁的）</span></span><br><span class="line"><span class="comment">// 2、如果当前线程的不是重入，仅是获取独占锁一次，那么当它调用unlock时，显然state变为0，意味着是释放独占锁，其他线程可以争抢此独占锁了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">     * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">     * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">     * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 释放锁的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// 扣减释放量</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; <span class="comment">// 这里的free是指写锁释放完全释放，如果等于0，说写锁完全被释放。</span></span><br><span class="line">      <span class="comment">// 如果为0，说明写锁完全被释放，其他线程（含读、写线程）可以争抢了</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// free不为0，说明是同一线程重入写锁后，现在是释放自己重入的写锁，也即“重入-退出”操作，将state设为扣减后的值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="读锁实现"><a href="#读锁实现" class="headerlink" title="读锁实现"></a>读锁实现</h4><p>读锁的实现类最关键的还是<code>lock</code>和<code>unlock</code>方法，具体实现由<code>ReentrantReadWriteLock</code>  内部的<code>Sync</code>类的<code>tryAcquireShared</code>和<code>tryReleaseShared</code>对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The lock returned by method &#123;<span class="doctag">@link</span> ReentrantReadWriteLock#readLock&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for use by subclasses</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock the outer lock object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the lock is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the read lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">     * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">     * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">     * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>); <span class="comment">// 具体获取读锁的逻辑在tryAcquireShared实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 响应中断的获取读锁方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即时返回是否成功获取读锁，显然如果写锁别其他线程持有，那么此时tryLock() 立即返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否读锁，具体释放读锁的逻辑在tryReleaseShared实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125; because</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> ReadLocks&#125; do not support conditions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string identifying this lock, as well as its lock state.</span></span><br><span class="line"><span class="comment">     * The state, in brackets, includes the String &#123;<span class="doctag">@code</span> &quot;Read locks =&quot;&#125;</span></span><br><span class="line"><span class="comment">     * followed by the number of held read locks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a string identifying this lock, as well as its lock state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = sync.getReadLockCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">            <span class="string">&quot;[Read locks = &quot;</span> + r + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读锁获取-tryAcquireShared"><a href="#读锁获取-tryAcquireShared" class="headerlink" title="读锁获取(tryAcquireShared)"></a>读锁获取(tryAcquireShared)</h5><p>调用者使用<code>rwl.readLock().lock()</code> 获取读锁，内部调用是acquireShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires the read lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment"> * another thread and returns immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment"> * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireShared当然是AQS的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 只要ReentrantReadWriteLock的tryAcquireShared获取读锁方法返回-1，就说明当前线程没能马上获得读锁，得去CLH排队等待</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared</code>则是<code>ReentrantReadWriteLock</code>实现请求读锁的关键逻辑</p><p>其实<code>tryAcquireShared</code>总逻辑分为4部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 第1部分：全局存在写锁且不是当前线程持有，因此当前线程不能获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 第2部分：全局层面获得读锁</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 第3部分:&#123;第2部分的全局层面获得读锁后，还得对当前线程自己持有的读锁计数进行相关管理&#125;，这部分最为核心，也是最难理解的部分。</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 第2部分的全局层面获得读锁，必然返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第4部分：在全局层面获取读锁失败，使用以下全面尝试获取读锁的逻辑去获取读锁，增加当前线程获取读锁的概率。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">//1、 当前state存在写锁计数但不是当前线程持有，那么不容许获取读锁，因为两者被设计为是互斥的，换句话说：在有写锁存在的条件下，只能是已经持有写锁的当前线程才能获取当前读锁，当然这种情况被称为“锁降级”。想想为何？</span></span><br><span class="line">           <span class="comment">//  因为如果存在写锁的条件下但不是当前线程持有，还去允许当前线程获取读锁的话，这不就等价于将别人占有的写锁“抢了过来”，这显然是不符合ReentrantReadWriteLock的读写互斥设计的。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          <span class="comment">//2、当前state拥有的读锁数量</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">          <span class="comment">//3、如果此时读线程是非公平模式且读锁计数小于最大值且CAS更新读锁计数加1成功，那么就执行此if里面的条件</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123; </span><br><span class="line"><span class="comment">// 在state的高16位累加1，也即使得所有线程总的读锁计数加1,执行流来到这里，说明当前线程已经成功获得读锁，下面就是要完成当前线程持有读锁的计数管理相关逻辑。</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">//4、在2读取的r值如果为0，说明当前线程是第一个进来请求读锁的线程，记为firstReader</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>; <span class="comment">// 记录第一个读线程的重入数量，首次当然是1 </span></span><br><span class="line">               <span class="comment">//  5、 如果在第2点读取的读锁数量不为0且当前线程就是之前的第一个读线程，说明是重入，对第一个读线程的重入进行计数加1 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">               <span class="comment">// 6、以下的读锁设计比较难理解，参考后面的内容分析。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 读取“全局缓存计数器”，注意到此“全局缓存计数器”只缓存“最新成功获取读锁的那个线程”：The hold count of the last thread to successfully acquire readLock，目的是This saves ThreadLocal lookup，避免回到ThreadLocalHoldCounter的readHolds去查找。</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                   <span class="comment">/* 6.1 </span></span><br><span class="line"><span class="comment">                  情况1 如果此“全局缓存计数器”变量为空，说明在此刻之前没有“最新成功获取读锁的那个线程””出现，那么当前线程自然可以将自己设为“最新成功获取读锁的那个线程”这个角色</span></span><br><span class="line"><span class="comment">                  情况2 如果此“全局缓存计数器”变量不为空但已经缓存“最新成功获取读锁的那个线程”，而这个缓存线程又不是当前线程，说明当前线程从此刻起将成为“最新成功获取读锁的线程”角色。</span></span><br><span class="line"><span class="comment">                  针对情况1和情况2，既然当前线程在此刻已经成为“最新成功获取读锁的线程”角色，那么当前线程取出自己的计数器并放入“全局缓存计数器”：cachedHoldCounter = rh = readHolds.get()。这样就保证了cachedHoldCounter会一直指向“最新成功获取读锁的线程”  </span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="comment">/*6.2</span></span><br><span class="line"><span class="comment">                   说明6.1两个条件都不成立，说明“全局缓存计数器”缓存的恰好是当前线程，如果缓存的读锁计数为0，那么说明这个线程是在上一刻释放了自己持有的最后一个读锁且将“全局缓存计数器”计数减至0（并且它会调用readHolds.remove()移除了rh计数器对象，这一操作可以发生在tryReleaseShared中），现在这一刻此线程又再次进来作为“最新成功获取读锁的线程”，而此刻当前线程自己readHolds并没有放置计时器，于是作为“最新成功获取读锁的线程”，当前线程再将计数器放入到自己的“ThreadLocalHoldCounter的readHolds中”。</span></span><br><span class="line"><span class="comment">                   */</span> </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）"><a href="#关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）" class="headerlink" title="关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）"></a>关于“当前线程自己持有的读锁计数进行相关管理”的设计（ReentrantReadWriteLock最核心的设计）</h5><p>首先，读锁的计数需要在两个层面上进行去理解：</p><p>所有线程请求的总读锁计数的加1操作，使用以下方式记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 也即每个线程，只要请求读锁成功，那么读锁总数对应加1（state的高16位加1）  </span></span><br><span class="line"><span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">           r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">           compareAndSetState(c, c + SHARED_UNIT)) &#123; </span><br></pre></td></tr></table></figure><p>其次，还需要记录每个线程自己请求读锁的数量（或者重入读锁的次数），也即“当前线程自己持有的读锁计数进行相关管理”。这里解释为何每个线程需要记录自己读锁的数量，这是因为ReentrantReadWriteLock设计的读锁是可重入的，那么每个线程管理自己的读锁数量后，可以方便进行且准确的加锁、释放锁操作（自己重入多少次，就需要释放多少次）以及是否需要进入排队操作。<code>而compareAndSetState(c, c + SHARED_UNIT)</code>是记录所有线程的总读锁数量的设计，显然无法实现“当前线程自己持有的读锁计数进行相关管理”的功能。</p><p>这种要实现“每个线程自己的状态管理和线程关联起来”的场景，ThreadLocal无疑是最适合的，这在“ThreadLocal的源代码设计的深度解析”的文章中已提及过。在这里通过设计一个计数器HoldCounter并放入到ThreadLocal，也即ThreadLocalHoldCounter，即可实现线程安全方式实现“当前线程自己持有的读锁计数进行相关管理”的需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解本节内容的前提是掌握ThreadLocal的底层设计原理及其源代码实现，否则无法掌握其设计内涵。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">     * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 1、此辅助对象就是为了记录当前线程请求读锁的次数，目的是为了知道此线程第一有没有持有读锁，第二持有读锁情况下重入多少次。交由ThreadLocal来维护。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 记录当前线程的读锁请求次数</span></span><br><span class="line">        <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">      <span class="comment">// 当前线程的内存地址ID号，用于一些特别场景例如下面的cachedHoldCounter</span></span><br><span class="line"><span class="comment">// 使用线程ID号而不是对象可以有效优化GC</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2、通过ThreadLocal维护HoldCounter的更新，实现每个线程能线程安全的方式去管理持有读锁的计数。</span></span><br><span class="line"><span class="comment">// 这里是设定HoldCounter的初始化值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">     * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">     * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 3、当前线程持有读锁的重入次数，如果不为0，说明当前线程肯定持有读锁,需要注意它的灵活用法:</span></span><br><span class="line"><span class="comment"> 总体上一定要遵守“当前线程不再持有读锁时，当前线程的ThreadLocal对象一定不能还存放着HoldCounter对象，否则HoldCounter是强引用，会造成当前线程的ThreadLocal出现内存泄露的风险”</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 3.1 一旦当前线程释放自己持有的最后一个读锁，说明当前线程不再需要持有“读锁计时器”引用来给自己计算读锁数量，那么当前线程还需要做多一个操作： readHolds.remove(),保证当前线程不再引用此“ThreadLocal变量”的读锁计数器，从而避免当前线程的ThreadLocal内存泄露，对应的代码逻辑（此逻辑一般在释放锁的操作中实施）：</span></span><br><span class="line"><span class="comment">       if (count &lt;= 1) &#123;</span></span><br><span class="line"><span class="comment">                readHolds.remove();</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> readHolds = new ThreadLocalHoldCounter() ,当然此初始化已经被上面initialValue取代了。</span></span><br><span class="line"><span class="comment"> 每个线程持有的readHolds初始值：count=0，tid=此线程内存地址ID</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 3.2 如果当前线程查询自己readHolds的rh.count=0,说明当前线程是第一次成功获取读锁，考虑当前线程以后可能有重入读锁，那么此时可以将自己“读锁计数器” rh放到readHolds里面，对应的代码逻辑（此逻辑一般在请求读锁的操作中实施）：</span></span><br><span class="line"><span class="comment">         else if (rh.count == 0)</span></span><br><span class="line"><span class="comment">                    readHolds.set(rh);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">     * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">     * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">     * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">     * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">     * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">     * reference to the Thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model&#x27;s final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此cachedHoldCounter从名字可以直到它是一个缓存的读锁计数器，那么它是缓存哪个线程的读锁计时器呢？</span></span><br><span class="line"><span class="comment">// 缓存的是“最近（最新）获得读锁的那个线程的读锁计数器”，例如Thread-0、Thread-1、Thread-2三个线程并发竞争读锁，如果Thread-1是最后一个成功获取读锁的线程，那么cachedHoldCounter就会缓存Thread-1的读锁计数count=1和Thread-1对应的内存地址ID号。当然如果后面还有最新的来的Thread-xx，那么cachedHoldCounter就会马上更新缓存Thread-xx的信息。</span></span><br><span class="line"><span class="comment">/* 这个缓存cachedHoldCounter有何作用呢？ </span></span><br><span class="line"><span class="comment">（1）在前面ThreadLocalHoldCounter中，每个线程HoldCounter由ThreadLocal维护，如果此线程需要查询自己的读锁计数，需要使用ThreadLocal里面的get方法，而此get方法会调用ThreadLocal里面ThreadLocalMap的getEntry方法，了解ThreadLocal的底层设计都知道这一get操作还可能引起ThreadLocalMap的额外清理操作，这无疑降低查询效率，因此干脆设计用于“具有缓存功能、快速查询”的cachedHoldCounter，如果当前线程恰好就是设置cachedHoldCounter的线程，那么它直接在cachedHoldCounter就可以拿到自己的读锁数，完全不需要调用ThreadLocal里面get方法来查询（避免了在ThreadLocalMap内部的一系列操作）通过这种方式，当前线程在读锁重入时能提高加锁效率。</span></span><br><span class="line"><span class="comment">  （2）当前如果读锁竞争激烈，那么假设线程加锁后缓存了Thread-1，在Thread-1释放锁前，又有其他线程Thread-2、Thread-3请求了读锁，那么cachedHoldCounter就会一直更新，这种情况导致Thread-1需要调用ThreadLocal查询自己的读锁计数。可以说Thread-1在请求读锁重入锁期间没有“享受到缓存带来的性能提升”</span></span><br><span class="line"><span class="comment">  正如源码注释里面的说的：This is non-volatile since it is just used as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">  因为这是被设计为一个试探性的缓存，因此不需要设为volatile类型，如果当前线程试探性去查询发现此缓存是自己加锁后设置的缓存，那么就可以提高此线程的本次加锁和释放读锁的性能，如果不是自己设置缓存，那就稍微牺牲一点性能ThreadLocal（在内部的ThreadLocalMap）去查询。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">     * firstReaderHoldCount is firstReader&#x27;s hold count.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">     * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">     * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">     * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">     * sets it to null.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model&#x27;s out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">     * locks to be very cheap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* 以下两个成员也是为了提升读锁加速的性能。认真看其源码注释说：更准确地说，firstReader是指向一个线程———这个线程是让总读锁计数从0变为1的线程。注意需要用动态的思维看待这样的解释。简单来说就是第一个获得读锁的线程，firstReaderHoldCount显然就是第一个获得读锁线程的重入计数</span></span><br><span class="line"><span class="comment">那么在什么场景下firstReader和firstReaderHoldCount起到提升性能的作用呢？</span></span><br><span class="line"><span class="comment">对于这种有序获取读锁的场景，优化效果明显，例如，</span></span><br><span class="line"><span class="comment">Thread-0加锁-释放锁后，接着Thread-1才开始请求读锁，Thread-1释放读锁，然后Thread-2才开始请求读锁....</span></span><br><span class="line"><span class="comment">可以这么理解：</span></span><br><span class="line"><span class="comment">当Thraed-0作为第一个请求读锁的线程，它从加锁到释放锁的代码执行期间，此时Thread-1还没开始启动请求读锁。那么当Thread-0再次重入锁时（而且此刻还没其他线程来请求读锁），显然只需查询firstReaderHoldCount自己的读锁计数即可，无需进入自己的ThreadLocal里面去查询读锁计数，因为进入ThreadLocal去查询意味着要去ThreadLocalMap查询（get操作还可能引起清理stale entry）意味着降低查询效率。</span></span><br><span class="line"><span class="comment">这就是注释所说的：This allows tracking of read holds for uncontended read locks to be very cheap. 能够使用最小代价去追踪那种非竞争线程获取的读锁计数</span></span><br><span class="line"><span class="comment">uncontended read locks：一个线程拥有读锁的时候，没有其他线程企图获得读锁（也就是非并发竞争的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p>可以看到，读锁的获取设计确实较为复杂，因为Doug Lea为了实现在某些非竞争情况下请求锁性能的提升，采用了非常高技巧的“fast path”策略——先试探性执行某个“快速”操作，如果没命中那就再执行那个“相对耗时”的操作。（这种设计思想其实在ConcurrentHashMap里面的<code>addCount</code>和<code>fullAddCount</code>已经体现过）</p><p>其次可以通过一个内部方法快速理解线程自己管理的读锁计数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 获取当前线程想获取自己持有读锁的数量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 如果总读锁数量为0，那么当前线程持有的读锁数量肯定也为0</span></span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2. 看看自己是否为第一个获取读锁的角色，如果是，好办直接使用firstReaderHoldCount存储的数量即可，无需进入到ThreadLocal里面查询</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line"><span class="comment">// 3. 说明当前线程不是“第一个获取读锁”的线程，那就看看“全局缓存计时器”缓存的是哪个线程的</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 4. 如果存在“全局缓存计时器”且缓存的就是当前线程自己，那么说明当前线程一定是“最新获取读锁的那个线程”，返回缓存的计数即可</span></span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="comment">// 5. 说明自己不是“最新获取读锁的那个线程”，当然也不是“第一个获取读锁的角色”，因此要读取自己持有的读锁计数，显然要先取出自己在ThreadLocal放置的计时器</span></span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">    <span class="comment">// 6. 自己在ThreadLocal放置的计时器的读锁数量已经变为0，说明当前线程接下来已经不再持有读锁，也即不需要再借助“计数器”，那么应该及时在自己的ThreadLocal变量删除此“计数器对象”——ThreadLocalHoldCounter</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有了以上缓存和快速试探的算法设计以及线程自己是如何管理自己持有的读锁的分析后，那么<code>fullTryAcquireShared</code>的算法流程才相对好理解。</p><h5 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h5><p>处理“快速尝试tryAcquireShared中CAS失败更新总读锁”的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">     * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 正如注释里面说的：专为快速尝试tryAcquireShared中CAS失败更新总读锁、重入读锁的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">         * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">         * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">         * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">// 注释也说到fullTryAcquireShared的总体代码实现跟tryAcquireShared大体类似（有部分冗余）</span></span><br><span class="line">        HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 自旋+内部CAS，保证了当前线程一定会在某个时机上成功拿到读锁，或在某个时机拿不到锁然后被放入CLH阻塞队列里面排队</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">          <span class="comment">// 1、同tryAcquireShared的设计，同步状态存在写锁，且是其他线程持有的写锁，显然当前线程无法获取读锁，因为不同线程的写、读锁请求是互斥的。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// A</span></span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              <span class="comment">// else return -1</span></span><br><span class="line">              <span class="comment">//补充技术点：注意到这里有个死锁的解释：假设给A配一个else分支，返回-1，那么就使得持有写锁的当前线程进入阻塞队列，它持有的写锁一直不会释放，而外面的线程又等着这个写锁的释放，因此进入了死锁困境，所以不能在这里return -1。换句话说，不要试图阻塞已持有的独占锁线程，否则会出现死锁意外。其实这种合理的设计在AQS的条件队列await里面的“addConditionWaiter然后fullyRelease”有提到（进了条件队列后，阻塞前把自己持有的所有独占锁完全释放掉）</span></span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line">              <span class="comment">// 2、来到这里说明此时写锁计数为0，暂时没有其他线程请求写锁，当前线程可以去请求读锁但遗憾的是readerShouldBlock为true时，表示当前线程需要被阻塞，而if里面的逻辑并没有关于“进入CLH阻塞队列排队的操作”，原来这里的if是这么设计的：既然当前线程待会要进去阻塞队列，那么在它进去之前，要求当前线程先处理好自己的读锁计数情况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 如果存在这样的场合：假设某线程AA在某次tryAcquireShared请求读锁成功，然后在某次重入读锁时tryAcquireShared没有抢到读锁只能调用fullTryAcquireShared来处理重入锁时，线程AA来到if (readerShouldBlock()) 为true情况，接下里怎么安排呢？ 以下就是对应的处理策略：                 </span></span><br><span class="line">              <span class="comment">// 3.1 如果当前线程就是第一个加读锁的线程，说明是重入读锁，即使readerShouldBlock为true，当前线程也不需要去阻塞队列排队（也即不需要在这里return -1），因为对于重入锁情况，直接它进入下面的第11位置执行重入锁逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                  <span class="comment">// 并没有直接返回-1</span></span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3.2 说明当前线程不是firstReader也不是firstReader的重入，而是此线程是第一次竞争读锁，但因为大前提readerShouldBlock是true，因此此线程一定会进入CLH阻塞队列。</span></span><br><span class="line">                <span class="comment">// 4、 </span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                      <span class="comment">//5、</span></span><br><span class="line">                      <span class="comment">// 5.1 当前线程（显然是非firstReader角色）如果是第一次请求读锁，发现cachedHoldCounter还是空或者里面缓存不是自己的，从自己的ThreadLocal取出HoldCounter对象,然后进入6.1</span></span><br><span class="line">                      <span class="comment">// 5.2 当前线程是重入锁的情况，显然rh不是null，且6.1的判断不成立,会走入7.2逻辑</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                          <span class="comment">// 6、</span></span><br><span class="line">                          <span class="comment">//  6.1 对接5.1 由于当前线程是第一次请求读锁，但此时并没有拿到读锁，需要清空自己的ThreadLocal里面的HoldCounter对象，然后会来到7.1。因为这个线程将被送入CLH阻塞队列中，既然它准备要在阻塞队列了，那么它的ThreadLocal存放的HoldCounter对象要移除，避免ThreadLocal造成此线程的内存泄露。然后会进入7.1步骤</span></span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 7、</span></span><br><span class="line">                  <span class="comment">// 7.1 当前线程第一次请求读锁,此时它持有读锁数量是0，由于readerShouldBlock为true，因此当前线程不能直接竞争读锁要去阻塞队列排队等待，因此返回-1</span></span><br><span class="line">                  <span class="comment">// 7.2 当前线程是重入情况，显然rh.count不等于0，因此会进入第12的重入锁累加</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8、 读锁总数达到最大值</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">          <span class="comment">// 9、如果当前线程CAS对总读锁加1成功，那么结果一定是返回1，中间逻辑就是线程对自己的计数器加1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//10、发现此时读锁为0，那么当前线程就变成firstReader角色。</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 11、firstReader的重入  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                <span class="comment">// 12、 当前线程（其他线程，非firstReader角色）的第一次请求读锁或者重入锁的情况 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 12.1 rh为空，说明准备要将缓冲计时器cachedHoldCounter指向当前“最新成功获取读锁的线程”</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">/* 12.2 </span></span><br><span class="line"><span class="comment">              情况1 如果此“全局缓存计数器”变量为空，说明在此刻之前没有“最新成功获取读锁的那个线程””出现，那么当前线程自然可以将自己设为“最新成功获取读锁的那个线程”这个角色</span></span><br><span class="line"><span class="comment">              情况2 如果此“全局缓存计数器”变量不为空但已经缓存“最新成功获取读锁的那个线程”，而这个缓存线程又不是当前线程，说明当前线程从此刻起将成为“最新成功获取读锁的线程”角色。</span></span><br><span class="line"><span class="comment">              针对情况1和情况2，既然当前线程在此刻已经成为“最新成功获取读锁的线程”角色，那么当前线程取出自己的计数器并放入“全局缓存计数器”：放入的前提是rh.count == 0，说明当前线程是“最新成功获取读锁的线程”且不是重入的，cachedHoldCounter = rh = readHolds.get()。这样就保证了cachedHoldCounter会一直指向“最新成功获取读锁的线程”  。</span></span><br><span class="line"><span class="comment">              如果当前线程是重入请求读锁，那么这里if (rh.count == 0)就不会成立，自然不会有readHolds.set(rh)</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 当前线程（其他线程，非firstReader角色）增加自己的读锁计数器，并将缓存设置为自己的 </span></span><br><span class="line">                    rh.count++;</span><br><span class="line">                  </span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实<code>fullTryAcquireShared</code>考虑到两种角色的线程处理，而每种角色有对应着“第一次请求读锁”和“重入读锁”的两种情况，这导致了<code>fullTryAcquireShared</code>设计的复杂性</p><p>第一种角色的线程：<code>firstReader</code></p><p>当<code>readerShouldBlock</code>为true时（意味着此线程要进行排队，但有例外：重入锁情况不需要排队）：</p><p>（1）如果<code>firstReader</code> 是重入的，不需要返回-1，也即不需要进入CLH阻塞排队，直接进入第11位置的重入锁加1逻辑</p><p>第二种角色的线程：非<code>firstReader</code>角色，也即不是第一个请求读锁的线程</p><p>当<code>readerShouldBlock</code>为true时（意味着此线程要进行排队，但有例外：重入锁情况不需要排队）：</p><p>（1）如果当前线程（非<code>firstReader</code>角色）是重入的，此时<code>rh.count!=0</code>不需要返回-1，也即不需要进入CLH阻塞排队，直接进入第11位置的重入锁加1逻辑</p><p>（2）如果当前线程（非<code>firstReader</code>角色）是第一次请求读锁，但因为<code>readerShouldBlock</code>为true，表示需要进入阻塞队列排队，因此会满足<code>rh.count=0</code>返回-1，此线程进入阻塞队列</p><p>或者用更为简洁的话：</p><p>如果其他线程是第一次获取读锁，因为<code>readerShouldBlock</code>为true，因此就要返回-1，这样这种线程才会被安排到CLH队列去排队，符合“ShouldBlock的要求”。又因为这些线程第一次获取读锁就需要被安排到CLH排队，因此他们持有的计数器对象如果rh.count=0,就需要readHolds.remove()，这样保证了入队后，这个线程首先没有持有读锁且能对应没有持有读锁计数器，保证了这些线程不会发生“ThreadLocal内存泄露”。</p><p>如果是<code>firstReader</code>是重入锁或者其他线程做重入锁，那么对自己的HoldCount进行加1计数后返回1，表示重入锁成功。</p><h5 id="关于读锁的非公平设计readerShouldBlock"><a href="#关于读锁的非公平设计readerShouldBlock" class="headerlink" title="关于读锁的非公平设计readerShouldBlock"></a>关于读锁的非公平设计readerShouldBlock</h5><p>如果<code>ReentrantReadWriteLock</code>在初始化给定的是非公平模式，那么其设计思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nonfair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要到这里的readerShouldBlock方法都会在<code>tryAcquireShared</code>和<code>fullTryAcquireShared</code>使用，具体实现是<code>apparentlyFirstQueuedIsExclusive</code>,注释说它可以“试探性”的（或者说在一定概率上）防止在阻塞队列等待的写线程节点发生“锁饥饿”情况。</p><p>为何会出现“阻塞队列等待的写线程节点发生“锁饥饿”情况”?</p><p>假设现在有一个写锁节点已经在阻塞队列，结构如下：</p><p>head(null,-1)&lt;-&gt;node(写线程,0)</p><p>在<code>fullTryAcquireShared</code>中，如果<code>readerShouldBlock</code>的非公平模式设计为直接返回false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）假设现在有新来的10个线程Thread-1~Thread-10并发请求读锁的线程，那么按照<code>readerShouldBlock</code>返回false的逻辑，他们可以直接竞争第一次请求锁或者重入锁，不妨假设这些请求读锁的10个线程都恰好领先于阻塞队列的写线程获取锁（毕竟新来的线程拿到CPU时间片的概率要比阻塞队列里面的写线程要高），那么就会导致此写线程根本无机会去请求锁，只能一直“委屈的在阻塞队列里面等待”，也即发生了“锁饥饿”情况。</p><p>那么如何优化这种极限情况？这就是<code>apparentlyFirstQueuedIsExclusive</code>方法要解决的。</p><p>（2）从方法的命名也可以看出它的含义：阻塞队列的第一个排队节点是否就是独占模式节点（在本文可以理解为：阻塞队列的第一个排队节点是否就是写线程节点），如果是独占模式节点，那么<code>readerShouldBlock</code>就会返回true，就会使得那些新来的请求读锁的线程们不能直接去竞争锁资源，而是被安排到阻塞队列去排队等候，这就使得阻塞队列的第一个写线程节点能够出队去竞争锁资源了，从而避免在（1）提到的“锁饥饿”情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment"> * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment"> * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment"> * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment"> * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="comment">// 1、存在阻塞队列</span></span><br><span class="line">  <span class="comment">// 2、阻塞队列至少有1个线程节点在排队</span></span><br><span class="line">  <span class="comment">// 3、且第一个线程节点是独占模式节点</span></span><br><span class="line">  <span class="comment">// 4、且第一个线程节点线程未取消</span></span><br><span class="line">  <span class="comment">// 如果以上4个条件同时成立，那么就会返回true，也即readerShouldBlock返回true</span></span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑可以结合以下两种情况来理解：</p><p>第一种情况：</p><p>外面的新来的线程们：Thread-1~Thread10</p><p>阻塞队列的情况：head(null,-1)&lt;-&gt;node(写线程,0)</p><p>因此,根据<code>apparentlyFirstQueuedIsExclusive</code>的第三个条件，阻塞队列的第一个节点是独占模式节点（请求写锁的线程），那么<code>readerShouldBlock</code>就会返回true，要求外面的新来的线程们去阻塞队列排队等待，保证了此写线程能够出队抢锁。</p><p>第二种情况：</p><p>外面的新来的线程们：Thread-1~Thread10</p><p>阻塞队列的情况：head(null,-1)&lt;-&gt;node(读线程,-1)&lt;-&gt;node(写线程,0)</p><p>或者：head(null,-1)&lt;-&gt;node(读线程,-1)…….&lt;-&gt;node(写线程,0)</p><p>可以看到，阻塞队列里面的第一个线程节点为读线程节点，写线程排在第二或者其他更后面的位置，这时<code>apparentlyFirstQueuedIsExclusive</code> 显然因为<code>!s.isShared()</code>是共享模式节点而返回false，也即<code>`readerShouldBlock</code>就会返回false，那么外面新来的10个线程就会直接争抢锁资源而不需要排队，这会导致排在第二位置或者更后位置的写线程发生了一定程度的“锁饥饿”，因此只能说这种设计能够在一定程度上减少<code>writer starvation</code>，但不能保证一定杜绝<code>writer starvation</code>。</p><p>因此，正如<code>readerShouldBlock</code>里面的注释：a probabilistic effect 或者As a heuristic to avoid indefinite writer starvation，也即有一定概率性的。</p><p>这里不得不赞叹Dung Lea设计的读锁请求算法是如此的精妙和高超！</p><h5 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、用户代码</span></span><br><span class="line">rwl.readLock().unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、ReentrantReadWriteLock的unlock</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the number of readers is now zero then the lock</span></span><br><span class="line"><span class="comment">         * is made available for write lock attempts.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、调用的是AQS的releaseShared：共享锁释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、ReentrantReadWriteLock内部Sync定义的释放读锁逻辑</span></span><br><span class="line"><span class="comment">// 从读锁的加锁分析中可以推理出：有几种释放锁情况</span></span><br><span class="line"><span class="comment">// 第一：请求读锁然后马上释放锁的情况，</span></span><br><span class="line"><span class="comment">// 第二：已经是重入锁的情况去释放自己的重入锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">          <span class="comment">// 1、如果当前线程恰好是第一个拿到读锁的线程，那么对于首次加锁那么释放锁就是直接将firstReader置为null，否则说明是重入锁的释放，只需将自己持有的读锁计数减1</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 2、 非firstReader角色释放自己持有的读锁 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">              <span class="comment">// 2.1 如果缓存为空或者缓存的HoldCounter对象不是当前线程，那么就从当前线程的ThreadLocal取出它的HoldCounter对象赋给rh变量</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">              <span class="comment">// 2.2 如果原来持有的读锁&lt;=1,那么因为本次释放就会使得自己持有读锁计数变为0，对应要清除自己ThreadLocal存放的HoldCounter对象，这是因为考虑到ThreadLocal里面的entry是WeakReference类型，而HoldCounter是放在entry中，那么显然调用remove后，使得这个entry没有对象引用，加速GC回收。</span></span><br><span class="line">               <span class="comment">// 此外，当前线程因此已经准备要释放自己持有的最后一个读锁，说明释放后它就不不再需要计数，因此通过主动调用remove来避免ThreadLocal出现内存泄漏。</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();  <span class="comment">// 务必已经掌握了ThreadLocal的底层源码设计，否则这段将无法理解为何要使用remove。</span></span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 2.3 如果原来持有的读锁计数大于1，那么当前线程的本次释放并不是释放自己持有的最后一个读锁，而是重入锁的退出，只需对自己持有的重入锁计数器减1即可</span></span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//3、以上1和2步骤都是为了完成线程自己持有读锁的计数减1，那么下面使用自旋保证当前线程一定能使得总读锁计数state-1，如果释放后总锁（含读、写锁）剩余量刚好为0，那么当前下线程就会使用doReleaseShared去唤醒阻塞队里面正在等待的线程节点，尤其是被阻塞的写线程节点。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line"><span class="comment">/* 这里也说到：如果是读线程释放读锁，对于持有读锁的线程来说是无影响的，如何理解这句话？</span></span><br><span class="line"><span class="comment">          想象一下：假设有65535个线程并发使用lock请求读锁，并假设都可以拿到读锁（意味着每个线程拿到1个读锁）,此时state的高16位计数为65535，假设在下一刻有65534个线程同一时刻释放自己的读锁，可以容易推出：每次有线程成功CAS：compareAndSetState(c, nextc)，且nextc不等于0，对应tryReleaseShared返回false，那么在外面此线程并不需要进入doReleaseShared()逻辑，这其实在说明：65534个线程在释放锁的过程中，tryReleaseShared都是返回false，显然都不影响其他读线程，这就是“Releasing the read lock has no effect on readers”的含义。</span></span><br><span class="line"><span class="comment">          当tryReleaseShared返回true时，说明第65535个线程也释放自己的锁，此时nextc==0成立，这时当前线程才会进入doReleaseShared()唤醒阻塞队列里面的线程节点。 因此这一刻，读锁和写锁都没人请求，阻塞队列的线程节点当然可以出队去请求锁。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁的公平性"><a href="#读写锁的公平性" class="headerlink" title="读写锁的公平性"></a>读写锁的公平性</h4><p>我们知道，<code>ReentrantReadWriteLock</code>在创建时默认使用的非公平模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造器使用的是非公平模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);  <span class="comment">// new时就已经实例化一个readerLock 对象和 writerLock 对象</span></span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平模式实现：</p><p>请求写锁时：当前准备请求写锁的线程可以直接CAS写锁，不需要询问CLH阻塞队列是否有线程在等待拿锁。</p><p>请求读锁时：返回apparentlyFirstQueuedIsExclusive的策略，解析参考上文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nonfair version of Sync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">         * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">         * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">         * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">         * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">         * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平模式：</p><p>请求写锁时：当前准备请求写锁的线程要去查询CLH阻塞队列是否有线程正在排队</p><p>请求读锁时：当前准备请求读锁的线程要去查询CLH阻塞队列是否有线程正在排队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Fair version of Sync</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Queries whether any threads have been waiting to acquire longer</span></span><br><span class="line"><span class="comment">   * than the current thread.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment">   * more efficient than):</span></span><br><span class="line"><span class="comment">   *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;</span></span><br><span class="line"><span class="comment">   * hasQueuedThreads()&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">   * timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">   * guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">   * thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">   * race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">   * due to the queue being empty.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This method is designed to be used by a fair synchronizer to</span></span><br><span class="line"><span class="comment">   * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">   * Such a synchronizer&#x27;s &#123;<span class="doctag">@link</span> #tryAcquire&#125; method should return</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> false&#125;, and its &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; method should</span></span><br><span class="line"><span class="comment">   * return a negative value, if this method returns &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">   * (unless this is a reentrant acquire).  For example, the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * tryAcquire&#125; method for a fair, reentrant, exclusive mode</span></span><br><span class="line"><span class="comment">   * synchronizer might look like this:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   // 这里给出当前线程请求独占锁前需要询问阻塞队列的是否有线程正在排队情况</span></span><br><span class="line"><span class="comment">   * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">   *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">   *     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">   *     return true;</span></span><br><span class="line"><span class="comment">   *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">   *     return false;</span></span><br><span class="line"><span class="comment">   *   &#125; else &#123;</span></span><br><span class="line"><span class="comment">   *     // try to acquire normally</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">   *         current thread, and &#123;<span class="doctag">@code</span> false&#125; if the current thread</span></span><br><span class="line"><span class="comment">   *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 如果当前准备请求读写锁的线程调用hasQueuedPredecessors()返回false，说明当前线程要么已经在队列且作为第一个排队节点，要么就是没有CLH阻塞队列，也即没有其他线程在排队，这两种情况都可以说明当前线程不需要排队可以直接去竞争锁。</span></span><br><span class="line"> <span class="comment">//  2. s = h.next且s.thread = Thread.currentThread()，就是说明CLH阻塞队列里面第一个排队线程就是当前线程本身。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">      <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">      <span class="comment">// thread is first in queue.</span></span><br><span class="line">      Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">      Node h = head;</span><br><span class="line">      Node s;</span><br><span class="line">      <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">          ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>基于以上全文，显然<code>ReentrantReadWriteLock</code>的一些特定如下：</p><p>读读不互斥：持有读锁的线程A读数据显然不影响持有读锁的线程B读数据，这样的<code>读读不互斥</code>才是<code>ReentrantReadWriteLock</code>的高性能设计，如果采用<code>ReentrantLock</code>，那么持有<code>lock</code>的线程A读数据显然会导致线程B需要等待线程A释放了<code>ReentrantLock的lock</code>才能读数据，这就是为何<code>ReentrantLock</code>读读互斥不再符合<code>读多写少</code>的高并发需求的场景。</p><p>读写互斥：设想，如果允许读写不互斥，那么持有写锁的线程A正在写数据时，持有读锁的线程B读数据就会读到旧数据，这不是<code>ReentrantReadWriteLock</code>的设计初衷。因此持有写锁的线程A正在写数据时，线程B将无法请求到读锁或者写锁。持有读锁的线程A正在读数据时，线程B将无法请求到写锁来执行相关写操作，这样就保证了线程A在写时，其他线程不会读到乱数据。</p><p>写写互斥：持有写锁的线程A正在写数据时，线程B显然无法请求到写锁。</p><p>对于同一线程持有读锁的情况下，不允许持有写锁：否则就是持当前线程有读锁情况下竟然可以请求到写锁，那么这个读锁就不是共享模式读锁，而是变相称为了独占锁。</p><p>对于同一线程持有写锁的情况下，允许持有读锁：这是允许的，因此例如持有写锁的线程A正在写数据（外面的其他线程无法请求读锁和写锁），写完数据后，可以请求读锁再去读数据，这样不管是线程A自己还是外面的线程都能正确的读取到正确的数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在ReentrantLock的独占模式下，当需要在一个读写高度竞争场景中使用它的&lt;code&gt;lock.lock()&lt;/code&gt;时，你会发现这是独占锁，它会让大量同时请求锁的线程们都不得不进入CLH阻塞队列中等待，如果在“读多写少”的场景中，ReentrantLock的这种独占锁方式显然会降低并发性能，因此ReentrantReadWriteLock就是为了解决这种“读多写少”的场景：一个线程正在请求锁进行读操作可以不影响其他线程同时请求读锁（共享锁），意味着多个线程可以并发读。&lt;/p&gt;
&lt;p&gt;这里首先通过Doug Lea在源码注释给出的demo作为对ReentrantReadWriteLock一般用法说明：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CachedData&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 读线程需要对data读取，写线程可以对data进行更新，那么data显然是线程不安全的，需要借助锁进行相关操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Object data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; cacheValid; &lt;span class=&quot;comment&quot;&gt;// 判断data是否已经被缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 1、创建一个读写锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ReentrantReadWriteLock rwl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantReadWriteLock(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//该方式的功能就是对已经缓存的数据进行预处理 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;processCachedData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2、由于一开始，我们乐观认为data可能已经被缓存，因此我们不急着申请独占锁，而是申请并发的共享读锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rwl.readLock().lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3、结果发现：我们太乐观了，原来data没缓存，因此还不能读取数据（如果非得去读，只能读到旧数据）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cacheValid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Must release read lock before acquiring write lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 4、既然乐观错估了情况，那么只能用上“强大的独占锁”，保证自己能独占的实施“写操作、更新操作、删除操作”：因为读写锁是互斥的，需先释放读锁，然后在升级为写锁。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      rwl.readLock().unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 这就是所谓的“锁升级”。虽然说升级，但这里是当前线程请求独占锁，若同一时刻有其他线程已经拿到写锁，那么在这里当前线程会被阻塞在AQS里面的CLH阻塞队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      rwl.writeLock().lock(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Recheck state because another thread might have&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// acquired write lock and changed state before we did.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 5、由于我们获取写锁的时机也许比其他线程晚一步拿到，因此在这里拿到独占锁后，还得重新检查是否data已经提前被其他线程更新过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cacheValid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          data = ... &lt;span class=&quot;comment&quot;&gt;// 例如从数据库重新读取最新的data，然后将cacheValid标记为true，表示data已经更新（或已经更新缓存）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          cacheValid = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 6、由于我们还得使用更新后的data，因此可以申请读锁。注意，由于当前线程还持有写锁，因此其他线程不可能获得写锁进行写操作，因此当前线程此时可以申请读锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Downgrade by acquiring read lock before releasing write lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rwl.readLock().lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 7、显然data已经被我“独占式”地更新过，可以释放写锁了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rwl.writeLock().unlock(); &lt;span class=&quot;comment&quot;&gt;// Unlock write, still hold read&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 8、在第6点获得共享的读锁后，在这里可以使用已经缓存的新data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      use(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 9、释放读锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      rwl.readLock().unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;关于读锁、写锁、读线程、写线程的一些说明&quot;&gt;&lt;a href=&quot;#关于读锁、写锁、读线程、写线程的一些说明&quot; class=&quot;headerlink&quot; title=&quot;关于读锁、写锁、读线程、写线程的一些说明&quot;&gt;&lt;/a&gt;关于读锁、写锁、读线程、写线程的一些说明&lt;/h4&gt;&lt;p&gt;&lt;code&gt;rwl.readLock().lock()&lt;/code&gt; `:很明显，线程在请求读锁，此锁是AQS的共享模式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rwl.writeLock().lock()&lt;/code&gt;:很明显，线程在请求写锁，此锁是AQS的独占模式&lt;/p&gt;
&lt;p&gt;严格来说：对于ReentrantReadWriteLock这种读写锁的设计，请求读锁的线程直接称为“读线程”可以吗，例如，请求写锁的线程，由于已经获取独占锁的线程可以去请求读锁，那么这个线程是应该称为“写线程”？“读线程”？还是“写、读线程”？还是“读写线程”呢？ 这么看来，请求到读锁的线程似乎也不适合称为读线程？成功请求到写锁的线程也不适合称为写线程。也许换一个角度可以更容易区分：&lt;/p&gt;
&lt;p&gt;在用户代码层面的角度出发：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、用户设计此方法具有明显“读取”数据的逻辑时，该方法首先使用&lt;code&gt;`rwl.readLock().lock()&lt;/code&gt; `，过程中不管是否需要再次请求写锁，都可以把执行用户方法的线程称为“读线程”&lt;/p&gt;
&lt;p&gt;2、用户设计此方法具有明显“更新、删除、改、插入”数据的逻辑时，该方法首先使用&lt;code&gt;`rwl.writeLock().lock()&lt;/code&gt; `，过程中不管是否需要再次请求写锁、还是读锁，都可以把执行用户方法的线程称为“写线程”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是从ReentrantReadWriteLock内部设计来看，可能按以下思路去想会更清晰：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、仅在ReentrantReadWriteLock内部调用tryAcquire方法来看，调用tryAcquire方法的线程可以看成是写线程，因为它是从&lt;code&gt;rwl.writeLock().lock()&lt;/code&gt;来的&lt;/p&gt;
&lt;p&gt;2、仅在ReentrantReadWriteLock内部调用tryAcquireShared方法来看，调用tryAcquireShared方法的线程可以看成是读线程，因为它是从&lt;code&gt;rwl.readLock().lock()&lt;/code&gt;来的&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：基于AQS驱动的CyclicBarrier实现原理解析</title>
    <link href="https://yield-bytes.github.io/2021/08/02/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84CyclicBarrier%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/08/02/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84CyclicBarrier%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2021-08-01T16:00:00.000Z</published>
    <updated>2022-05-10T03:27:54.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CyclicBarrier的基本使用"><a href="#CyclicBarrier的基本使用" class="headerlink" title="CyclicBarrier的基本使用"></a>CyclicBarrier的基本使用</h4><p>这里的Barrier可以翻译为屏障、篱栅、栅栏、“关口”，本文统一称为屏障，因此CyclicBarrier如果非得翻译的话，可以理解为：一个可循环制造屏障的同步器。</p><blockquote><p><em>CyclicBarrier</em>是一个（用于多线程协调的）同步器，它允许一组线程实现互相等待，直到所有线程的执行流都来到一个公共屏障点 （然后再去做一个任务）</p><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point</p></blockquote><p>要理解CyclicBarrier的使用或者其设计意图，可以通过以下简单的demo来了解：</p><a id="more"></a><p>场景： 三位同学A、B、C玩一个闯关游戏，总共有两关（每一关的关口称为屏障），每个同学在本关玩游戏花费时间不一定相同，但要求：当前仅当三位同学都到达关口位置时，由最晚到关口的同学去说：可以进行第二关的任务，然后三位同学继续下一关游戏…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        CyclicBarrier bar;</span><br><span class="line">        <span class="keyword">int</span> duration;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(CyclicBarrier bar,<span class="keyword">int</span> duration)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.bar=bar;</span><br><span class="line">            <span class="keyword">this</span>.duration=duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>*<span class="keyword">this</span>.duration);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;同学到达关口1&quot;</span>);</span><br><span class="line">                bar.await();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>*<span class="keyword">this</span>.duration+<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;同学到达关口2&quot;</span>);</span><br><span class="line">                bar.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CyclicBarrier bar=<span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String broadcast=<span class="string">&quot;最晚到关口的&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;说：A、B、C都齐了，可以开始下一关&quot;</span>;</span><br><span class="line">                System.out.println(broadcast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(bar,<span class="number">1</span>).start(); <span class="comment">// A同学，对应Thread-0</span></span><br><span class="line">        <span class="keyword">new</span> Player(bar,<span class="number">2</span>).start(); <span class="comment">// B同学，对应Thread-1</span></span><br><span class="line">        <span class="keyword">new</span> Player(bar,<span class="number">3</span>).start(); <span class="comment">// C同学，对应Thread-2</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出： </p><p>Thread-0同学到达关口1<br>Thread-1同学到达关口1<br>Thread-2同学到达关口1<br>最晚到关口的Thread-2说：A、B、C都齐了，可以开始下一关<br>Thread-0同学到达关口2<br>Thread-1同学到达关口2<br>Thread-2同学到达关口2<br>最晚到关口的Thread-2说：A、B、C都齐了，可以开始下一关</p><p> 对输出的说明：</p><p>可以看到A、B、C三位依次到达关口1，最晚到关口的C同学来执行“通告工作”，接着三位同学又可以进行下一关游戏（第二关），同样A、B、C三位依次到达关口2，且由最晚到关口的C同学来执行“通告工作”。</p><p>可以结合以下示意图帮助理解<br><img src="https://img-blog.csdnimg.cn/f60f2823a81247779035a624abfc052c.png" alt="在这里插入图片描述"></p><h4 id="CyclicBarrier设计解析"><a href="#CyclicBarrier设计解析" class="headerlink" title="CyclicBarrier设计解析"></a>CyclicBarrier设计解析</h4><h5 id="重要的一些成员变量"><a href="#重要的一些成员变量" class="headerlink" title="重要的一些成员变量"></a>重要的一些成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Each use of the barrier is represented as a generation instance.</span></span><br><span class="line"><span class="comment">   * The generation changes whenever the barrier is tripped, or</span></span><br><span class="line"><span class="comment">   * is reset. There can be many generations associated with threads</span></span><br><span class="line"><span class="comment">   * using the barrier - due to the non-deterministic way the lock</span></span><br><span class="line"><span class="comment">   * may be allocated to waiting threads - but only one of these</span></span><br><span class="line"><span class="comment">   * can be active at a time (the one to which &#123;<span class="doctag">@code</span> count&#125; applies)</span></span><br><span class="line"><span class="comment">   * and all the rest are either broken or tripped.</span></span><br><span class="line"><span class="comment">   * There need not be an active generation if there has been a break</span></span><br><span class="line"><span class="comment">   * but no subsequent reset.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="comment">// 从这里可以看到，内部使用一把独占锁和一个条件队列实现阻塞机制</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="comment">// 这里tripped可以理解为：如果所有线程还未到达屏障，那么那些先来到屏障的线程会被阻塞在trip条件队列中</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">  <span class="comment">/** The number of parties */</span></span><br><span class="line"> <span class="comment">// 到达同一屏障才给放行的线程数量，例如上面demo参与游戏的人数，要求3位同学到达关口才能进入下一关</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">  <span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="comment">// 当所有线程都到达了屏障，由最晚到的线程去执行barrierCommand定义的具体任务，例如demo的C同学：最晚到关口的Thread-2说：A、B、C都齐了，可以开始下一关</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">  <span class="comment">/** The current generation */</span></span><br><span class="line"><span class="comment">// 这里的generation可以理解“当前屏障”、“本关”、“本局”、“本阶段”，就像游戏过关一样，如果在本局就是当前generation，如果通过本局就来到下一局，也即nextGeneration</span></span><br><span class="line">  <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment">   * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment">   * generation or when broken.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">（1）用于统计目前还差多少个线程到达屏障才能进行下一关任务，由barrier.await()对其扣减。</span></span><br><span class="line"><span class="comment">在new CyclicBarrier给定，count的初始值=parties</span></span><br><span class="line"><span class="comment">例如上面的demo：</span></span><br><span class="line"><span class="comment">Thread-0执行barrier.await()，此时count=2，表示当前还差2个线程到达屏障才能进行下一关任务</span></span><br><span class="line"><span class="comment">Thread-1执行barrier.await()，此时count=1，表示当前还差1个线程到达屏障才能进行下一关任务</span></span><br><span class="line"><span class="comment">Thread-2执行barrier.await()，此时count=0，表示3个线程都到齐了屏障，可以开始任务</span></span><br><span class="line"><span class="comment">(2) 当“游戏”从本关进入到下一关(或者从本屏障通过，达到下一个屏障)，count又恢复到parties的数量，这里体现了Cyclic重复、循环的意思。</span></span><br><span class="line"><span class="comment">(3) 当然还有其他情况，参考后面的解析。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  关于“when the barrier is tripped”，本文一律解释为“当屏障”</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment">   * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment">   * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment">   * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment">   注意这里已经很清楚说明：由最后到达barrier的线程来执行给定barrierAction（也即初始化传入一个Runnable的任务，类似demo里面“A、B、C都齐了，可以开始下一关”的打印任务），barrierAction也可以是null，意味着无任何操作。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">   *        before the barrier is tripped</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment">   *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">this</span>.parties = parties;</span><br><span class="line">      <span class="keyword">this</span>.count = parties;</span><br><span class="line">      <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="核心方法await、dowait"><a href="#核心方法await、dowait" class="headerlink" title="核心方法await、dowait"></a>核心方法await、dowait</h5><p>对于await方法，它会响应中断异常和所谓的“打破屏障异常”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在源码该方法注释中,说明调用await的线程阻塞在trip条件队列中，除非发生以下5个情况（这些情况都会让条件队列中全部阻塞的线程们唤醒）：</span></span><br><span class="line"><span class="comment">1、最后一个到达屏障线程，此线程会signalAll条件队列中所有阻塞线程</span></span><br><span class="line"><span class="comment">1、The last thread arrives; or </span></span><br><span class="line"><span class="comment">2、其他线程中断当前执行await的线程</span></span><br><span class="line"><span class="comment">2、Some other thread interrupts the current thread; or </span></span><br><span class="line"><span class="comment">3、其他线程中断一个已经在条件队列阻塞的线程</span></span><br><span class="line"><span class="comment">3、Some other thread interrupts one of the other waiting threads; or</span></span><br><span class="line"><span class="comment">4、在条件队列等待状态的线程出现等待超时的情况</span></span><br><span class="line"><span class="comment">4、Some other thread times out while waiting for barrier; or</span></span><br><span class="line"><span class="comment">5、有些线程主动使用reset方法</span></span><br><span class="line"><span class="comment">5、Some other thread invokes reset on this barrier.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//具体的阻塞机制和唤醒机制是在dowait实现。</span></span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="dowait核心方法的设计"><a href="#dowait核心方法的设计" class="headerlink" title="dowait核心方法的设计"></a>dowait核心方法的设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 注释说这里面有多种处理策略</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">             TimeoutException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock(); <span class="comment">// 先获取独占锁的这种设计对于条件队列来说已经再熟悉不过</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 临时变量g指向当前代（或者本局游戏）</span></span><br><span class="line">          <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"><span class="comment">// 1、此线程执行await前，当前屏障就已经被本局中的其他线程提前打破，则此线程只能抛出BrokenBarrierException。</span></span><br><span class="line">          <span class="keyword">if</span> (g.broken)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">// 2、线程还未进入条件队列就已经被外界中断，那么“所有线程都到达当前屏障的情况一定不会满足了”， 那么采取需要这样的操作：Sets current barrier generation as broken and wakes up everyone，并抛出中断异常。</span></span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">              breakBarrier();              </span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">// 3、线程调用await会在这里对计时器减1，或者说：每有一个线程到达屏障，计时器就减1</span></span><br><span class="line">          <span class="keyword">int</span> index = --count;</span><br><span class="line">          <span class="comment">// 4、这里是关键的逻辑：当计时器为0时，说明所有的线程都到达了屏障，那么最晚到的那个线程可以开始执行一个指定任务：barrierCommand，然后再唤醒所有线程</span></span><br><span class="line">          <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">              <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>; <span class="comment">// 字面意思也可以猜出：是否成功运行了任务</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 5、这里就是demo里面的由最晚到的C同学来完成“通知可以进行下一关”的任务</span></span><br><span class="line">                  <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                  <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                      command.run(); <span class="comment">// 由最晚到屏障的线程来执行给定的任务</span></span><br><span class="line">                  ranAction = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="comment">// 6 &quot;开启下一关&quot;：这最晚的到屏障的线程（C同学）通知那些已经在条件队列阻塞的线程们“开始进行下一局游戏”</span></span><br><span class="line">                  nextGeneration(); </span><br><span class="line">                  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 7、如果最晚到达屏障的线程没能“成功执行给定的任务”，那么也要唤醒条件队列里面的线程，表明本局游戏中止</span></span><br><span class="line">                  <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                      breakBarrier();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 8、来到这里，说明执行await的线程一定不是最晚到达屏障的，那就先进入条件队列里面阻塞等待着，直到triped、当前屏障被打翻、在条件队列阻塞过程中被中断、超时等待，只要其中一个发生，此线程都会被唤醒。</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 9、如果使用普通的await，则调用AQS条件队列里面普通await，如果使用超时的await，那么就调用AQS条件队列里面有超时计时的awaitNanos方法</span></span><br><span class="line">                  <span class="keyword">if</span> (!timed)</span><br><span class="line">                      trip.await();</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                      nanos = trip.awaitNanos(nanos);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 10、执行流来到这里，说明第9点提到线程在条件队列等待中被外界中断唤醒，如果唤醒线程发现还在本局“游戏”进度中且屏障还未被打翻，那么自己就去做breakBarrier这个操作：因为CyclicBarrier的设计要求只要任一在条件队列阻塞的线程被中断唤醒，那么“本局游戏”就认为是“输了”，表示本局需要中止。</span></span><br><span class="line">                  <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                      breakBarrier();</span><br><span class="line">                      <span class="keyword">throw</span> ie;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 11 、来到这里，考察第10点提到的两个条件中，（1）如果g!=generation,说明这个醒来的线程发现自己处于在“下一局游戏环境中”，既然这样自己可以继续执行，不必打破已经处在“下一局”的环境，至多将自己标记为中断过</span></span><br><span class="line">                     <span class="comment">//（2）如果g == generation 且 g.broken=true，说明当前局的屏障被（其他醒来的线程）打翻过，自己只需补一个中断标记即可，不必重新又来一个breakBarrier()。</span></span><br><span class="line">                      <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                      <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                      <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                      Thread.currentThread().interrupt();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">11、由于g.broken要么被当前线程自己来标记，要么就是本局中其他线程比当前线程提早标记g.broken，因此分为以下几种情况。也即对应dowait的上面各种策略</span></span><br><span class="line"><span class="comment">              ① 此线程执行await前，当前屏障就已经被本局中的其他线程提前打破</span></span><br><span class="line"><span class="comment">              ② 如果本局中最晚到达屏障的线程没能“成功执行给定的任务”</span></span><br><span class="line"><span class="comment">              ③ 如果本局中已经在条件队列中阻塞过程中被外界中断或者超时中断唤醒</span></span><br><span class="line"><span class="comment">              ④ 本局中线程或者外界线程调用reset</span></span><br><span class="line"><span class="comment">              或者参考await方法的注释</span></span><br><span class="line"><span class="comment">              Some other thread interrupts the current thread; or</span></span><br><span class="line"><span class="comment">              Some other thread interrupts one of the other waiting threads; or</span></span><br><span class="line"><span class="comment">              Some other thread times out while waiting for barrier; or</span></span><br><span class="line"><span class="comment">              Some other thread invokes reset on this barrier.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">              <span class="keyword">if</span> (g.broken)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"><span class="comment">// 12、说明当前线程是被最晚到达屏障的线程（例如demo的C同学）唤醒来的，那么说明“本局所有线程在玩游戏过程中都是正常执行，没有任何异常发生”，因为最晚到达屏障的线程它会在dowait第6点逻辑中执行nextGeneration，从而使得g指向下一局（指向下一代）</span></span><br><span class="line">              <span class="keyword">if</span> (g != generation)</span><br><span class="line">                  <span class="keyword">return</span> index;</span><br><span class="line"><span class="comment">// 13、对于超时等待引起的中断从而唤醒正在条件队列等待的线程，那只能宣告“本局游戏中止，当前屏障要标记为打翻”然后抛出timeout异常</span></span><br><span class="line">              <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                  breakBarrier();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="nextGeneration方法"><a href="#nextGeneration方法" class="headerlink" title="nextGeneration方法"></a>nextGeneration方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment">   * Called only while holding lock.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 在dowait方法的第6个逻辑：唤醒那些已经到达屏障然后在条件队列中阻塞的线程们（wakes up everyone）：“可以开始开启下一局”</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// signal completion of last generation</span></span><br><span class="line">      trip.signalAll();</span><br><span class="line">      <span class="comment">// set up next generation</span></span><br><span class="line">    <span class="comment">// 计时器重置为指定的线程数量，以便在下一局又可以重新对到达屏障的线程计数</span></span><br><span class="line">      count = parties;</span><br><span class="line">    <span class="comment">// “开始下一局”、“开始下一关”、“开始下一代” 这三种表达的意思都一样</span></span><br><span class="line">      generation = <span class="keyword">new</span> Generation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="breakBarrier方法"><a href="#breakBarrier方法" class="headerlink" title="breakBarrier方法"></a>breakBarrier方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">broken有打翻、破碎的、中止了的意思，在这里可以理解本局中止了、本关中止了、当前代中止了。</span></span><br><span class="line"><span class="comment"> * Sets current barrier generation as broken and wakes up everyone.</span></span><br><span class="line"><span class="comment"> * Called only while holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在dowait方法的第7个逻辑：最晚到达屏障的线程没能“成功执行给定的任务”，这种情况称为“当前屏障被打翻”（不建议直接翻译，还是按current barrier generation as broken去理解显然更为自然）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>; <span class="comment">// 将当前局（当前代、当前关口）设为中止了。</span></span><br><span class="line">    count = parties;<span class="comment">// 重置计数器</span></span><br><span class="line">    trip.signalAll(); <span class="comment">// 即使最晚到达屏障的线程没能“成功执行给定的任务”，它也要将阻塞在trip条件队列里面的所有线程唤醒。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reset方法"><a href="#reset方法" class="headerlink" title="reset方法"></a>reset方法</h5><p>首先reset方法是public的，因此如果有一组线程正在当前的barrier进行某任务中，假设此时外面有一个线程（或者本组的其他线程）主动调用reset，那么就导致“本局游戏中止”，所有正在trip条件队列阻塞的线程都要醒来，然后再重新开始“新一局游戏”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the barrier to its initial state.  If any parties are</span></span><br><span class="line"><span class="comment"> * currently waiting at the barrier, they will return with a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * a breakage has occurred for other reasons can be complicated to</span></span><br><span class="line"><span class="comment"> * carry out; threads need to re-synchronize in some other way,</span></span><br><span class="line"><span class="comment"> * and choose one to perform the reset.  It may be preferable to</span></span><br><span class="line"><span class="comment"> * instead create a new barrier for subsequent use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于“打破本局游戏”的说明"><a href="#关于“打破本局游戏”的说明" class="headerlink" title="关于“打破本局游戏”的说明"></a>关于“打破本局游戏”的说明</h5><p>理解了CyclicBarrier的await方法（dowait）核心设计思想后，可以看到“如果有一组线程想通过CyclicBarrier不中断的完成一局又一局游戏”，条件是严格的：</p><p>（1）先完成自己工作的线程先到达关口（屏障）后，都得乖乖的在屏障这里等待（也即在trip关联的条件队列中阻塞），外界或者本组线程最好不要出现中断它的操作，（如果给定了在屏障的等待时长，线程还不能等太长导致超时，或者组内的还未到达屏障的线程没有去中断已经在条件队列的其他线程）</p><p>（2）所有的线程都到达了屏障</p><p>（3）最晚到达关口（屏障）的线程能不出错地完成指定的任务（barrierCommand）</p><p>以上三点都能顺利的话，那么这一组线程们就可以顺利进入“下一关（下一个屏障）游戏”，也即使得线程们能继续执行下一阶段的工作任务。</p><h5 id="如何设计有多个关口的“游戏任务”？"><a href="#如何设计有多个关口的“游戏任务”？" class="headerlink" title="如何设计有多个关口的“游戏任务”？"></a>如何设计有多个关口的“游戏任务”？</h5><p>这里说的“游戏任务”是指一种类似流水线的工作任务。只需在每个线程定义自己的run方法时，每完成一个“特定工作”就调用barrier.await()，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    CyclicBarrier bar;</span><br><span class="line">    <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(CyclicBarrier bar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bar=bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doSomeWork1()</span><br><span class="line">            bar.await(); <span class="comment">// 此线程在第一局关口等待其他线程</span></span><br><span class="line">            doSomeWork2()</span><br><span class="line">            bar.await();<span class="comment">// 此线程在第二局关口等待其他线程</span></span><br><span class="line">            doSomeWork3()</span><br><span class="line">            bar.await();<span class="comment">// 此线程在第三局关口等待其他线程</span></span><br><span class="line">          .... <span class="comment">// 以此类推</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomeWork1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomeWork2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomeWork3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="CyclicBarrier和CountDownLatch的对比说明"><a href="#CyclicBarrier和CountDownLatch的对比说明" class="headerlink" title="CyclicBarrier和CountDownLatch的对比说明"></a>CyclicBarrier和CountDownLatch的对比说明</h4><p>1、首先回顾CountDownLatch的基本使用：</p><p>以下是“等A、B、C三个同学到齐后才可以开会”的伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.初始化一个CountDownLatch waitSignal&#x3D;new CountDownLatch(3)</span><br><span class="line"></span><br><span class="line">2.主线程先执行condition.await()，此时主线程在“CLH阻塞队列中阻塞”</span><br><span class="line"></span><br><span class="line">3.随后</span><br><span class="line">子线程A启动便调用condition.countDown()，AQS的内部state从3减到2</span><br><span class="line">子线程B启动便调用condition.countDown()，AQS的内部state从2减到1</span><br><span class="line">子线程C最晚启动调用condition.countDown()，AQS的内部state从1减到0，满足唤醒条件，子线程C使用unparkSuccessor唤醒CHL阻塞队列的主线程</span><br><span class="line"></span><br><span class="line">4.最后</span><br><span class="line">主线程打印：A、B、C三个同学已经到齐，现在可以开会</span><br></pre></td></tr></table></figure><p>可以看到CountDownLatch也可以完成CyclicBarrier的这种“等人到齐了再去做某任务”的场景，但你可以清楚看到，CountDownLatch并不能持续进行“下一阶段的开会”，但是使用CyclicBarrier可以实现“A、B、C三个同学到齐了可以进行第一次开会，接着再来一轮A、B、C三个同学到齐了可以开第二次会，依次类推”，这就是两者在使用上的区别。</p><p>2、AQS的底层工作机制不同</p><p>CyclicBarrier显然是基于一把独占锁（支持独占模式和共享模式）、一个条件队列和一个CLH阻塞队列去实现的，唤醒方法是使用条件队列的signalAll</p><p>而CountDownLatch是基于一把独占锁（仅共享模式）、一个CLH阻塞队列实现的，唤醒方法使用传播唤醒方式去唤醒，用到doReleaseShared（unparkSuccessor）去传播唤醒。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;CyclicBarrier的基本使用&quot;&gt;&lt;a href=&quot;#CyclicBarrier的基本使用&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier的基本使用&quot;&gt;&lt;/a&gt;CyclicBarrier的基本使用&lt;/h4&gt;&lt;p&gt;这里的Barrier可以翻译为屏障、篱栅、栅栏、“关口”，本文统一称为屏障，因此CyclicBarrier如果非得翻译的话，可以理解为：一个可循环制造屏障的同步器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;CyclicBarrier&lt;/em&gt;是一个（用于多线程协调的）同步器，它允许一组线程实现互相等待，直到所有线程的执行流都来到一个公共屏障点 （然后再去做一个任务）&lt;/p&gt;
&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要理解CyclicBarrier的使用或者其设计意图，可以通过以下简单的demo来了解：&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：基于AQS驱动的CountDownLatch实现原理解析</title>
    <link href="https://yield-bytes.github.io/2021/07/27/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84CountDownLatch%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/07/27/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84CountDownLatch%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-26T16:00:00.000Z</published>
    <updated>2022-05-10T03:26:17.263Z</updated>
    
    <content type="html"><![CDATA[<p>countdown：倒计时，latch：门闩；插销</p><p>其实CountDownLatch是一种共享锁资源的同步器，用于协调多个线程并行执行（注意不是并发），也即控制多个线程完成后接着在同一时刻去完成某事。当然了，这种协调的底层实现是基于AQS的共享模式实现。</p><p>CountDownLatch一般用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">countdownLatch.countDown()  <span class="comment">// 使得内部的“计数器值”减1,一般由子线程去调用</span></span><br><span class="line">countdownLatch.await() <span class="comment">// 当内部的“计算器值”为0时，说明所有子线程都已经完成任务，那么阻塞的主线程就会被唤醒再去执行其他任务</span></span><br></pre></td></tr></table></figure><h4 id="第一种用法：主线程等所有子线程完成后再统一做某事"><a href="#第一种用法：主线程等所有子线程完成后再统一做某事" class="headerlink" title="第一种用法：主线程等所有子线程完成后再统一做某事"></a>第一种用法：主线程等所有子线程完成后再统一做某事</h4><a id="more"></a><p>这里用开会作为例子，假设有A、B、C三个人参与开会，主持人是AA，开会的规则：要求三个人到场后，主持人才可以开始开会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch =<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> A(countDownLatch).start();</span><br><span class="line">        <span class="keyword">new</span> B(countDownLatch).start();</span><br><span class="line">        <span class="keyword">new</span> C(countDownLatch).start();</span><br><span class="line">        countDownLatch.await(); <span class="comment">// 主持人在等待三位到达会场</span></span><br><span class="line">        System.out.println(<span class="string">&quot;三位都到了会场，现在可以开会了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line">    A (CountDownLatch countDownLatch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;A已到达会场&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line">    B (CountDownLatch countDownLatch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;B已到达会场&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line">    C (CountDownLatch countDownLatch)&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;C已到达会场&quot;</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p>A已到达会场<br>B已到达会场<br>C已到达会场<br>三位都到了会场，现在可以开会了</p><h4 id="countDown的底层AQS解析"><a href="#countDown的底层AQS解析" class="headerlink" title="countDown的底层AQS解析"></a>countDown的底层AQS解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、 用户代码（子线程调用）</span></span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 CountDownLatch同步器的countDown方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、 AQS的releaseShared方法，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 减1成功后，如果state值不为0则不会进入唤醒传播操作。实际场景中一般由最后一个完成任务的子线程到这边一步就会tryReleaseShared==0，进入唤醒逻辑</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 CountDownLatch同步器的tryReleaseShared方法,也即AQS定义的模板方法的子类实现，注意：该“释放方法”是将state值（计数器）减1，而在信号量Semaphore同步器的tryReleaseShared是对可用资源加1操作，注意区别。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">int</span> nextc = c-<span class="number">1</span>; <span class="comment">// 这里就体现用户代码调用countDownLatch.countDown()使得内部计数器state减1的核心设计</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">      <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 如果计时器的值为0，那么调用此逻辑线程的就会接着执行doReleaseShared()唤醒传播操作：实际场景中一般由最后一个执行countDownLatch.countDown()的子线程来唤醒阻塞队列里面的线程节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="await-的底层AQS解析"><a href="#await-的底层AQS解析" class="headerlink" title="await()的底层AQS解析"></a>await()的底层AQS解析</h4><p>注意，调用countDownLatch.await()的线程可能会马上进入阻塞状态，已经掌握AQS的底层设计原理的同学应该可以看出所谓的“阻塞”其实就是进入了CLH阻塞队列后将自己park起来，并等待释放锁的线程来唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、 主线程调用</span></span><br><span class="line">countDownLatch.await(); <span class="comment">// 主持人在等待三位到达会场</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2、CountDownLatch的await方法</span></span><br><span class="line"><span class="comment">Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupted.</span></span><br><span class="line"><span class="comment">这里的官方注释：此方法会使得当前线程处于等待状态直到内部计数器的值为0或者当前线程被外界中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、AQS的获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果调用await前就已经被其他线程中断，那么会直接抛出异常，不再进入阻塞队列排队。</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 注意：这里不是Semaphore对state可用资源进行减1操作，而是判断只要内部计时器不为0，tryAcquireShared就会返回-1，会导致调用await()的线程进入CLH阻塞队列：这里经常会这样使用，其他子线程做完任务后才能调用countDown(),而主线程作为和子线程接近同一时刻启动，因此对于主线程来说它会先读取到的state肯定不为0，使得tryAcquireShared(arg) &lt; 0成立，主线程就会优先执行阻塞队列的流程</span></span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、CountDownLatch内部的tryAcquireShared，注意第3点所提，主线程先运行后await()这里返回getState()返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、AQS内部获取资源失败则进入阻塞队列进行阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 调用await()的主线程作为节点进入阻塞队列的队尾</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">// 由于此刻阻塞队列里面仅有主线程在排队，因此它可以再去尝试获取锁资源</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                  <span class="comment">// 根据上面的第3、第4说明，这里tryAcquireShared返回-1，因此主线程节点进入下面if阻塞自己</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 主线程在这里会阻塞自己（当然是了避免cpu空转），此时阻塞队列里面仅有一个正在等待外面线程唤醒的线程节点。</span></span><br><span class="line">              <span class="comment">// 当然被唤醒后，继续在parkAndCheckInterrupt()内执行，进行自我中断检查：如果线程节点在阻塞队列的等待过程被外界中断过，则醒来后，直接抛出中断异常，然后就会进入finally的取消节点逻辑。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结以上“等三个人到齐后再开会”的例子：</p><p>虽然A、B、C以及主线程都是同时start，但因为A、B、C线程分别要执行一定时间后才能进行countDown减1，因此在主线程执行await()方法时马上有getState()==3，也即<code>tryAcquireShared</code>返回-1，故主线程进入了doAcquireSharedInterruptibly逻辑。</p><h4 id="谁去唤醒已经在阻塞队列里面“主线程节点”"><a href="#谁去唤醒已经在阻塞队列里面“主线程节点”" class="headerlink" title="谁去唤醒已经在阻塞队列里面“主线程节点”"></a>谁去唤醒已经在阻塞队列里面“主线程节点”</h4><p>上一小节已经分析了调用await()的主线程先被AQS“调度”进入了阻塞队列里面，那么谁去负责把这个位于阻塞队列里面的主线程唤醒呢？这里不妨给一个拟人化的演绎推理：</p><blockquote><p>假设A先到，他说我到了主持人可以开始开会，但显然后面还有B、C没到，因此A需要等齐人再去“唤醒主持人”，这样才显得“开会流程”是合理的，接着B到了，他说我到了主持人可以开始开会，但显然后面还有C没到，因此B也不适合去“唤醒主持人”，最后C到了，C看到前面的A、B都到了，这时符合三人都到齐了的条件，因此由最后一个到达会场的C来执行doReleaseShared唤醒逻辑才是合理的，也即让在“等候间睡眠的主持人醒来”开始主持会议。</p></blockquote><p>对应到CountDownLatch—AQS算法层面的流程如下：</p><p>A、B、C以及主线程同一时刻start</p><p>1、主线程先进入AQS的阻塞队列并park上（阻塞自己）。</p><p>2、接着线程A执行1秒结束后使用countDown，计数器从初始给定的3减为2，因为getState ！=0 ，此时不会执行<code>doReleaseShared</code> 唤醒操作</p><p>2、线程B执行2秒结束后使用countDown，计数器从上面的2减为1，因为getState ！=0 ，因此此时不会执行<code>doReleaseShared</code> 唤醒操作</p><p>3、线程C执行3秒结束后使用countDown，计数器从上面的1减为0，因为getState ==0成立 ，此时会进入<code>doReleaseShared</code>唤醒操作操作流程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C线程使用countDown对应内部以下流程：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// C读取的计数器值为1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">int</span> nextc = c-<span class="number">1</span>; <span class="comment">// nextc=1-1=0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 此时CAS后，state变为0</span></span><br><span class="line">      <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// nextc=0显然返回true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 显然上面的tryReleaseShared返回true，C线程可以去执行doReleaseShared唤醒传播操作，对应的逻辑就是让最后一个完成任务的C去唤醒在阻塞队列等待锁资源的主线程。</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; </span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              显然对于阻塞队列结构： head(waitStatus=-1) &lt;-&gt; 主线程(waitStatus=0)，满足</span></span><br><span class="line"><span class="comment">              h.waitStatus == Node.SIGNAL，因此进入unparkSuccessor唤醒主线程。</span></span><br><span class="line"><span class="comment">              */</span> </span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的唤醒流程其实可以得出这样的结论：虽然有多个线程使用的countDown，但最终是由最后一个完成自身任务的线程C（因为它可以使得state减为0）去唤醒“调用await被放入阻塞队列”的主线线程。</p><p>有了以上解析，那么针对CountDownLatch的第二种场景使用则可以很好理解其背后的工作机制。</p><h4 id="第二种用法：要求多个线程在同一时刻“开跑”"><a href="#第二种用法：要求多个线程在同一时刻“开跑”" class="headerlink" title="第二种用法：要求多个线程在同一时刻“开跑”"></a>第二种用法：要求多个线程在同一时刻“开跑”</h4><p>这里我们用了Doug Lea在源码给出的demo代码自行设计一个场景 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doug Lea在源码给出的demo代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">    doSomethingElse();            <span class="comment">// don&#x27;t let run yet</span></span><br><span class="line">    startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">    doSomethingElse();</span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      startSignal.await();</span><br><span class="line">      doWork();</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Demo:</p><p>场景：三个跑者线程在同一起跑线上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch waitSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch launchSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> RunnerA(waitSignal,launchSignal).start();</span><br><span class="line">        <span class="keyword">new</span> RunnerB(waitSignal,launchSignal).start();</span><br><span class="line">        <span class="keyword">new</span> RunnerC(waitSignal,launchSignal).start();</span><br><span class="line">    </span><br><span class="line">        waitSignal.countDown(); </span><br><span class="line">        launchSignal.await();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnerA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch waitSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch launchSignal;</span><br><span class="line">    RunnerA (CountDownLatch startSignal,CountDownLatch doneSignal )&#123;</span><br><span class="line">        <span class="keyword">this</span>.waitSignal =startSignal;</span><br><span class="line">        <span class="keyword">this</span>.launchSignal =doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A在起跑线等待裁判吹哨&quot;</span>);</span><br><span class="line">            waitSignal.await();</span><br><span class="line">            doRun();</span><br><span class="line">            launchSignal.countDown();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;A 到达了终点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnerB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    RunnerB (CountDownLatch startSignal,CountDownLatch doneSignal )&#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal=startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal=doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B在起跑线等待裁判吹哨&quot;</span>);</span><br><span class="line">            startSignal.await();</span><br><span class="line">            doRun();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;B 到达了终点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnerC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    RunnerC (CountDownLatch startSignal,CountDownLatch doneSignal )&#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal=startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal=doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;C在起跑线等待裁判吹哨&quot;</span>);</span><br><span class="line">            startSignal.await();</span><br><span class="line">            doRun();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;C 到达了终点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A在起跑线等待裁判吹哨<span class="comment">// 同一时间启动</span></span><br><span class="line">B在起跑线等待裁判吹哨<span class="comment">// 同一时间启动</span></span><br><span class="line">C在起跑线等待裁判吹哨<span class="comment">// 同一时间启动</span></span><br><span class="line"></span><br><span class="line">A 到达了终点 <span class="comment">// 1秒后</span></span><br><span class="line">B 到达了终点 <span class="comment">// 3秒后</span></span><br><span class="line">C 到达了终点 <span class="comment">// 5秒后</span></span><br></pre></td></tr></table></figure><p>以上线程调度涉及到两个AQS底层的阻塞队列：</p><h5 id="第一个阻塞队列的形成（waitSignal背后对应的阻塞队列）："><a href="#第一个阻塞队列的形成（waitSignal背后对应的阻塞队列）：" class="headerlink" title="第一个阻塞队列的形成（waitSignal背后对应的阻塞队列）："></a>第一个阻塞队列的形成（waitSignal背后对应的阻塞队列）：</h5><p>RunnerA、RunnerB、RunnerC这三个线程都在“run”里面先调用<code>waitSignal.await()</code>，且同一时刻启动，由于比主线程<code>waitSignal.countDown()</code>先执行，因此这三个线程的await的getSate !=0 会进入阻塞队列操作<code>doAcquireSharedInterruptibly</code>,也即在waitSignal对象上形成以下CLH阻塞队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(null,-1) &lt;-&gt; node(RunnerA,-1)  &lt;-&gt; node(RunnerB,-1)  &lt;-&gt; node(RunnerC,0)-&gt;null </span><br></pre></td></tr></table></figure><p>(假设按A、B、C入队顺序做的阻塞队列示意图)</p><p>什么时刻由谁去唤醒他们呢？</p><p>这里就是为何在主线程下使用<code>waitSignal.countDown()</code>的原因：对应以下1、2执行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//CountDownLatch内部</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> c = getState(); <span class="comment">// waitSignal=new CountDownLatch(1)，此时state值为1</span></span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">int</span> nextc = c-<span class="number">1</span>; <span class="comment">// 主线程waitSignal.countDown()先执行，因此这里nextc=1-1=0</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>; <span class="comment">// 显然返回true</span></span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">// AQS     </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 上面返回true后，当然进入唤醒操作</span></span><br><span class="line">     doReleaseShared(); <span class="comment">// 内部的unparkSuccessor(h)会先唤醒RunnerA线程节点</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，在主线程执行<code>waitSignal.countDown()</code>后会在AQS内部先通过<code>doReleaseShared</code>里面的<code>unparkSuccessor</code>唤醒RunnerA，那么之后的RunnerB、RunnerC又是怎么被唤醒呢？这就需要使用AQS共享模式的唤醒传播设计去解释了，以下便是RunnerA唤醒之后的执行流程：</p><p>RunnerA通过<code>setHeadAndPropagate(node, r)</code> 唤醒了RunnerB，同时RunnerA也会出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// ①RunnerA被唤醒后，会来到此位置继续循环</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//② RunnerA通过此方法实现将唤醒传播到RunnerB</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">               <span class="comment">//省略部分</span></span><br></pre></td></tr></table></figure><p>以此类推，RunnerB通过<code>setHeadAndPropagate(node, r)</code> 唤醒了RunnerC，同时RunnerC也会出队</p><p>最终实现了以下唤醒流：</p><p>1、主线程唤醒RunnerA</p><p>2、RunnerA使用setHeadAndPropagate传播唤醒RunnerB</p><p>3、RunnerB使用setHeadAndPropagate传播唤醒RunnerC</p><p>如果没有看本博客之前关于AQS的共享模式设计的解析，则无法理解背后多个线程入队阻塞之后被唤醒的流程，以及所谓的传播唤醒设计原理。</p><h5 id="第二个阻塞队列的形成（launchSignal背后对应的阻塞队列）："><a href="#第二个阻塞队列的形成（launchSignal背后对应的阻塞队列）：" class="headerlink" title="第二个阻塞队列的形成（launchSignal背后对应的阻塞队列）："></a>第二个阻塞队列的形成（launchSignal背后对应的阻塞队列）：</h5><p>虽然三个线程和主线程都是同一时刻执行，但因为每个线程需要“跑步一段时间后”才执行<code>launchSignal.countDown()</code>，故主线程执行<code>launchSignal.await()</code>时，getState=3显然不是0，因此会执行<code>doAcquireSharedInterruptibly</code>进入另外一条CLH阻塞队列，队列结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(null,-1) &lt;-&gt; node(主线程,0)-&gt;null</span><br></pre></td></tr></table></figure><p>当主线程进入阻塞队列且被阻塞后，此时对应的用户线程是这样的：RunnerA运行自己的任务、RunnerB运行自己的任务、RunnerC运行自己的任务，且主程序还未退出，那么在什么时间且最终由谁去唤醒位于<code>launchSignal对象内部的阻塞队列</code>的主线程呢？</p><p>由于RunnerA是第一个结束任务（执行1秒）、RunnerB是第二个结束任务（执行3秒），RunnerC是作为最后一个结束任务（运行5秒），因此容易推出：由RunnerC在众多线程中作为最后一个结束任务的线程去唤醒位于<code>launchSignal对象内部的阻塞队列</code>的主线程。这里就不再具体解释其唤醒过程了，参考第一种用法里面的部分解析即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;countdown：倒计时，latch：门闩；插销&lt;/p&gt;
&lt;p&gt;其实CountDownLatch是一种共享锁资源的同步器，用于协调多个线程并行执行（注意不是并发），也即控制多个线程完成后接着在同一时刻去完成某事。当然了，这种协调的底层实现是基于AQS的共享模式实现。&lt;/p&gt;
&lt;p&gt;CountDownLatch一般用法如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;countdownLatch.countDown()  &lt;span class=&quot;comment&quot;&gt;// 使得内部的“计数器值”减1,一般由子线程去调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;countdownLatch.await() &lt;span class=&quot;comment&quot;&gt;// 当内部的“计算器值”为0时，说明所有子线程都已经完成任务，那么阻塞的主线程就会被唤醒再去执行其他任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;第一种用法：主线程等所有子线程完成后再统一做某事&quot;&gt;&lt;a href=&quot;#第一种用法：主线程等所有子线程完成后再统一做某事&quot; class=&quot;headerlink&quot; title=&quot;第一种用法：主线程等所有子线程完成后再统一做某事&quot;&gt;&lt;/a&gt;第一种用法：主线程等所有子线程完成后再统一做某事&lt;/h4&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：jdk1.8 ConcurrentHashMap的TreeBin读写锁竞争机制讨论</title>
    <link href="https://yield-bytes.github.io/2021/07/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%20ConcurrentHashMap%E7%9A%84TreeBin%E8%AF%BB%E5%86%99%E9%94%81%E7%AB%9E%E4%BA%89%E6%9C%BA%E5%88%B6%E8%AE%A8%E8%AE%BA/"/>
    <id>https://yield-bytes.github.io/2021/07/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%20ConcurrentHashMap%E7%9A%84TreeBin%E8%AF%BB%E5%86%99%E9%94%81%E7%AB%9E%E4%BA%89%E6%9C%BA%E5%88%B6%E8%AE%A8%E8%AE%BA/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2022-05-09T13:50:02.242Z</updated>
    
    <content type="html"><![CDATA[<p>本文接前面ConcurrentHashMap文章的内容，继续深入到TreeBin这个特殊节点的读写锁竞争机制。</p><h4 id="7、TreeBin类设计原理"><a href="#7、TreeBin类设计原理" class="headerlink" title="7、TreeBin类设计原理"></a>7、TreeBin类设计原理</h4><p>对TreeBin类深入分析，不仅能够理解为何CHM能支持并发读的底层实现，而且也能加深jk1.8的ConcurrentHashMap整体设计原理。本文将详细深入地解析TreeBin优秀的读写锁控制设计，此部分内容在全网的相关文章很少涉及。</p><h5 id="7-1-保证加锁对象不改变的设计思想"><a href="#7-1-保证加锁对象不改变的设计思想" class="headerlink" title="7.1 保证加锁对象不改变的设计思想"></a>7.1 保证加锁对象不改变的设计思想</h5><p>首先看其源码的注释说明：</p><blockquote><p>TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.</p></blockquote><p>TreeBins节点不是用于放置key和value，而是用于指向TreeNodes和TreeNodes的根节点。TreeBins内部会维护一把读写锁，用于保证在树重构前，持有锁的写线程被强制等待无锁读线程完成。</p><p>当然这注释也未能回答这样核心问题：为何对于桶位是红黑树的情况下，CHM放置的一个TreeBin节点，而不像HashMap那样放置一个TreeNode节点？</p><p>首先看看TreeBin的使用场景，在put场景下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p;</span><br><span class="line">                binCount = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                               value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldVal = p.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        p.val = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当key所在桶位可以放入key时，先对头节点加锁<code>synchronized (f)</code>，注意这是独占锁，要求头节点对象在锁期间不会改变，否则就不能锁住同一对象。</p><p>为论证f头节点是<code>TreeNode</code>类型不适用并发的CHM场景，不妨假设CHM使用TreeNode作为CHM桶位上红黑树的头节点，于是在put场景下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ① 假设当前头节点f是一个TreeNode节点，则执行流会进入②分支</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                  <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// ② 这里已经将TreeBin换成TreeNode类型</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                      <span class="comment">// ③ 将key和value插入到红黑树当中</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这里关键是第③步逻辑：将key和value插入到红黑树当中，会发生什么事情？</p><p>我们知道，在HashMap节点，将一个节点put入红黑树后，需要做插入平衡处理和将红黑树root节点移到双向链表的头节点位置，目的是为了保证桶位上的头节点即是红黑树的根节点也是双向链表的头结点，下面就是HashMap对应的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 插入平衡处理和将红黑树root节点移到双向链表的头节点位置</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但对于并发CHM来说，红黑树的插入平衡处理会导致root节点发生了改变（例如插入平衡前根节点是treeNodeA，插入平衡后根节点是treeNodeB）而不是位于桶位头节点上，如果CHM桶位头节点还是TreeNode，那么就会出现以下图示的不能保证写线程独占操作的线程不安全情况。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/54c658513c0a61c8d834b71268ad8b52.png" alt="TreeBin改为TreeNode的锁情况.001"></p><p>如何解决以上遇到的问题？</p><a id="more"></a><p>Doug Lea为此设计了TreeBin类（节点），该节点只放在桶位头节点上，它内部“包装”一棵红黑树（有些文章会跟你说TreeBin是 TreeNode的代理结点，其实意思都一样）。加锁时，对桶位头节点上TreeBin节点进行加锁，内部的红黑树根节点root在调整平衡后不管如何变化，当前桶位的加锁对象——TreeBin节点保持不变，也即保证写操作独占性，如下图所示。此外TreeBin还支持高级特性：并发环境下的读写锁控制机制。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6dfa0d55150d2c596cca7bafb704cfc3.png" alt="TreeBin对象加锁不变.0001"></p><p>而且这样设计的TreeBin还有另外一个收益：无需进行类似HashMap的<code>moveRootToFront</code> 操作，因为桶头节点不再要求是</p><p>红黑树的根节点root，也不是链表的first头节点，而是一个包装了TreeNodes的TreeBin节点。</p><p>以下是HashMap的插入节点后需要做<code>moveRootToFront</code> 操作的源码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putVal方法内部代码片段    </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// putTreeVal方法内部代码片段    </span></span><br><span class="line">moveRootToFront(tab, balanceInsertion(root, x));</span><br></pre></td></tr></table></figure><p>以下是CHM插入新节点后的插入平衡操作：在插入平衡操作前，采用cas加锁机制，显然不同于HashMap，这个加锁机制有点复杂，目的是什么呢？在后面7.3小节会提到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      lockRoot();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 仅有插入平衡操作，没有moveRootToFront操作，因为桶位头节点一直都是TreeBin节点，这个节点的hash值为-2，没有key和value</span></span><br><span class="line">          root = balanceInsertion(root, x); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          unlockRoot();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>此外，在源码中的lockRoot等地方的注释中，有个短语：tree restructuring，表示：红黑树重新调整结构。</p><p>而tree restructuring operations则表示：红黑树重新调整结构操作，具体来说是以下两个方法</p><p>put方面内部的putTreeVal方法以及remove方法内部的removeTreeNode方法，也即红黑树插入一个新节点需要触发tree restructuring 操作，红黑树删除一个节点需要触发tree restructuring 操作：执行tree restructuring操作前需要使用lockRoot()获取写锁，调整完后使用unlockRoot()释放写锁。</p><h5 id="7-2-TreeBin类"><a href="#7-2-TreeBin类" class="headerlink" title="7.2 TreeBin类"></a>7.2 TreeBin类</h5><p>TreeBin作为CHM内部类，有部分设计是新设计，用于解决高并发条件下的读写竞争问题，而另外一部分设计则沿用HashMap红黑树部分操作方法：如<code>rotateLeft</code>、<code>rotateRight</code>、<code>balanceInsertion</code>、<code>balanceDeletion</code> 等，这几个方法是在synchronized(f)独占锁条件系进行的，因此跟HashMap原来的执行机制类似，此处不再累赘。本章重点放在新的设计上。</p><h6 id="7-2-1-基本的成员变量"><a href="#7-2-1-基本的成员变量" class="headerlink" title="7.2.1 基本的成员变量"></a>7.2.1 基本的成员变量</h6><p>基本成员变量具体使用在7.3小节的读写竞争设计给出，waiter、lockState以及lockState对应的三个标记值，再结合位运算方式，非常巧妙的实现了TreeBin读写锁竞争！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root; <span class="comment">// 桶位上红黑树根节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first; <span class="comment">// 因为TreeNode节点还有next属性，因此红黑树本身也是一条链表，first就是该链表的头节点，常常用在需要线性遍历节点的场景</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter; <span class="comment">// 参考7.3.1小节内容</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState; <span class="comment">// 直译：锁状态，用于表征TreeBin对象当前的锁状态是什么，对应以下三种状态</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock 写线程给lockState进行cas设1以此获得写锁：0001</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock  写线程将lockState设为2就会转成“等待线程”：0010</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock 桶位每来一个读线程就会对lockState进行cas加4操作：0100</span></span><br></pre></td></tr></table></figure><p>看完后文，你可以发现为何采用1、2、4这样的值，而不是1，2，3或者0，1，2或者2，4，6等，这与读写锁竞争的算法设计有关。</p><h6 id="7-2-2-构造方法"><a href="#7-2-2-构造方法" class="headerlink" title="7.2.2 构造方法"></a>7.2.2 构造方法</h6><p>以下只给出部分片段代码，省略部分的源码片段，其逻辑与HashMap类似，不再给出。</p><p>TreeBin构造方法目的只有一个：基于桶位链表构建一棵红黑树，例如在treeifyBin方法内部的 <code>setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd))</code></p><blockquote><p>TreeBin构造方法在treeifyBin方法被调用，此外还有以下两种情况也会调用TreeBin的构造方法，在优先重点关注”TreeBin构造方法在treeifyBin方法被调用”的场景。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates bin with initial set of nodes headed by b.</span></span><br><span class="line"><span class="comment"> 调用方：treeifyBin方法里面的setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)) ，这里的hd就是桶位链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">//TREEBIN的值为-2，作为TreeBin节点的hash值：hash for roots of trees，这个特殊的hash值一般用在桶位节点类型判断上，fwd节点是-1，因此只要桶位节点的hash值&lt;0，就可以判断当前桶位节点不是链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b; <span class="comment">// 红黑树本身也是一条链表，这里的first表示链表的头节点，也即hd链表头节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// ①外层for循环用于从链表取出节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">// ②内层循环用于将链表遍历节点插入到红黑树合适位置，插入并完成调整则完成了链表上一个节点的转移，回到外层for循环继续转移链表下一个节点</span></span><br><span class="line">      <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">             r = balanceInsertion(r, x);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用逆向思维去找出“TreeBin构造方法”在什么场合被调用？</p><p>什么场景下，CHM的table桶位上才能放置一个TreeBin节点？</p><p>自然是桶位上已经是一棵红黑树？</p><p>那么桶位上的红黑树是怎么来？</p><p>桶位上的冲突链表达到树化阈值后，使用treeifyBin基于链表构建了红黑树。</p><p>找到答案：treeifyBin方法内部一定有TreeBin构造方法调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ①如果table长度还未达到64，优先使用扩容逻辑而不是转红黑树逻辑</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ②说明当前CHM需要树化处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// ③锁住当前桶位链表头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">               <span class="comment">// 再次检查桶位头节点前后时刻有无改动，没改动的情况下，才能进行写操作</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                  <span class="comment">// 红黑树本身也是一条链表</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// ④链表Node节点转为TreeNode节点，并拷贝到新链表hd-&gt;...-&gt;tl</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// ⑤这里就是TeeBin构造方法调用点！！使用cas在index这个桶位上放置一个TreeBin节点，而且可以看到TreeBin节点的入参是hd链表头结点</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br></pre></td></tr></table></figure><p>有人会问，进入②逻辑开始构建红黑树，但从代码上只看到拷贝了一条hd新链表的逻辑，完全没有构建红黑树的逻辑，这是怎么回事？</p><font color=red>这是因为真正构建红黑树的逻辑是在new TreeBin<K,V>(hd)时才被创建，也即CHM桶位上红黑树是由TreeBin构造方法内部代理创建的。</font><p>此外还有以下两种情况也会调用TreeBin的构造方法：</p><p>1、在扩容阶段transfer方法里面，转移桶位链表到新table上是有对应的<code>new TreeBin&lt;K,V&gt;</code> ,也即在新table的i位置上基于低位节点链表构建红黑树，在新table的i+n位置上基于高位节点链表构建红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                    ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line"><span class="comment">// TreeBin构造方法的调用点</span></span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                    hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                    setTabAt(nextTab, i, ln);</span><br><span class="line">                    setTabAt(nextTab, i + n, hn);</span><br><span class="line">                    setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>2、将文件流（本地文件或者socket流）反序列为CHM对象时，readObject也会调用TreeBin的构造方法来构建红黑树实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To improve performance in typical cases, we create nodes</span></span><br><span class="line"><span class="comment">     * while reading, then place in table once size is known.</span></span><br><span class="line"><span class="comment">     * However, we must also validate uniqueness and deal with</span></span><br><span class="line"><span class="comment">     * overpopulated bins while doing so, which requires</span></span><br><span class="line"><span class="comment">     * specialized versions of putVal mechanics.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 1、基于TreeNode的next属性先构建出一条链表hd</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (q = p; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (q.hash, q.key, q.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((t.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                                hd = t;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = t;</span><br><span class="line">                            tl = t;</span><br><span class="line">                        &#125;</span><br><span class="line">          <span class="comment">// 2、在桶位j上，使用TreeBin构造方法构建一棵红黑树，节点来自上面的hd链表</span></span><br><span class="line">                        setTabAt(tab, j, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-3-putval方面-binCount-2的含义？"><a href="#7-2-3-putval方面-binCount-2的含义？" class="headerlink" title="7.2.3 putval方面 binCount = 2的含义？"></a>7.2.3 putval方面 binCount = 2的含义？</h5><p>在put操作里面，我们知道底层是调用了putval方法，有一个逻辑很难理解：</p><p>为何当前桶位节点是TreeBin节点时，binCount=2，而且不需要继续累加计数？ 为何不是跟链表一样从1开始计数？（binCount计算当前桶位的节点数）</p><p>或者这么提问：binCount是用于统计桶位链表节点数量以便判断是否达到树化阈值，但TreeBin里面已经是一棵红黑树了，那么binCount岂不是没有什么实际意义？为何还需要binCount = 2，用意何在？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>; <span class="comment">// 这里binCount不会进行累加计数，为何还需要binCount = 2，有什么用意？</span></span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                   value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从7.2.2的构造方法的内容可知，桶位上的TreeBin节点是用下面这样的代码构建成的，以treeifyBin为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br></pre></td></tr></table></figure><p>这里的hd是桶位链表头节点，算1个，TreeBin本身算1个，共两个，这里binCount=2不是说TreeBin只有两个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; hd) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 这里就可以表示1个节点：TreeBin本身算1个，hash值为-2</span></span><br></pre></td></tr></table></figure><p>binCount=2的实际用意是：能够让addCount的分支2执行判断是否需要扩容，从而TreeBin的红黑树也可以被扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addCount(1L, binCount=2);</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分</span></span><br><span class="line">      <span class="comment">// 能够让addCount的分支2执行判断是否需要扩容，从而TreeBin的红黑树也可以被扩容</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br></pre></td></tr></table></figure><h5 id="7-3-TreeBin读写锁的设计"><a href="#7-3-TreeBin读写锁的设计" class="headerlink" title="7.3 TreeBin读写锁的设计"></a>7.3 TreeBin读写锁的设计</h5><p>深度分析TreeBin读写锁的设计非常有利于理解CHM在红黑树结构上并发读写机制，而且TreeBin读写锁的设计也相当优秀。</p><p>在对TreeBin进行写操作时，由于已经使用了<code>synchronized(f)</code>独占锁语义，表示仅有一个写线程进入写操作，此设计解决了写线程与写线程之间竞争，而读线程和写线程之间的竞争如果采用<code>synchronized</code>方式，在高并发条件下性能无法接受。为了达到高性能的读写锁竞争，肯定需要熟悉的lock-free技术：CAS机制。</p><font color=red>TreeBin读写竞争机制容易给人一种惯性思维：如果有写线程在写，那么读线程就不能读。相信这是所有没有深入研究过TreeBin读写锁源码的人会这样理解，遗憾的是：这种理解从TreeBin底层实现来看是错误的。</font><font color=red>TreeBin读写竞争机制实际是这样的：即使有写线程在写，读线程依然可以并发读！具体实现参考7.3.2小节</font> ：其他说明：>本文提到的写线程是指：>>put入一个节点后（或删除一个节点后），准备执行插入平衡（删除平衡）操作的线程。或者简单说：在TreeBin节点行进行put或者remove操作的线程。同一时刻只能有一个写线程进行写操作。>>本文提到的读线程是指：>>使用get获取（find）TreeBin上指定的key的线程，同一时刻可以有多个读线程并发进行读操作。由于Doug  Lea使用位运算设计TreeBin读写锁获取的条件，使得其源码理解上有些晦涩难懂，具体看后面的章节分析。##### 7.3.1 TreeBin写线程竞争write lock的设计在putTreeVal方法里面，插入节点后需要做插入平衡处理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    lockRoot();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root = balanceInsertion(root, x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRoot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不同于HashMap的设计，这里在插入平衡前加入了lockRoot设计：put写线程竞争到当前TreeBin对象write lock才能实施插入平衡操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires write lock for tree restructuring.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lockRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写线程如果cas加锁成功，那么LOCKSTATE从0变为1（注意这里：只能当LOCKSTATE主存值为0时，写线程才能获得write lock），因此只要LOCKSTATE=1，说明当前TreeBin对象正在被写线程做插入平衡操作，那么此时其他读线程会被阻塞吗，惯性思维会认为读线程会被此刻的写操作阻塞？ 但实际情况不会，具体解释参考7.3.2。</span></span><br><span class="line">  <span class="comment">// 当然，如果写线程cas不成功，就得使用自旋去竞争write lock</span></span><br><span class="line">    <span class="keyword">if</span> (!U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, <span class="number">0</span>, WRITER))</span><br><span class="line">        contendedLock(); <span class="comment">// offload to separate method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里提到的`自旋去竞争获取write lock` 是跟“谁在竞争”呢？当然是和读线程(find操作)竞争。两者CAS互相竞争，源码片段对比如下：>// ①写线程竞争写锁>if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))>          contendedLock(); // offload to separate method>  }> // ②读线程竞争读锁>> else if (U.compareAndSwapInt(this, LOCKSTATE, s,s + READER))  contendedLock有三个分支：分支1：写线程竞争write lock分支2：写线程竞争write lock失败后，在此分支将自己变为“waiter等待线程”分支3：在分支2完成后，写线程已经是waiter线程，将自己挂起不再继续自旋，避免无限for循环的cpu空转<font color=red>另外需要注意一个细节：虽然写线程在`if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))`cas不成功表明lockState那一刻在主存值不为0，但进入if后，来到contendedLock，lockState也有可能变成为0，因为同一时刻有读线程并发读，读完后会对lockState进行cas减4操作，也可能将lockState减至0。简单说来：写线程进入contendedLock时或者进入方法内部时，lockState在主存值可能为0，也可能不是0 </font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Possibly blocks awaiting root lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">contendedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// waiting为true时用于控制这样情况：如果当前写线程未能获得write lock，就不再继续自旋cas竞争，而是将自己转为挂起状态的“等待线程”（waiter），这样做的好处：避免cpu空转浪费cpu时间片</span></span><br><span class="line">    <span class="keyword">boolean</span> waiting = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 当前写线程进入自旋：要么获得write lock，要么变为waiter并将自己挂起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s;;) &#123;</span><br><span class="line"><span class="comment">/* 分支1：竞争write lock，分两种情况讨论</span></span><br><span class="line"><span class="comment">① lockState不为0时，</span></span><br><span class="line"><span class="comment">要使得 (s = lockState) &amp; ~WAITER) == 0，推出lockState=WAITER，也即</span></span><br><span class="line"><span class="comment">WAITER &amp; ~WAITER必然等于0</span></span><br><span class="line"><span class="comment">改为使用位运算方式，也可以推导出来（只需考虑低4位）：</span></span><br><span class="line"><span class="comment">  xxxx</span></span><br><span class="line"><span class="comment">&amp;~0010</span></span><br><span class="line"><span class="comment">也即：</span></span><br><span class="line"><span class="comment"> xxxx</span></span><br><span class="line"><span class="comment">&amp;1101</span></span><br><span class="line"><span class="comment">要使得结果为0，那么xxxx只能是0010这个值，也即lockState为2，也即lockState=WAITER</span></span><br><span class="line"><span class="comment">   而lockState=WAITER，表示当前写线程已经在上一轮遍历转为了“waiter线程”，也说明此时没有读线程正在读TreeBin对象（如果还有读线程，lockState值一定大于2），那么写线程当然可以去竞争写锁：U.compareAndSwapInt(this, LOCKSTATE, 2, WRITER)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   ② lockState在主存值又等于0的情况：这个“又”是指什么情况呢？</span></span><br><span class="line"><span class="comment">   加锁现在有一个读线程和写线程准备读写一个TreeBin，写线程首次对lockState cas不成功说明同一时刻lockState已经被读线程从0改到4（读线程cas加4操作），当写线程进入contendedLock方法后，此时读线程退出对lockState减4，恰好使得lockState在主存值又等于0。</span></span><br><span class="line"><span class="comment">   lockState=0，显然满足(s = lockState) &amp; ~WAITER) == 0，也即</span></span><br><span class="line"><span class="comment">   此刻无读线程竞争，则写线程可以直接去cas加锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">if</span> (((s = lockState) &amp; ~WAITER) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line"><span class="comment">// 如果当前写线程是因为lockState=WAITER加锁成功进来的，那么可以将自己之前被标为waiter线程的标记去除，表示“我现在不是waiter线程，而是已经获取写锁变成writer线程了”</span></span><br><span class="line">                <span class="keyword">if</span> (waiting)</span><br><span class="line">                    waiter = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 写线程成功获得write lock当然可以返回，结束自旋。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* 分支2：写线程竞争write lock失败后，在此分支将自己变为“waiter等待线程”</span></span><br><span class="line"><span class="comment">        到了此分支说明此时lockStat不是0也不是2，是多少呢？</span></span><br><span class="line"><span class="comment">        要使得(s &amp; WAITER) == 0成立，也即</span></span><br><span class="line"><span class="comment">          xx00</span></span><br><span class="line"><span class="comment">        &amp; 0010</span></span><br><span class="line"><span class="comment">       结果为0，可以推出s一定是0或者4、8、12...这样的值，根据读线程能对lockStat使用cas加4操作的设计，可知：</span></span><br><span class="line"><span class="comment">       此时有一个或者多个读线程在读TreeBin对象，那么写线程当然需要等等，这就是为何有waiting、waiter这样的设计</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((s &amp; WAITER) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">/* 既然写线程发现有读线程正在读TreeBin对象，那么就将自己变成等待线程后继续下一次自旋并在分支3把自己挂起来。</span></span><br><span class="line"><span class="comment">   注意这里不是直接将lockState改为WAITER值，而是改为s | WAITER，例如s在主内存值为4，那么cas成功后例如lockState=4+2=6。容易得出如果有N个读线程并发读，那么在这里lockState就设为4*N+2</span></span><br><span class="line"><span class="comment">   */</span>       </span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, s | WAITER)) &#123;</span><br><span class="line">                waiting = <span class="keyword">true</span>;</span><br><span class="line">                waiter = Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 分支3：在分支2完成后，写线程已经是waiter线程，在这里调用UnSafe的park方法将自己挂起不再继续自旋，避免无限for循环的cpu空转</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (waiting)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><font color=red>小结：contendedLock的for循环其实只需关注前3轮遍历：</font><p>对于lockState为0时，这种情况很好理解：写线程直接进入分支1竞争write lock</p><p>对于lockState不为0时，流程如下：</p><p>1、写线程首次进入for循环会直接进入分支2，因为此时lockState已经被1个或多个并发读线程cas加4满足分支2条件，写线程在此分支把自己变成waiter线程。<br>2、第2次循环时，写线程因为在首次循环将waiting设为true，因此会进入分支3，将自己挂起</p><p>3、分支1执行时机是：当其他读线程读完后（find到key）使用unpark唤醒写线程，此时写线程从挂起处执行，回到for循环进入分支1再继续竞争write lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (waiting)</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//写线程从挂起处恢复cpu现场,回到for循环</span></span><br></pre></td></tr></table></figure><p>在理解以上“基于量化的分析”后，再通过以下的“定性说明”，则能掌握contendedLock的设计用意：</p><p>1、写线程发现有读线程正在读TreeBin，那么写线程首次进入for循环后，把自己变为waiter线程（意思是：我在等读线程完成），接着进入第2轮循环。</p><p>2、写线程在第2轮循环将自己挂起，避免自旋消耗cpu时间片</p><p>3、当“最后一个读线程”找到key并在退出前将写线程唤醒。</p><p>4、写线程唤醒后，进入第3轮循环，来到分支1去竞争写锁。</p><h5 id="7-3-2-TreeBin读线程竞争read-lock的设计"><a href="#7-3-2-TreeBin读线程竞争read-lock的设计" class="headerlink" title="7.3.2 TreeBin读线程竞争read lock的设计"></a>7.3.2 TreeBin读线程竞争read lock的设计</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line">  <span class="comment">//如果e节点hash值小于0，说明节点要么是TreeBin节点，要么是fwd节点，两者都有find方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果eh=-2，那么e节点是一个TreeBin节点，也即<code>e.find</code>方法最终调用的是TreeBin内部的find方法（对读线程来说这个find方法可称为读操作）。</p><p>其find方法主要设计思想：</p><p>1、如果TreeBin节点已经有写线程正在做写操作（插入平衡）或者有处于等待状态的写线程，那么当前读线程尝试用遍历链表的方式去读取节点。</p><p>2、如果当前读线程恰能在TreeBin节点cas加锁成功，那么读线程使用红黑树树查找方法快速找到节点，完了后使用unpark将“已经挂起的写线程也即waiter线程”唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns matching node or null if none. Tries to search</span></span><br><span class="line"><span class="comment"> * using tree comparisons from root, but continues linear</span></span><br><span class="line"><span class="comment"> * search when lock not available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line">          <span class="comment">/* 分支1：</span></span><br><span class="line"><span class="comment">          （1）考察lockState=1以及lockState=2时，(s = lockState) &amp; (WAITER|WRITER)计算结果代表的真实含义。</span></span><br><span class="line"><span class="comment">          首先WAITER|WRITER =&gt; 2|1 =&gt; 3 =&gt; 0011</span></span><br><span class="line"><span class="comment">          ① lockState=1</span></span><br><span class="line"><span class="comment">              0001  </span></span><br><span class="line"><span class="comment">          &amp; 0011</span></span><br><span class="line"><span class="comment">          结果不等于0</span></span><br><span class="line"><span class="comment">          ② lockState=2</span></span><br><span class="line"><span class="comment">            0010  </span></span><br><span class="line"><span class="comment">          &amp; 0011</span></span><br><span class="line"><span class="comment">          结果不等于0</span></span><br><span class="line"><span class="comment">          以上两个计算结果是要解释分支1要做的事情：如果当前有写线程正在对TreeBin节点写操作（TreeBin被写线程做插入平衡、删除操作）或者当前写线程已经是一个waiter线程，读线程不会被阻塞，而且读线程用遍历链表的方式去find key</span></span><br><span class="line"><span class="comment">          （2）第二种情况较为复杂：TreeBin同时关联读线程和写线程。当读写线程是以类似下列的CAS序列去并发读、写TreeBin对象时</span></span><br><span class="line"><span class="comment">          读线程      写线程(waiter线程)   读线程 读线程读线程...</span></span><br><span class="line"><span class="comment">          cas(s,s+4) cas(s,s|WAITER)    cas(s,s+4)cas(s,s+4)  cas(s,s+4) ...</span></span><br><span class="line"><span class="comment">          此时lockState=4*N+2，N=1，2，3，4...，</span></span><br><span class="line"><span class="comment">          条件(s = lockState) &amp; (WAITER|WRITER)) != 0也能成立。</span></span><br><span class="line"><span class="comment">          因为此情况下至少有1个读线程和1个写线程（waiter线程），而且从lockState=4*N+2的低两位为10也可以推导出：它和0011相&amp;必然不等于0，位运算如下所示</span></span><br><span class="line"><span class="comment">          x010</span></span><br><span class="line"><span class="comment">          &amp; 0011</span></span><br><span class="line"><span class="comment">         右起第2位的1保证了结果一定不为0，这也是因为lockState值有一个特殊的“+2”，也即有waiter线程。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">// 同时分支1在这里可以证明TreeBin支持即使有写线程在写，也不会阻塞读线程并发读！！</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">/* 分支2：若分支1不成立，说明(s = lockState) &amp; (WAITER|WRITER)) ==0</span></span><br><span class="line"><span class="comment">  由于 (WAITER|WRITER)的值为0011，要使得(s = lockState) &amp; (WAITER|WRITER))结果为0，那么lockState的低两位必须为00， 也即：</span></span><br><span class="line"><span class="comment">                       xx00</span></span><br><span class="line"><span class="comment">                     &amp; 0011</span></span><br><span class="line"><span class="comment">     结果为0说明什么？说明当前时刻lockState的值不是1和2和4*N+2这样的值，而是0，4，8，...4*N这样的值，对应的读写竞争层面含义为：当前有1个或者多个读线程正在读TreeBin节点，那么作为新来的读线程自然可以加进来，并对lockState加4</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 这里可以证明TreeBin支持并发读，每进入一个读线程，就对lockState加4</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 读线程在这里即可放心读取节点（find key）</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Thread w;</span><br><span class="line">                <span class="comment">/*这里可是一个关键的设计：它的思想跟transfer判断最后一个扩容线程的思想是如出一辙：</span></span><br><span class="line"><span class="comment">                  每次有一个读线程读结束后就会对lockState加“-4”，相当于减4，注意这里用的getAndAddInt，而不是前面熟悉的CAS，用处是什么呢？</span></span><br><span class="line"><span class="comment">                  用处：若最后一个读线程读结束后它使用getAndAddInt返回的恰好是6也即等于(READER|WAITER)，同时lockState被减至2（恰好等于WAITER），表明此刻当前TreeBin对象还关联着仅剩一个waiter线程，于是最后一个读线程在return前顺便把waiter线程唤醒，好让这个写线程恢复执行去获取写锁。这一小设计相当巧妙！！</span></span><br><span class="line"><span class="comment">                 本代码片段设计思想可结合7.3.3的图3来理解。</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到了这里，我们可以根据分支1回答以下关键问题：</p><p>为何TreeBin读写竞争机制可以实现：即使有写线程在写，读线程依然可以并发读，不是说好的读写竞争吗（写的时候不能读）</p><font color=red>这是因为：写线程在写操作时，是对红黑树做插入平衡操作，它只是用到了TreeNode的red、parent、right、left属性，别忘了TreeNode的设计中还有next属性，也即红黑树所有节点在背后已经通过next属性链成了一条链表，当红黑树调整时不会改变next属性，因此链表结构保持不变或者说写线程写操作不会影响到TreeNode的链表节点前后指向，那么就可以安排读线程用遍历链表的方式去读链表节点，所以才有了TreeBin以下的设计</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写线程写时 或者写线程是waiter线程时，可使用TreeNode的next属性去遍历链表，实现读线程并发读也不会被写线程阻塞。</span></span><br><span class="line">              <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                       ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">                   e = e.next; <span class="comment">// 使用TreeNode的next属性去遍历背后的链表结构</span></span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-图示理解lockState如何控制读写线程"><a href="#7-3-3-图示理解lockState如何控制读写线程" class="headerlink" title="7.3.3 图示理解lockState如何控制读写线程"></a>7.3.3 图示理解lockState如何控制读写线程</h5><p>7.3.1和7.3.2给出非常详细解释了lockState位运算满足的条件及其设计目的，在此基础上结合以下图可深入掌握TreeBin设计的读写锁竞争机制，它是一个非常优秀的并发设计！</p><p>图1：仅有写线程情况下，逻辑简单不再给出图示。</p><p>假设TreeBin节点仅关联一个写线程，那么s的状态值变化很简单，0变为1，再从1变为0：</p><p>① 写线程进入lockRoot：cas(lockState,0,1)，此时lockState从0变为1，表示写线程获得写锁</p><p>② 写线程完成写操作后调用unlockRoot：lockState = 0，此时lockState 从1变为0，表示写线程释放了写锁</p><p>图2：假设当前有N个读线程且无写线程的情况下并发读TreeBin节点，不妨假设它们都是同一时刻进入find方法，完成读后，也是同一时刻退出find方法，那么lockState值变化如下图所示：</p><p>（此设计很像transfer方法里面扩容线程计数设计：扩容线程进入扩容操作时sc+1、退出扩容操作时sc-1。）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6cb4f3e0435a69f7c9f119e3accc35c3.png" alt="N个读线程并发读TreeBin.001"></p><font color=red> 图3：假设当前有N个读线程和1写线程并发读写TreeBin节点，毫无疑问，此时读线程要竞争读锁、写线程要竞争写锁。不妨假设第1个读线程正在读TreeBin节点，接着来了一个写线程，再接着进来第2个读线程以及后续更多的读线程，那么观察lockState的变化过程：</font><p>(此设计很像transfer方法里面的cas设计：扩容线程进入扩容时sc+1、退出扩容时sc-1，而且这里有个特殊点：lockState=4*N+2中的“+2”，从图中可以知道这个“+2”表示：目前还存在与TreeBin节点关联的唯一一个waiter线程。)</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71fed23c88b3acec285cc576a04e91c5.png" alt="读写线程并存的lockState状态图的副本"></p><h4 id="8、ForwardingNode节点分析"><a href="#8、ForwardingNode节点分析" class="headerlink" title="8、ForwardingNode节点分析"></a>8、ForwardingNode节点分析</h4><p>这个节点的设计相对简单：在扩容阶段，transfer方法中转移节点的那片逻辑里，当旧表桶位节点迁移到新表中后，会在旧表桶位上放置一个ForwardingNode节点，该节点的hash值为MOVED=-1，不存放key以及value。</p><p>还有一个nextTable属性以及内置一个读方法find，它们的设计意图是？解释如下：</p><p>在扩容阶段：对于桶位i，当旧表桶位节点迁移到新表中后，会在旧表桶位i上放置一个ForwardingNode节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">           setTabAt(nextTab, i, ln);</span><br><span class="line">                  setTabAt(nextTab, i + n, hn);</span><br><span class="line"><span class="comment">// 旧表桶位i节点全部迁移到新表后，会在旧表桶位i上放置一个ForwardingNode节点</span></span><br><span class="line">                  setTabAt(tab, i, fwd); </span><br></pre></td></tr></table></figure><p>当有读线程定位桶位i发现是一个fwd节点，就会调用其内部方法find去找key，但是当前桶位只是一个fwd节点，它没有key和value，那么读线程去哪里找key呢？</p><p>这就是nextTable属性的用意：读线程会去新表nextTable相应的桶位去找节点，这一点可以在以下源码的①位置得到证明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Special Nodes -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        <span class="comment">// ① 读线程虽然定位在旧表桶上，从此处for循环条件来看，读线程会在新表nextTable去找节点</span></span><br><span class="line">        <span class="comment">// 这里的outer有特别的用意</span></span><br><span class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//② 在新表的桶位上遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果读线程转去新表（第一个nextTable）去读节点发现该新表对应节点又是一个fwd，说明数据节点被迁移到第二个nextTable，也即读线程转去新表时，新表已经进入扩容期。这时怎么处理呢？ 很简单：告诉读线程请你去第二个nextTable继续去找数据节点。</span></span><br><span class="line">                    <span class="comment">//③</span></span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                    <span class="comment">// 让tab指向第二个nextTable新表，那么下一轮遍历线程就会在第二个nextTable新表去找节点</span></span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                      <span class="comment">// 到打这里说明当前e节点是一个TreeBin节点，TreeBin也有find方法，用它找key即可</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这片源码有个地方的写法比较陌生outer语法：也即 ①位置和③位置，它所要表达的逻辑如下图所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            <span class="comment">//continue outer告诉线程在此处继续执行for(;;)循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 省略部分</span></span><br><span class="line">              <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于解决这样的场景：</p><p>1、首先读线程在旧表读桶位i0时发现是一个fwd节点，读线程会转去新表（第一个nextTable）去读节点</p><p>2、接着读线程发现新表对应桶位i1又是一个fwd节点，说明新表（第一个nextTable）已经进入扩容期。</p><p>3、读线程只能继续转去下一个新表（第二个nextTable）找，发现对应桶位i2是正常的数据节点，那么就可以使用for(;;)读取数据节点。</p><p>可以看出outer设计目的是避免无限递归查找：新表的e.find -&gt;递归&gt;回到新表自己的e.find-&gt;…-&gt; 无限递归</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0c0576900dea2795ee43035c6a347b7.png" alt="Forwarding节点分析.001"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文接前面ConcurrentHashMap文章的内容，继续深入到TreeBin这个特殊节点的读写锁竞争机制。&lt;/p&gt;
&lt;h4 id=&quot;7、TreeBin类设计原理&quot;&gt;&lt;a href=&quot;#7、TreeBin类设计原理&quot; class=&quot;headerlink&quot; title=&quot;7、TreeBin类设计原理&quot;&gt;&lt;/a&gt;7、TreeBin类设计原理&lt;/h4&gt;&lt;p&gt;对TreeBin类深入分析，不仅能够理解为何CHM能支持并发读的底层实现，而且也能加深jk1.8的ConcurrentHashMap整体设计原理。本文将详细深入地解析TreeBin优秀的读写锁控制设计，此部分内容在全网的相关文章很少涉及。&lt;/p&gt;
&lt;h5 id=&quot;7-1-保证加锁对象不改变的设计思想&quot;&gt;&lt;a href=&quot;#7-1-保证加锁对象不改变的设计思想&quot; class=&quot;headerlink&quot; title=&quot;7.1 保证加锁对象不改变的设计思想&quot;&gt;&lt;/a&gt;7.1 保证加锁对象不改变的设计思想&lt;/h5&gt;&lt;p&gt;首先看其源码的注释说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TreeBins节点不是用于放置key和value，而是用于指向TreeNodes和TreeNodes的根节点。TreeBins内部会维护一把读写锁，用于保证在树重构前，持有锁的写线程被强制等待无锁读线程完成。&lt;/p&gt;
&lt;p&gt;当然这注释也未能回答这样核心问题：为何对于桶位是红黑树的情况下，CHM放置的一个TreeBin节点，而不像HashMap那样放置一个TreeNode节点？&lt;/p&gt;
&lt;p&gt;首先看看TreeBin的使用场景，在put场景下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (f) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tabAt(tab, i) == f) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ..&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          	&lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; TreeBin) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Node&amp;lt;K,V&amp;gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                binCount = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                               value)) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    oldVal = p.val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!onlyIfAbsent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        p.val = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当key所在桶位可以放入key时，先对头节点加锁&lt;code&gt;synchronized (f)&lt;/code&gt;，注意这是独占锁，要求头节点对象在锁期间不会改变，否则就不能锁住同一对象。&lt;/p&gt;
&lt;p&gt;为论证f头节点是&lt;code&gt;TreeNode&lt;/code&gt;类型不适用并发的CHM场景，不妨假设CHM使用TreeNode作为CHM桶位上红黑树的头节点，于是在put场景下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ① 假设当前头节点f是一个TreeNode节点，则执行流会进入②分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (f) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (tabAt(tab, i) == f) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;								&lt;span class=&quot;comment&quot;&gt;// ..&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  	&lt;span class=&quot;comment&quot;&gt;// ② 这里已经将TreeBin换成TreeNode类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; TreeNode) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        Node&amp;lt;K,V&amp;gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        binCount = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      	&lt;span class=&quot;comment&quot;&gt;// ③ 将key和value插入到红黑树当中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                       value)) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            oldVal = p.val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!onlyIfAbsent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                p.val = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里关键是第③步逻辑：将key和value插入到红黑树当中，会发生什么事情？&lt;/p&gt;
&lt;p&gt;我们知道，在HashMap节点，将一个节点put入红黑树后，需要做插入平衡处理和将红黑树root节点移到双向链表的头节点位置，目的是为了保证桶位上的头节点即是红黑树的根节点也是双向链表的头结点，下面就是HashMap对应的操作&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; &lt;span class=&quot;title&quot;&gt;putTreeVal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                               &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h, K k, V v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 插入平衡处理和将红黑树root节点移到双向链表的头节点位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            moveRootToFront(tab, balanceInsertion(root, x));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但对于并发CHM来说，红黑树的插入平衡处理会导致root节点发生了改变（例如插入平衡前根节点是treeNodeA，插入平衡后根节点是treeNodeB）而不是位于桶位头节点上，如果CHM桶位头节点还是TreeNode，那么就会出现以下图示的不能保证写线程独占操作的线程不安全情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/54c658513c0a61c8d834b71268ad8b52.png&quot; alt=&quot;TreeBin改为TreeNode的锁情况.001&quot;&gt;&lt;/p&gt;
&lt;p&gt;如何解决以上遇到的问题？&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：基于AQS条件队列实现的各种XXBlockingQueue分析</title>
    <link href="https://yield-bytes.github.io/2021/07/10/%E5%9F%BA%E4%BA%8EAQS%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%84%E7%A7%8DXXBlockingQueue%E5%88%86%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/07/10/%E5%9F%BA%E4%BA%8EAQS%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%84%E7%A7%8DXXBlockingQueue%E5%88%86%E6%9E%90/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2022-05-10T03:23:59.730Z</updated>
    
    <content type="html"><![CDATA[<p>有了《基于AQS实现的Condition底层原理解析》文章关于条件队列底层设计的讨论后，那么关于使用BlockingQueue接口和AQS设计各种阻塞队列实现——ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue的数据结构设计和源代码实现则非常好理解。注意本文的讨论的“阻塞队列”是指代BlockingQueue接口，不是指代AQS源码分析文章中所说的CLH的FIFO阻塞队列。</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>BlockingQueue是一个接口，它有Queue接口常见的方法：add、offer，而put方法和take方法则是BlockingQueue特有的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element into this queue, waiting if necessary</span></span><br><span class="line"><span class="comment">     * for space to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment">     * until an element becomes available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实put和take就是经典的生产者-消费者模型中的逻辑：生产者使用put操作不断向“容器”中放入元素，消费者使用take操作不断从“容器”中取出（消费）元素。只不过对于BlockingQueue接口来说，put和take都要求实现此BlockingQueue接口的子类需实现“阻塞机制”，也即：</p><p>1、对于put操作来说：生产者线程（1个或者多线程并发）向容器（该容器可以是基于数组实现或者基于链表实现）put一个元素（item），如果此容器已满，则所有生产者线程的put操作都会被阻塞直到“容器不满notFull”时。</p><p>结合AQS的条件队列的阻塞机制设计可推出：对于put的阻塞，其实就是让执行put操作的生产者线程在一个“特定的”条件队列中阻塞，这里的阻塞实现就是使用该条件队列的await方法达成。</p><p>2、对于take操作来说：消费者线程（1个或者多线程并发）从容器（该容器可以是基于数组实现或者基于链表实现）中take一个元素（item），如果此容器为空，则所有消费者线程的take操作都会被阻塞直到“容器不空notEmtpy”时。</p><p>结合AQS的条件队列的阻塞机制设计可推出：对于take的阻塞，其实就是让执行take操作的消费者线程在一个“特定的”条件队列中阻塞，这里的阻塞实现就是使用该条件队列的await方法达成。</p><a id="more"></a><h4 id="ArrayBlockingQueue基本使用"><a href="#ArrayBlockingQueue基本使用" class="headerlink" title="ArrayBlockingQueue基本使用"></a>ArrayBlockingQueue基本使用</h4><p>ArrayBlockingQueue的put阻塞demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; q=<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>,<span class="keyword">true</span>); <span class="comment">// 这里的true表示使用ArrayBlockingQueue内部ReentrantLock的公平锁模式，目的是为了使得多个线程有序抢锁资源，以便观察输出情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ii=i;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.put(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产了foo:&quot;</span>+ii);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出以下三句后主线程进入阻塞状态，因为队列长度为3，此时有5个生产线程向q并发生产，因此当第3个线程完成后，q队列已经满了，当后面的第4个、第5个线程向q生产元素时，就会被阻塞：</p><p>Thread-0生产了foo:0<br>Thread-1生产了foo:1<br>Thread-2生产了foo:2</p><p>ArrayBlockingQueue的take操作阻塞demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; q=<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ii=i;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时没有输出：因为q队列没有元素，因此5个消费者线程只能被阻塞。</p><h4 id="ArrayBlockingQueue核心设计"><a href="#ArrayBlockingQueue核心设计" class="headerlink" title="ArrayBlockingQueue核心设计"></a>ArrayBlockingQueue核心设计</h4><p>本文并不定打算对ArrayBlockingQueue做全面的源代码的解析，本文仅挑出其核心的阻塞设计作为解析</p><h5 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialization ID. This class relies on default serialization</span></span><br><span class="line"><span class="comment">     * even for the items array, which is default-serialized, even if</span></span><br><span class="line"><span class="comment">     * it is empty. Otherwise it could not be declared final, which is</span></span><br><span class="line"><span class="comment">     * necessary here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The queued items ArrayBlockingQueue存放元素的容器是基于数组实现的 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Number of elements in the queue </span></span><br><span class="line"><span class="comment">    ArrayBlockingQueue当前含有元素的个数，每次向队列里面放入1个元素，则count++，每次向队列里面取走1个元素，则count--</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment">     * found in any textbook.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* 可以看到，ArrayBlockingQueue的相关put、take也即读写操作都是基于全局一把ReentrantLock，也即是互斥的，而非无锁实现，性能当然会比无锁队列要低。阻塞机制实现：使用一把锁和两个条件队列实现</span></span><br><span class="line"><span class="comment"> notEmpty:消费者线程调用take发现队列元素为空时，被阻塞所在的条件队列</span></span><br><span class="line"><span class="comment"> notFull:生产者线程调用put发现队列元素满时，被阻塞所在的条件队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity]; <span class="comment">// 初始化时可以选择存放元素的个数，以及ReentrantLock的公平模式，默认采用性能相对较高的非公平模式</span></span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition(); </span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment">  * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 在队列尾部添加元素，且不支持添加null对象</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">   <span class="comment">// 1、如果有多个put线程，它们之间需要竞争互斥锁，因此没lock成功的写线程都会进入lock对象关联的CLH阻塞队列里面等着</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2、就算此put线程抢到独占锁资源，但因为条件中“队列的元素个数已经满了”，此时put线程会被notFull.await()放入 notFull对象关联的条件队列，这既是ArrayBlockingQueue的put的阻塞设计实现</span></span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">             notFull.await();</span><br><span class="line">       <span class="comment">// 3、执行流到这里，说明队列还没满，因此可以把元素放入队列，使用enqueue放入元素</span></span><br><span class="line">         enqueue(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment">  * Call only when holding lock.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 注意：将元素入队，是指将元素放在队尾，而取出元素也即出队，是从队列头取出</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     <span class="comment">// 1、将元素放入putIndex下标指向的桶位，putIndex默认值为0，如果下一次要放入的下标已经达到数组长度，那么将putIndex重置为0，以便实现循环使用底层数组放置元素</span></span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 2、入队一个元素，计数器加1</span></span><br><span class="line">     count++;</span><br><span class="line">     <span class="comment">// 3、既然队列已经有刚添加的元素，那么可以通知在notEmpty条件队列等待的“消费者线程们”</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 1、显然take操作也是互斥锁操作，同理如果有多个消费者线程，未能抢到lock的消费者线程则进入lock关联的CLH阻塞队列，结合上面put方法，因此CLH阻塞队列的线程节点可能同时存在消费者线程节点和生产者线程节点</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 2、只要当前队列没有元素，就将当前消费者线程阻塞在notEmpty的条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">      <span class="comment">// 3、说明此时队列里面还有元素可供取出，使用dequeue</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 1、取出当前位置的元素后马上置为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 2、如果下一个要取出的元素下标已经达到数组长度，则重置为0，以便重复利用items这个数组</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 3、既然取出了一个元素，且items[takeIndex] 已经置为null，当然对元素个数的计数器减1</span></span><br><span class="line">    count--;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    4、若使用了ArrayBlockingQueue的迭代器，在每次从队列取出一个元素时还需删除那些关联此队列的、“过时”的迭代器上对应的元素，以实现每个迭代器和底层容器数据数据的一致性：</span></span><br><span class="line"><span class="comment">    例如下面，同一个队列，开启了两个迭代器</span></span><br><span class="line"><span class="comment">    BlockingQueue&lt;String&gt; q=new ArrayBlockingQueue(3,true);</span></span><br><span class="line"><span class="comment">    Iterator iterator1=q.iterator();</span></span><br><span class="line"><span class="comment">    Iterator iterator2=q.iterator();</span></span><br><span class="line"><span class="comment">    由于ArrayBlockingQueue的迭代器设计比普通的ArrayList迭代器设计要复杂，本文在此不再展开。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 4、既然消费者线程已经从队列取出一个元素，说明队列肯定不满，因此可以通知阻塞在notFull条件队列的生产者线程。</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实关于put、take的设计思想，在<code>java.util.concurrent.locks.Condition</code>的源码设计中就有给出相应的demo说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设计一个有界的阻塞队列：一个独占锁关联两个条件队列</span></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>]; <span class="comment">// 内部指定此队列只能放置100个元素</span></span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count; <span class="comment">// 这里的putptr 也即上面的putIndex，takeptr对应takeIndex</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BoundedBuffer buffer=<span class="keyword">new</span> BoundedBuffer();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer.put(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h4 id="LinkedBlockingQueue基本使用"><a href="#LinkedBlockingQueue基本使用" class="headerlink" title="LinkedBlockingQueue基本使用"></a>LinkedBlockingQueue基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; q=<span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line">Iterator iterator1=q.iterator();</span><br><span class="line">Iterator iterator2=q.iterator();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ii=i;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.put(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 观察put的阻塞</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产了foo:&quot;</span>+ii);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue基本使用其实跟ArrayBlockingQueue一样的，只不过内部存放元素的容器是基于链表实现，当然也可以在初始化就指定可存放元素的数量，这样原本的链表阻塞队列即可变为有界阻塞队列。</p><h4 id="LinkedBlockingQueue核心设计"><a href="#LinkedBlockingQueue核心设计" class="headerlink" title="LinkedBlockingQueue核心设计"></a>LinkedBlockingQueue核心设计</h4><p>以下将存放元素的链表统称为容器链表，也即存放元素的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Linked list node class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       E item;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * One of:</span></span><br><span class="line"><span class="comment">        * - the real successor Node</span></span><br><span class="line"><span class="comment">        * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">        * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">     <span class="comment">// 注意由于容器链表的head节点是一个辅助节点，真正的数据头节点是first=head.next</span></span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(E x) &#123; item = x; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;  <span class="comment">// 可以指定默认存放元素个数，最多只能到Integer.MAX_VALUE个</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Current number of elements */</span></span><br><span class="line">  <span class="comment">// 当前容器列表的元素个数，这里为何使用线程安全的原子计数器，而不是像ArrayBlockingQueue那样使用普通的count？ 这里需要理解LinkedBlockingQueue双互斥锁设计才能明白其设计意图！</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Head of linked list.</span></span><br><span class="line"><span class="comment">    * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 容器链表的头结点是head = new Node&lt;E&gt;(null)，因此只需要判断head.item==null，说明此时位于head就是位于头节点位置</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tail of linked list.</span></span><br><span class="line"><span class="comment">    * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 如果last.next=null（注意区别head.next=item），说明last执行的是容器链表的最后一个数据节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="comment">// 这里就是体现了双锁设计：一把take锁，用于消费者线程，意味着消费者线程的take操作并不会阻塞生产者线程的put操作</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="comment">// take锁关联的条件队列，用于存放被阻塞的消费者线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="comment">// 这里就是体现了双锁设计：一把put锁，用于生产者线程，意味着产者线程的put操作并不会阻塞消费者线程的take操作</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="comment">// put锁关联的条件队列，用于存放被阻塞的生产者线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 默认构造器的容器链表长度使用了最大正整数值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">/* 这里可以看到LinkedBlockingQueue存放元素的链表跟普通的链表的头节点不同，</span></span><br><span class="line"><span class="comment">     普通链表的头节点在初始化是head=null，意味着当head指向节点时，此节点就是真正的数据头节点,而LinkedBlockingQueue的头节点是一个辅助节点，在初始化时head指向new Node&lt;E&gt;(null)，显然head不是真正的数据头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>含有数据节点的链表结构示意如下：</p><p>head(null)-&gt;node0(item0)-&gt;node1(item1)-&gt;node2(item2)-&gt;node3(item3)-&gt;null</p><h5 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  源码注释清楚说明：采用了尾插法，也即生产者线程将元素放入容器链表尾部</span></span><br><span class="line"><span class="comment">   * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment">   * necessary for space to become available.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也说明LinkedBlockingQueue不支持放入null对象</span></span><br><span class="line">      <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">      <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">      <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">      Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当然如果有多个生产者线程使用put，那么那些没抢到独占锁的生产者线程将阻塞在putLock关联的CLH阻塞队列里面。</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">      <span class="comment">// 1、因为存在两把锁：putLock和takeLock，意味着生产者线程和消费者可以同一时刻操作计数器count，因此采用AtomicInteger才能计数操作的线程安全</span></span><br><span class="line">      <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">      putLock.lockInterruptibly();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2、通过当前容器链表的元素数量达到指定长度，说明已经满了，则调用put生产者线程将被阻塞在notFull关联的条件队列</span></span><br><span class="line">          <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">              notFull.await();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 3、执行流来到这里，说明此时容器链表可以放入元素，则在链表尾部追加即可</span></span><br><span class="line">          enqueue(node);</span><br><span class="line">        <span class="comment">// 4、添加元素后，对计时器加1并返回上一次计数值</span></span><br><span class="line">          c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 5、如果计时器+1还未超过指定长度，则唤醒可能在notFull条件队列阻塞的的生产者线程：当前容器链表还没满，你们可以醒来向此容器put入元素。</span></span><br><span class="line">          <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">              notFull.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* 6、首先c = count.getAndIncrement()，说明c是在容器链表添加元素之前的计数，如果c等于0，说明容器链表是空的，也说明可能在c=0时可能已经有take消费者线程阻塞在notEmpty的条件队列中，</span></span><br><span class="line"><span class="comment">    而经过上面的3步骤后，既然已经入队了1个元素，那么就需要唤醒在c=0那段时刻被阻塞的消费者线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          signalNotEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Links node at end of queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">      <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">// 可以看到如果是链表结构，入队操作比基于数组实现的效率快很多</span></span><br><span class="line">    <span class="comment">// last.next=node 将当前链表尾指针的next指向新节点node，从而使得node入队</span></span><br><span class="line">      <span class="comment">// last=node 更新尾指针的指向最新的尾节点。</span></span><br><span class="line">      last = last.next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Signals a waiting take. Called only from put/offer (which do not</span></span><br><span class="line"><span class="comment">   * otherwise ordinarily lock takeLock.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 此方法也很简单，唤醒阻塞在takeLock对象下的条件队列的消费者线程节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">      takeLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="take方法-1"><a href="#take方法-1" class="headerlink" title="take方法"></a>take方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从容器链表头部的第一个数据节点取出元素（注意：这里说的是第一个数据节点，而不是head，因为head是一个辅助节点） </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 1、因为存在两把锁：putLock和takeLock，意味着生产者线程和消费者可以同一时刻操作计数器count，因此采用AtomicInteger才能计数操作的线程安全</span></span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"><span class="comment">// 2、消费线程线程使用take锁，说明容器链表的put操作和take操作可以同时进行，而ArrayBlockingQueue是互斥的。当然如果有多个消费者线程使用take，那么那些没抢到独占锁的消费者线程将阻塞在takeLock关联的CLH阻塞队列里面。</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3、 如果当前容器链表元素为0，也即无元素可取，那么消费者线程只能去notEmpty的条件队列阻塞等待</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 4、来到这里说明容器是有元素的，从“队头”取出一个</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">          <span class="comment">// 5、从容器链表取出1个元素后，对计时器减1并返回上一次计数值</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">          <span class="comment">/* 6、如果上一次计数值大于0，说明此刻容器队列还有元素可以去继续取，那么唤醒那些可能在notEmpty条件队列等待的消费线程：你们可以过来take元素。</span></span><br><span class="line"><span class="comment">          注意：这里说的唤醒要求你确实掌握AQS对于signal的内部实现：signal只是将notEmpty条件队列中阻塞的第一个线程节点转移到takeLock关联的CLH阻塞队列，也即那个节点被转移到CLH阻塞队列还处于阻塞状态，直到当前线程执行完finally的unlock，此操作才会在AQS使用unparkSuccessor唤醒那个在takeLock关联的CLH阻塞队列的线程节点。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 7、</span></span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/* 6、首先c = count.getAndIncrement()，说明c是在消费者取出元素之前的计数，如果c已经是指定容器长度，说明容器链表此时已满，也说明在c=capacity那一刻可能已经有put生产者线程阻塞在notFull的条件队列中，</span></span><br><span class="line"><span class="comment">      而经过上面的4的出队操作后，既然已经容器已经扣减了1个元素，那么就需要唤醒c=capacity容器满的那段时刻被阻塞的生产者线程。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes a node from head of queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        <span class="comment">// 取出第一个数据节点：h.next,注意：不是head，因为head=new Node(null)是一个辅助节点</span></span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">      <span class="comment">// 将head指针指向第一个数据节点并取出该节点存放的数据，然后将节点的item置为null，那么此时head指向的first就是一个新的辅助节点：first(item=null,next=下一个数据节点)</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有了《基于AQS实现的Condition底层原理解析》文章关于条件队列底层设计的讨论后，那么关于使用BlockingQueue接口和AQS设计各种阻塞队列实现——ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue的数据结构设计和源代码实现则非常好理解。注意本文的讨论的“阻塞队列”是指代BlockingQueue接口，不是指代AQS源码分析文章中所说的CLH的FIFO阻塞队列。&lt;/p&gt;
&lt;h4 id=&quot;BlockingQueue&quot;&gt;&lt;a href=&quot;#BlockingQueue&quot; class=&quot;headerlink&quot; title=&quot;BlockingQueue&quot;&gt;&lt;/a&gt;BlockingQueue&lt;/h4&gt;&lt;p&gt;BlockingQueue是一个接口，它有Queue接口常见的方法：add、offer，而put方法和take方法则是BlockingQueue特有的&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BlockingQueue&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Inserts the specified element into this queue, waiting if necessary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * for space to become available.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; e the element to add&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; InterruptedException if interrupted while waiting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; ClassCastException if the class of the specified element&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *         prevents it from being added to this queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; NullPointerException if the specified element is null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; IllegalArgumentException if some property of the specified&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *         element prevents it from being added to this queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Retrieves and removes the head of this queue, waiting if necessary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * until an element becomes available.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the head of this queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; InterruptedException if interrupted while waiting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;E &lt;span class=&quot;title&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实put和take就是经典的生产者-消费者模型中的逻辑：生产者使用put操作不断向“容器”中放入元素，消费者使用take操作不断从“容器”中取出（消费）元素。只不过对于BlockingQueue接口来说，put和take都要求实现此BlockingQueue接口的子类需实现“阻塞机制”，也即：&lt;/p&gt;
&lt;p&gt;1、对于put操作来说：生产者线程（1个或者多线程并发）向容器（该容器可以是基于数组实现或者基于链表实现）put一个元素（item），如果此容器已满，则所有生产者线程的put操作都会被阻塞直到“容器不满notFull”时。&lt;/p&gt;
&lt;p&gt;结合AQS的条件队列的阻塞机制设计可推出：对于put的阻塞，其实就是让执行put操作的生产者线程在一个“特定的”条件队列中阻塞，这里的阻塞实现就是使用该条件队列的await方法达成。&lt;/p&gt;
&lt;p&gt;2、对于take操作来说：消费者线程（1个或者多线程并发）从容器（该容器可以是基于数组实现或者基于链表实现）中take一个元素（item），如果此容器为空，则所有消费者线程的take操作都会被阻塞直到“容器不空notEmtpy”时。&lt;/p&gt;
&lt;p&gt;结合AQS的条件队列的阻塞机制设计可推出：对于take的阻塞，其实就是让执行take操作的消费者线程在一个“特定的”条件队列中阻塞，这里的阻塞实现就是使用该条件队列的await方法达成。&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：AQS核心源代码实现Condition的深入解析</title>
    <link href="https://yield-bytes.github.io/2021/06/27/AQS%E6%A0%B8%E5%BF%83%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0Condition%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/06/27/AQS%E6%A0%B8%E5%BF%83%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0Condition%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2022-05-10T03:21:45.757Z</updated>
    
    <content type="html"><![CDATA[<p>关于AQS的独占模式同步器设计原理（以ReentrantLock为例）以及共享模式的同步器设计原理（以Semaphore为例）在前面文章的已经讨论完毕，这两种模式让我们理解了AQS通过底层的FIFO阻塞队列（又称同步队列/变体的CLH队列/Sync queue）实现了相当巧妙的多线程协调调度的复杂逻辑。当然AQS还有一个更为关键的设计：结合FIFO阻塞队列+条件队列（又称condition queue/wait queue）实现一种基于条件的await和signal的多线程间的协调机制，也即本文内容。</p><h4 id="关于条件队列和阻塞队列的说明"><a href="#关于条件队列和阻塞队列的说明" class="headerlink" title="关于条件队列和阻塞队列的说明"></a>关于条件队列和阻塞队列的说明</h4><p>对于阻塞队列，这里只给出独占模式的线程节点说明：阻塞队列其实有AQS内部定义的双向链表节点的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">       <span class="keyword">volatile</span> Node prev;</span><br><span class="line">       <span class="keyword">volatile</span> Node next;</span><br><span class="line">       <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">   &#125;</span><br><span class="line">Node head; <span class="comment">// Head of the wait queue</span></span><br><span class="line">Node tail; <span class="comment">// Tail of the wait queue</span></span><br></pre></td></tr></table></figure><p>而条件队列中，它是有单向链表实现，该单向链表的节点的属性为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node firstWaiter; <span class="comment">// First node of condition queue.</span></span><br><span class="line">Node lastWaiter; <span class="comment">// Last node of condition queue.</span></span><br><span class="line">Node nextWaiter; <span class="comment">// Link to next node waiting on condition,</span></span><br></pre></td></tr></table></figure><p>可以看到三个属性用于构成单向链表，而条件队里的nextWaiter指针是为了区别阻塞队列中的next指针。</p><p>阻塞队列的作用在前面的文章已经给出很明确的说明：只要当前线程没有请求到锁资源（state），则需要进入CLH阻塞队列进行排队等候，那么AQS给出的条件队列到底是解决什么场景呢？</p><p>这里不妨考虑这种场景：</p><p>消费者线程：消费者线程原本在阻塞队列等待，当外界有线程释放了锁资源，那么此消费者线程从阻塞队列被唤醒后出队并拿到锁资源后，发现“存放货物的队列是空的”，这种未加入“条件限制”的等待线程调度策略则显得不够明智。</p><p>因此可以这么设计：给当前独占锁lock对象添加添加一个条件队列：如果有一个或者多消费者线程过来取“货物”，当遇到“仓库没有货物可取”这种条件时，那么这些消费者线程先被安排在条件队列等待（阻塞自己）：</p><p>firstWaiter(c0)-&gt;c1-&gt;c2-c3-&gt;c4-&gt;lastWaiter(c5)-&gt;null</p><p>直到条件“仓库有货物可取时”，那么条件队列的消费者线程再转移到阻塞队列里面排队等候被唤醒去抢占锁资源以实施消费行为</p><a id="more"></a><h4 id="基于Condition实现的生产者和消费者模型"><a href="#基于Condition实现的生产者和消费者模型" class="headerlink" title="基于Condition实现的生产者和消费者模型"></a>基于Condition实现的生产者和消费者模型</h4><p>这里将以一个经典多线程间协调案例作为分析基于AQS实现的Condition底层工作机制</p><p>生产者线程：每次向“仓库”生产1个产品，等待2秒后，并使用signal通知消费者线程</p><p>消费者线程：在启动后如果条件“仓库为空”成立则进入await阻塞状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">// 使用公平模式，以方便debug观察多个消费者线程的入队顺序和出队顺序等。</span></span><br><span class="line">    <span class="keyword">static</span>   Condition condition=lock.newCondition(); <span class="comment">// 可以看到锁对象关联了一个条件对象</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;ElectricCar&gt;  teslaWarehouse=<span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存放车的“仓库”</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 启动5个消费者去“消费”车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Consumer(condition,teslaWarehouse,lock).start();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//让消费者线程先启动，接着再启动1个生产者线程，每隔2秒生产一台车并放入“仓库”</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Producer(condition,teslaWarehouse,lock).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ElectricCar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelY</span> <span class="keyword">implements</span> <span class="title">ElectricCar</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ElectricCar&gt; list;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">    Producer(Condition condition,List&lt;ElectricCar&gt; list,ReentrantLock lock)&#123;</span><br><span class="line">        <span class="keyword">this</span>.condition=condition;</span><br><span class="line">        <span class="keyword">this</span>.list=list;</span><br><span class="line">        <span class="keyword">this</span>.lock=lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 注意：Condition对象使用await或者signal方法前需要获得于条件对象关联的独占锁，否则抛出非法错误。至于为何这么设计，需要等到文章最后的解释。</span></span><br><span class="line">            <span class="keyword">this</span>.list.add(<span class="keyword">new</span> ModelY()); </span><br><span class="line">            System.out.println(<span class="string">&quot;生产了一台modelY&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            condition.signal(); <span class="comment">// 通知消费者线程可以“消费”车了，</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ElectricCar&gt; list;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    Consumer(Condition condition, List&lt;ElectricCar&gt; list, ReentrantLock lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">// 注意：Condition对象使用await或者signal方法前需要获得于条件对象关联的独占锁，否则抛出非法错误。至于为何这么设计，需要等到文章最后的解释。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.isEmpty())</span><br><span class="line">                condition.await(); <span class="comment">// 消费者线程会在此释放锁资源并进入条件队列且阻塞自己，直到收到生产者生产了车信号</span></span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费一台modelY&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：生产者线程循环一次生产一台车，消费者线程有序的“消费”对应的一台车，由于只启动5个消费者线程，因此当生产者线程生产到第6台车时，此时已经没有其他新来的消费者线程来“消费车”，因此不断打印生产者生产车的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">生产了一台modelY</span><br><span class="line">Thread-0消费一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">Thread-1消费一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">Thread-2消费一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">Thread-3消费一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">Thread-4消费一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">生产了一台modelY</span><br><span class="line">生产了一台modelY</span><br></pre></td></tr></table></figure><p>以上的多个消费者线程await和生产者线程signal并发协调机制及其源码解析将在下面给出。</p><h4 id="消费者线程的await底层设计解析"><a href="#消费者线程的await底层设计解析" class="headerlink" title="消费者线程的await底层设计解析"></a>消费者线程的await底层设计解析</h4><p>首先，注释<code>new Producer(condition,teslaWarehouse,lock).start()</code>这一行代码，以考察多个消费者线程<code>lock.lock()-&gt;await()</code>内部逻辑，main启动后会发现主程序阻塞了，你会好奇到底消费者线程在AQS的哪个地方阻塞了？是因为都进入条件队列导致的main阻塞，还是在阻塞队列里面导致main阻塞？根据之前关于<code>ReentrantLock</code>的独占模式原理解析，可知：</p><p>（1）首先，考察5个线程并发执行时都使用<code>lock.lock()</code>争抢独占锁资源，由于lock对象使用公平模式实例化，因此Thread-0首先成功占有锁资源，而其他4个线程将有序进入lock对象的阻塞队列，state锁资源和阻塞队列的结构如下：</p><p>Thread-0作为优先抢占了锁资源的独占线程，可以继续执行自己的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exclusiveOwnerThread&#x3D;Thread-0</span><br></pre></td></tr></table></figure><p>Thread-1到Thread-4因为并发执行<code>lock.lock()</code>因此进入lock对象关联的阻塞队列且线程状态处于waiting阻塞状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(null,-1)&lt;-&gt;node(Thread1,-1)&lt;-&gt;node(Thread2,-1)&lt;-&gt;node(Thread3,-1)&lt;-&gt;node(Thread4,0)-&gt;null</span><br></pre></td></tr></table></figure><p>显然位于阻塞队列的第一个线程节点Thread-1正在等待Thread-0的唤醒。</p><p>注意：此时条件队列还未出现！此时条件队列还未出现！</p><p>（2） Thread-0可以继续执行自己逻辑，也即下面执行流（注意，此时锁资源还是由Thread-0占有！）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list.isEmpty()) <span class="comment">// 由于消费者线程早于生产者线程启动，因此一开始“仓库列表”是空的，因此进入以下await逻辑</span></span><br><span class="line">    condition.await(); <span class="comment">// 这里是理解条件队列的关键入口</span></span><br></pre></td></tr></table></figure><p><code>condition.await()</code>调用的是AQS内部类ConditionObject的await()方法，继续以消费者线程Thread-0作为分析对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 由于Thread-0已经作为独占锁线程，意味着await方法是线程安全的，因此在这里你不会看到自旋和CAS。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// await方法是响应外部中断的：当线程调用condition.await()前，被外部中断过，则这里马上响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// ① 将Thread-0添加到条件队列（单向链表）</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">      <span class="comment">/* ② Thread-0添加到条件队列后，需要释放占有的锁资源。内部其实调用release方法，也即Thread-0会唤醒阻塞队列里面的第一个线程节点Thread-1，此外：</span></span><br><span class="line"><span class="comment">      进入条件队列后，为何还要释放自己占有的锁资源？ 务必理解其设计原因，参考后面的解释。</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">      <span class="comment">// 注意这里：一旦Thread-0释放成功，那么就会唤醒位于阻塞队列的Thread-1</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">      <span class="comment">// ③ 记录Thread-0可能被外部中断的中断标记</span></span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// ④ 显然Thread-0节点不在阻塞队列（这里SyncQueue就是上面Thread-1~Thread-4所在的阻塞队列），</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">           <span class="comment">//⑤ 将Thread-0进行阻塞处理，避免浪费cpu时间片,这里正是解释了为何在main在启动仅有5个消费者线程后，主程序一直被阻塞运行的原因</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 以下的四个if都是为了处理“当线程被signal通知唤醒后响应中断或者取消在条件队列排队的情况，其设计思路会在文章后面给出，这里先分析其阻塞设计。</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是消费者线程首次调用condition.await()的内部工作流程，此时阻塞队列结构和条件队列结构如下：</p><p>Thread-0进入条件队列—&gt;释放自己占有的锁资源（此操作会唤醒阻塞队列的Thread-1）—&gt;在条件队列阻塞自己</p><p>同理被唤醒的Thread-1会继续执行await()方法，跟Thread-0执行流类似，以此类推，最后，5个消费者线程都在条件队列里面阻塞了：</p><p>firstWaiter(Thread-0,-2)-&gt;node(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>支持await的内部几个核心方法</p><ul><li>addConditionWaiter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①将Thread-0添加到条件队列（单向链表）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Node t = lastWaiter; </span><br><span class="line">           <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">         <span class="comment">// 只要条件队列的尾部线程节点是取消状态，那么将其剔除出队列。为何要从尾部判断呢？参考fullyRelease的解析</span></span><br><span class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">               unlinkCancelledWaiters();</span><br><span class="line">               t = lastWaiter; <span class="comment">// 从这里可以看出t的含义：指向非取消状态的尾部节点</span></span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">// 这里即可表明条件队列节点构成：将调用await的线程包装为节点，且状态值node.waitStatus为CONDITION</span></span><br><span class="line">           Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">               firstWaiter = node;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               t.nextWaiter = node; <span class="comment">// 因为上面已经知道t不为null，那么才能将await新来的线程节点放入条件队列</span></span><br><span class="line">           lastWaiter = node;</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>fullyRelease</li></ul><p>当Thread-0线程使用addConditionWaiter进入条件队列后，需要释放自己占有的独占锁资源，但为何要安排释放独占锁资源的逻辑？</p><p>以下可通过反证法考察其设计意图：</p><p>如果Thread-0进入条件队列后且不释放独占锁资源就进入阻塞状态，那么就会生产者线程lock.lock()加锁失败从而进入阻塞队列队尾，而阻塞队列里面第一个线程节点Thread-1显然已经没有外面线程来唤醒，结果就是：整个main程序直接stuck（卡住了），而且此时阻塞队列结构和条件队列结构如下：</p><p>head(null,-1)&lt;-&gt;node(Thread1,-1)&lt;-&gt;node(Thread2,-1)&lt;-&gt;node(Thread3,-1)&lt;-&gt;node(Thread4,-1)&lt;-&gt;node(生产者线程,0)-&gt;null</p><p>条件队列结构：firstWaiter(Thread-0,-2)-&gt;null</p><p>以上的流程可以这样通俗理解：你拿了办公室钥匙（唯一一把钥匙），你直接去休息室“休眠”了，且没有把钥匙“释放”给后面的同事，那么你的同事1、同事2….只能等你，如果你一直“休眠”，那么他们一直无法进入办公室。</p><p>那么考察加入释放的独占锁资源逻辑后，其工作过程将如何？</p><p>（1）Thread-0的fullyRelease会调用AQS的release方法，从而唤醒了阻塞队列里面的Thread-1，此时Thread-1独占锁资源，Thread-1继续执行业务代码await()，同理进入条件队列，并使用fullyRelease独占锁资源同时该操作也会唤醒阻塞队列里面的Thread-2，以此类推，这种进入条件队后释放独占锁资源的流程可以这样通俗理解：</p><p>你拿了办公室钥匙（唯一一把钥匙），你直接去休息室“休眠”前，把钥匙“释放”给后面的同事1，接着，同事1也要去休息室“休眠”，去之前把钥匙“释放”给后面的同事2，以此类推</p><p>（2）显然此时5个消费者线程都在条件队列里面阻塞着（5个同事都在休息室“休眠”），直到生产者线程使用使用signal后，条件队列的Thread-0将被唤醒，之后的逻辑就是signal支持实现。</p><p>这就是fullyRelease的设计意图！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入条件队列的线程释放自己占有的独占锁，可能释放一个或者多个锁资源，如何理解多个锁资源？由于是condition对象是关联ReentrantLock对象，支持同一线程的一次（state=1）或者多次重入占有锁（state&gt;1），因此这里fully是指：不管同一线程占用一个锁资源或者同一线程多次重入占用多个锁资源，都可以在这里一次性释放此线程占有的所有锁资源。</span></span><br><span class="line"> <span class="comment">// 如果释放失败，在finally里面将此节点标记为取消状态，从这里可以看出：条件队列的线程节点取消状态可以在这里产生。</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> savedState = getState();</span><br><span class="line">         <span class="comment">// 如果Thread-0在release能成功释放锁资源，由于release方法（内部调用unparkSuccessor）会唤醒阻塞队列的第一个线程节点，因此Thread-0此时会唤醒阻塞队列里面的Thread-1</span></span><br><span class="line">           <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">               failed = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span> savedState;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 这里做了一个优化设计：每次新节点条件队列后，如果此节点出现异常，则马上将其标记为取消状态，意味着条件队列的队尾要么是正常节点要么就是被标记为取消状态的节点，这种设计将方便addConditionWaiter加入if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) 的逻辑，也即：每次添加新节点到条件队列前，只需判断队列尾部是否存在取消状态的节点，如果有则先使用unlinkCancelledWaiters删除这类节点，然后再new Node入队。</span></span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               node.waitStatus = Node.CANCELLED;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>isOnSyncQueue</li></ul><p>判断刚进入条件队列的线程节点是否已经被转移到阻塞队列中，若不在，则使用 LockSupport.park(this)将当前条件队列的线程节点阻塞，避免浪费cpu时间片。对于Thread-0，显然刚进入条件队列，一定不在阻塞队列，因此将其阻塞在条件队列里等待，isOnSyncQueue就控制了条件队列节点的阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment"> * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//① 节点状态为CONDITION，或者节点的prev为null（因为条件队列的节点只用到firstWaiter、lastWaiter、nextWaiter）说明该节点在条件队列，但一定不在阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//② 阻塞队列使用next指针，因此当前节点的next不为空，必然是在阻塞队列里面</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">     * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">     * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">     * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">     * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">     * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//③ 在①和②都不满足时，官方注释做了这么一个特殊情况说明：在第一个if判断线程节点的prev不为空时表明此刻它还未进入阻塞队列（因为casTail尾部入队失败导致），但可能在下一个时刻就会进入阻塞队列尾部，因此需要重新读取阻塞队列也即在阻塞队列的尾部开始向前遍历，来判断当前node是否在阻塞队列。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的<code>lock.lock()到condition.await()</code>的线程节点工作原理分析，现在可以清晰看到线程们在阻塞队列结构过渡到条件队列结构的过程：</p><p>（1）5个消费者线程并发执行<code>lock.lock()</code>，形成的阻塞队列结构如下：</p><p>Thread-0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exclusiveOwnerThread&#x3D;Thread-0</span><br></pre></td></tr></table></figure><p>Thread-1到Thread-4因为并发执行<code>lock.lock()</code>因此进入lock对象关联的阻塞队列且线程状态处于waiting阻塞状态：</p><p>head(null,-1)&lt;-&gt;node(Thread1,-1)&lt;-&gt;node(Thread2,-1)&lt;-&gt;node(Thread3,-1)&lt;-&gt;node(Thread4,0)-&gt;null</p><p>（2）5个消费者线程的执行流来到<code>condition.await()</code>，形成的条件队列结构如下(单向链表)，且每个消费者线程都处于阻塞状态：</p><p>firstWaiter(Thread-0,-2)-&gt;node(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>在前面demo的mian方法，我们给出注释<code>new Producer(condition,teslaWarehouse,lock).start()</code>,也即没有生产者线程启动，也即没有调用condition.signal方法，那么消费者线程Thread-0只能在条件队列一直被阻塞，当然后面的Thread-1到Thread-4也同样处于阻塞状态。</p><p>下面将加入生产者的signal后的工作过程分析</p><h4 id="生产者线程的signal底层设计解析"><a href="#生产者线程的signal底层设计解析" class="headerlink" title="生产者线程的signal底层设计解析"></a>生产者线程的signal底层设计解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Consumer(condition,teslaWarehouse,lock).start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行流到此，5个消费线程已经在条件队列阻塞中</span></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 启动生产者线程</span></span><br><span class="line">   <span class="keyword">new</span> Producer(condition,teslaWarehouse,lock).start();</span><br></pre></td></tr></table></figure><p>Producer线程的运行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 此时没有其他线程和生产者线程抢锁资源，因此生产者线程成功持有独占锁</span></span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="keyword">new</span> ModelY()); </span><br><span class="line">        System.out.println(<span class="string">&quot;生产了一台modelY&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal(); <span class="comment">//这里是关键：通知条件队列里面的第一个非取消节点：消费者Thread-0</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>signal()设计逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    将当前lock对象关联的条件队列中等待时间最长的线程节点，这里为何不是说头节点呢？因为头节点或者其他节点都有可能变成取消状态，那么真正处理的目标是那些非取消状态的且等待时间最长的线程节点转移到阻塞队列中</span></span><br><span class="line"><span class="comment">     * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">     * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">     * owning lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">     *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 显然生产者线程确实是独占锁资源的线程，这里不会抛出非法状态异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">     * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">     * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 在将首个非取消状态的条件队列节点（也即Thread-0）转移到阻塞队列，且顺便在这一过程中移除条件队列中不是condition状态的节点。</span></span><br><span class="line"><span class="comment">// 需要注意的是：对于未曾研究过AQS工作原理的同学，也许会错以为条件队列的节点被signal后会马上去抢独占锁，实际并非如此。所谓的转移就是要求条件队列的节点被signal后要先移动到阻塞队列中去排队等候被唤醒，这种设计也保证了Condition的设计思路和AQS独占模式设计思路的一致性。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 因为转移的是first节点，因此将firstWaiter后移指向第二个节点也即Thread-1，当然如果第二个节点已经是null说明当前条件队列的所有节点都转移到阻塞队列中。</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// first节点出队，也即Thread-0断开和后面的Thread-1链接。（如果first是取消状态，则正好可以在此过程删除这些取消状态的节点）</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">          转移节点也不是随便转移的：只有first节点是非取消节点才能转移到阻塞队列。或者说</span></span><br><span class="line"><span class="comment">          只要转移操作失败（因为当前first节点是取消状态才会转移失败）且条件队列还存在下一个节点，就继续找一个非取消状态的节点去转移</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">//真正转移的逻辑是在transferForSignal实施的</span></span><br><span class="line">                 (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment"> * Returns true if successful.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment"> * cancelled before signal)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     // 这里正好回答了上面doSignal为何需要重试的原因：因为当前转移的节点已经变为取消状态了，因此在判断!transferForSignal(first)后需要继续找条件队列链表的下一个非取消节点来转移。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 这里就是条件队列节点转移到阻塞队列的秘密：条件队列节点头节点（假设first是非取消节点）维持自己阻塞状态出队，然后使用enq方法将此头节（注意此节点依旧处于阻塞状态）点放入阻塞队列的队尾。</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line"><span class="comment">// 如果前一个节点是取消状态ws&gt;0或者无法将前节点设为SIGNAL值，那么就无法让前节点来唤醒刚入阻塞队列的线程节点。为了处理这种特殊情况，直接唤醒此节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">  <span class="comment">// 执行到这里，说明：条件队列节点头节点（带着阻塞状态）已经成功进入阻塞队列且还处于阻塞状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了对signal的底层设计解析，现在分析这几个线程之间的内部协调</p><p>（1）生产者线程调用signal前，独占锁资源、阻塞队列和条件队列结构如下：</p><p>独占锁资源：生产者持有</p><p>阻塞队列：还未形成</p><p>条件队列如下：</p><p>firstWaiter(Thread-0,-2)-&gt;node(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>（2）生产者线程调用signal后，上面的独占锁资源、阻塞队列和条件队列结构如下：</p><p>独占锁资源：生产者持有</p><p>阻塞队列：head(null,-1)&lt;-&gt;node(Thread-0,0) ，因为signal内部会将条件队列的头节点Thread-0转移（enq）到阻塞队列，此时Thread-0等待生产者线程使用unlock唤醒</p><p>条件队列如下：</p><p>firstWaiter(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>（3）生产者线程调用signal后且执行了lock.unlock()，唤醒了阻塞队列里面的Thread-0消费者线程，唤醒流程,lock.unlock—&gt;release—&gt;tryRelease—&gt;unparkSuccessor。上面的独占锁资源、阻塞队列和条件队列结构如下：</p><p>独占锁资源：：Thread-0持有</p><p>阻塞队列：head(null,0)</p><p>条件队列如下：</p><p>firstWaiter(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>（4）显然此时Thread-0可以从await唤醒的位置继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty())</span><br><span class="line">            condition.await(); <span class="comment">// Thread-0从这里唤醒后，继续执行</span></span><br><span class="line">      </span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">// Thread-0消费了生产者线程刚刚生产的车：也即对应的打印：Thread-0消费一台modelY</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费一台modelY&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Thread-0释放独占锁 </span></span><br><span class="line">        lock.unlock();</span><br></pre></td></tr></table></figure><p>当Thread-0消费了一台车并在finally释放锁资源前、后过程中，生产者线程同时会进行第二次循环，执行流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第二次循环：</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// Thread-0执行lock.unlock()前，生产者线程在第二次循环执行到lock.lock()时，因为此时锁资源还被消费者Thread-0占用，因此生产者只能进入阻塞队列等待。直到Thread-0执行lock.unlock()后，生产者马上抢占锁成功（因为消费者线程Thread-1~Thread-4还是条件队列中等待）</span></span><br><span class="line">        <span class="keyword">this</span>.list.add(<span class="keyword">new</span> ModelY());</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了一台modelY&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal(); <span class="comment">// 通知条件队列里面的消费者Thread-1线程，以后的执行流程就按（2）~（4）不断循环执行，直到条件队列的消费者Thread-4完成lock.unlock()后，之后就没有消费者线程去消费生产者线程新生产的车，对应main程序可以观察到不断打印&quot;生产了一台modelY&quot;</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="await响应中断的逻辑分析"><a href="#await响应中断的逻辑分析" class="headerlink" title="await响应中断的逻辑分析"></a>await响应中断的逻辑分析</h4><p>在上面await设计分析中，重点放在消费者线程入队、释放锁资源、阻塞操作的原理分析。在这一小节，则重点分析await是被设计为可响应外界中断的，await响应中断的逻辑相对复杂，两种特别的中断处理策略：</p><p>（1）中断处理策略1：如果条件队列的线程节点（例如上面提到的Thread-0）在waiting过程中被外界中断过，且还未被生产者signal过，那么此线程调用await就需要抛出InterruptedException</p><p>（2）中断处理策略2：如果条件队列的线程节点（例如上面提到的Thread-0）在waiting过程中没被外界中断，而是在signal后，再被外界中断过，那么此线程调用await只需补一次<code>selfInterrupt()</code></p><p>当然此方法的注释也给出详细的说明（4、6）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">1. If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">2. Save lock state returned by getState.</span></span><br><span class="line"><span class="comment">3. Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">4. Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">5. Reacquire by invoking specialized version of acquire with saved state as argument.</span></span><br><span class="line"><span class="comment">6. If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以到此你应该猜测“await响应中断的设计中”是通过什么方式判断线程节点到底是被signal过还是没被signal呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用interruptMode表征阻塞队列的线程的中断模式，根据情况，取以下两种值</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对应上述的中断模式2，这里的exit是指线程从阻塞队列获取锁资源后采取的处理中断策略（别错把exit看成是条件队列的线程出队）</span></span><br><span class="line"><span class="comment">        Mode meaning to reinterrupt on exit from wait </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        中断模式2：对应上述的中断模式1</span></span><br><span class="line"><span class="comment">        Mode meaning to throw InterruptedException on exit from wait </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        如果当前线程节点在signal前就被外界中断，则标记为为THROW_IE。</span></span><br><span class="line"><span class="comment">        如果当前线程节点在signal之后被外界中断，那么则标记为REINTERRUPT，</span></span><br><span class="line"><span class="comment">        如果当前节点在阻塞队列都没有被外界中断，则标记为0</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 以下就是判断当前线程节点到底是有没有被signal过的核心设计</span></span><br><span class="line"><span class="comment">     * Transfers node, if necessary, to sync queue after a cancelled wait.</span></span><br><span class="line"><span class="comment">     * Returns true if thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* 1、在条件队列的线程节点，其waitStatus一定是CONDITION，因此如果这里能CAS成功就说明：在signal之前，该线程已经被取消（被外界中断），但仍然需要将此节点放入阻塞队列。</span></span><br><span class="line"><span class="comment">      thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2、执行流来到这里，说明此时线程节点waitStatus不是CONDITION肯定被signal过，也即出了条件队列而且在转移到阻塞队列的过程中（可能还未进入阻塞队列），waitStatus在转移逻辑transferForSignal被更改过。换句话说：线程节点被signal过，已经出了条件队列但还未成功进入阻塞队列，因为enq()操作需要此线程和其他线程竞争入阻塞队列队尾，因此出现这种“incomplete transfer”不完整的转移是有可能的，但此情况即罕见又短暂，那么线程自己通过spin直到enq完成入阻塞队列就行，这就是源码注释要表达的含义。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">         * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">         * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">         * spin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">两种情况会调用unlinkCancelledWaiters方法：</span></span><br><span class="line"><span class="comment">1、addConditionWaiter，添加一个新节点到条件队列队尾时，如果队尾节点恰好是取消状态的节点，则使用unlinkCancelledWaiters剔除它</span></span><br><span class="line"><span class="comment">2、在await方法中，当线程节点在条件队列中被中断（此时还未被signal，对应的interruptMode为THROW_IE），那么表示此节点取消在条件队列的排队，需要将其剔除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter; <span class="comment">// 每次循环，t滑向当前要处理的节点，相当于遍历指针</span></span><br><span class="line">            Node trail = <span class="keyword">null</span>; <span class="comment">// trail指向非取消状态的节点</span></span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line">                <span class="comment">// 1、如果t指向的当前节点是取消状态，断开t和子链next的连接（也即将t剔除出队）</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//1.1 如果trail还是null，说明条件队列的第一个节点是取消节点，把next作为条件队列的头节点即可</span></span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">         <span class="comment">// 1.2 如果trial不为空，将trail--&gt;t(cancelled)--&gt;next变成trail--&gt;next</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">         <span class="comment">/*1.3 如果来到条件队列队尾，那么原条件队列的所有取消状态的节点都被剔除，之后的条件队列：</span></span><br><span class="line"><span class="comment">         firstWaiter(CONDITION)--&gt;全部都是CONDITION状态的节点--&gt;lastWaiter(CONDITION)    </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 2、说明t当前处理节点是正常状态，trail滑向（指向）t</span></span><br><span class="line">                    trail = t;</span><br><span class="line">              <span class="comment">// 3、t滑向下一个条件队列节点</span></span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        根据线程节点interruptMode被标记的状态：要么抛出异常、要么补一次自我中断、或者无需做其他操作</span></span><br><span class="line"><span class="comment">         * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">         * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下以Thread-0调用await后进行中断逻辑分析，从唤醒处开始：</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="comment">// 如果Thread-0在进入条件队列等待之前就已经被外界中断过，此线程直接抛出异常，不再参与条件队列等待</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>); </span><br><span class="line">                <span class="comment">/* Thread-0被唤醒后继续之后执行流，被唤醒的原因有以下两种：</span></span><br><span class="line"><span class="comment">                  1、被生产者线程使用signal唤醒的</span></span><br><span class="line"><span class="comment">                  注意：很多人以为是被生产者线程signal方法唤醒，这是理解不透彻的表现：signal方法只是把条件队列的Thread-0转移到阻塞队列中，真正唤醒Thread-0的代码是：生产者线程执行lock.unlock()内部使用unparkSuccessor唤醒阻塞队列里面的Thread-0（前提假设Thread-0是此队列的第一个线程节点）</span></span><br><span class="line"><span class="comment">              2、其他线程中断了Thread-0导致唤醒</span></span><br><span class="line"><span class="comment">              为了找出是哪种中断，需要在checkInterruptWhileWaiting进行判断，以便让Thread-0从阻塞队列出队拿到锁资源后，补充对应的中断类型（或者抛出InterruptedException或者补一个selfInterrupt()）</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* ②醒来后的Thread-0使用Thread.interrupted()进行自我中断状态检查，如果自己在等待（线程休眠）过程中被中断过，则会跳出循环去到下面③的逻辑。</span></span><br><span class="line"><span class="comment">             当然如果Thread-0没被中断过，那么回到while就满足OnSyncQueue，因此也会跳出while循环，意味着interruptMode为0</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* ③ 由于Thread-0还在阻塞队列，运行到这里，就需要使用独占不可中断的acquireQueued方法重新获取锁资源，由于生产者线程执行②所提到的unlock后，此时Thread-0一定能acquireQueued成功获取独占锁（假设没有外界线程和Thread-0抢锁）：</span></span><br><span class="line"><span class="comment">         （1）acquireQueued返回true表示线程节点在阻塞队列中又被中断过1次，因此可以将interruptMode设为REINTERRUPT表示此线程节点被中断两次</span></span><br><span class="line"><span class="comment">         （2）当然对于Thread-0已经占有独占锁来说，acquireQueued返回的interrupted=false，因此会跳过此逻辑</span></span><br><span class="line"><span class="comment">           */</span> </span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="comment">// ④ 如果interruptMode是THROW_IE那么执行流从②跳过③来到这里，说明此线程节点在条件队列中就被中断过（还未被signal），因此需要将此线程节点剔除出条件队列</span></span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">          <span class="comment">// ⑤ Thread-0从条件队列到阻塞队列出队的全过程是否发生的中断，都在这里得到最终的响应：如果是在signal前被外界中断，则THROW_IE，也即抛出异常；否则就是在signal后在阻塞队列等待锁期间被外界中断过，补上一个 selfInterrupt()即可</span></span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>有了以上完整的条件队列设计原理，本文的demo的内部线程之间的协调则很好理解：</p><ul><li>（1）5个消费者线程公平模式lock.lock()之后在await执行前</li></ul><p>条件队列：空</p><p>独占锁资源：Thread-0</p><p>其他4个线程因为Thread-0占有锁资源，只能先进入lock关联的CLH阻塞队列：</p><p>head(null,-1)&lt;-&gt;node(Thread1,-1)&lt;-&gt;node(Thread2,-1)&lt;-&gt;node(Thread3,-1)&lt;-&gt;node(Thread4,0)-&gt;null</p><ul><li>（2）Thread-0执行await操作后，await操作包括的动作：进入条件队列、释放锁资源、阻塞自己</li></ul><p>条件队列：firstWaiter(Thread-0,-2)-&gt;null  (因为Thread-0进入条件队列)</p><p>独占线程：Thread-1 （因为Thread-0 fullyRelease()内部使用unparkSuccessor唤醒了阻塞队列的第一个线程节点Thread-1）</p><p>阻塞队列：head(null,-1)&lt;-&gt;node(Thread2,-1)&lt;-&gt;node(Thread3,-1)&lt;-&gt;node(Thread4,0)-&gt;null</p><ul><li>（3）接着Thread-1唤醒后执行await，重复以上(2)流程，直到Thread-4也执行await后有：</li></ul><p>阻塞队列：head(null,0)</p><p>条件队列：firstWaiter(Thread-0,-2)-&gt;node(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>独占锁资源：null</p><p>可以看到，此时5个消费者线程都阻塞在lock关联下的条件队列，如果main程序没有安排生产者线程去signal此条件队列，那么main程序就会这种情况下挂起。</p><ul><li>（4）接着生产者线程启动，加锁成功，执行到signal，将条件队列的中阻塞状态的Thread-0转移（transferForSignal）到阻塞队列</li></ul><p>独占锁资源：生产者线程持有</p><p>阻塞队列：head(null,-1)&lt;-&gt;node(Thread-0,0)&lt;-&gt;null    （Thread-0等待生产者释放锁资源）</p><p>条件队列：firstWaiter(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><ul><li>（5）生产者完成signal后，执行到lock.unlock()后，也即使用unparkSuccessor唤醒阻塞队列的Thread-0</li></ul><p>（注意：由于生产者此时可以进行第二次循环再次抢占锁但因为Thread-0已经持有锁，因此生产者线程此时会阻塞在阻塞队列）</p><p>独占锁资源：Thread-0持有</p><p>阻塞队列：head(null,-1)&lt;-&gt; 生产者线程</p><p>条件队列：firstWaiter(Thread1,-2)-&gt;node(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>Thread-0继续执行“消费”代码：打印”生产了一台modelY”，后unlock释放锁资源</p><ul><li>（6）生产者进行第二次循环后，因为Thread-0释放锁可以唤醒阻塞队列生产者线程，因此它能加锁成功，之后又来到signal，将条件队列的中阻塞状态的Thread-1转移到阻塞队列</li></ul><p>独占锁资源：生产者线程持</p><p>阻塞队列：head(null,-1)&lt;-&gt;node(Thread-1,0)&lt;-&gt;null    （等待生产者释放锁资源）</p><p>条件队列：firstWaiter(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><ul><li>（7）生产者完成signal后，执行到lock.unlock()，也即使用unparkSuccessor唤醒阻塞队列的Thread-1</li></ul><p>独占锁资源：Thread-1持有</p><p>（注意：由于生产者此时可以进行第二次循环再次抢占锁但因为Thread-1已经持有锁，因此生产者线程此时会阻塞在阻塞队列）</p><p>阻塞队列：head(null,-1)&lt;-&gt; 生产者线程</p><p>条件队列：firstWaiter(Thread2,-2)-&gt;node(Thread3,-2)-&gt;node(Thread4,-2)-&gt;null</p><p>Thread-1继续执行“消费”代码：打印”生产了一台modelY”，后unlock释放锁资源</p><p>之后的循环逻辑类似，这里不再累赘。</p><p>如果你能清晰描述上述多个消费者和生产者线程的内部协调机制，那么才算是真正理解了AQS的底层设计及其源代码实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于AQS的独占模式同步器设计原理（以ReentrantLock为例）以及共享模式的同步器设计原理（以Semaphore为例）在前面文章的已经讨论完毕，这两种模式让我们理解了AQS通过底层的FIFO阻塞队列（又称同步队列/变体的CLH队列/Sync queue）实现了相当巧妙的多线程协调调度的复杂逻辑。当然AQS还有一个更为关键的设计：结合FIFO阻塞队列+条件队列（又称condition queue/wait queue）实现一种基于条件的await和signal的多线程间的协调机制，也即本文内容。&lt;/p&gt;
&lt;h4 id=&quot;关于条件队列和阻塞队列的说明&quot;&gt;&lt;a href=&quot;#关于条件队列和阻塞队列的说明&quot; class=&quot;headerlink&quot; title=&quot;关于条件队列和阻塞队列的说明&quot;&gt;&lt;/a&gt;关于条件队列和阻塞队列的说明&lt;/h4&gt;&lt;p&gt;对于阻塞队列，这里只给出独占模式的线程节点说明：阻塞队列其实有AQS内部定义的双向链表节点的属性如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; waitStatus;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; Node prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; Node next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; Thread thread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Node head; &lt;span class=&quot;comment&quot;&gt;// Head of the wait queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Node tail; &lt;span class=&quot;comment&quot;&gt;// Tail of the wait queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而条件队列中，它是有单向链表实现，该单向链表的节点的属性为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Node firstWaiter; &lt;span class=&quot;comment&quot;&gt;// First node of condition queue.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Node lastWaiter; &lt;span class=&quot;comment&quot;&gt;// Last node of condition queue.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Node nextWaiter; &lt;span class=&quot;comment&quot;&gt;// Link to next node waiting on condition,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到三个属性用于构成单向链表，而条件队里的nextWaiter指针是为了区别阻塞队列中的next指针。&lt;/p&gt;
&lt;p&gt;阻塞队列的作用在前面的文章已经给出很明确的说明：只要当前线程没有请求到锁资源（state），则需要进入CLH阻塞队列进行排队等候，那么AQS给出的条件队列到底是解决什么场景呢？&lt;/p&gt;
&lt;p&gt;这里不妨考虑这种场景：&lt;/p&gt;
&lt;p&gt;消费者线程：消费者线程原本在阻塞队列等待，当外界有线程释放了锁资源，那么此消费者线程从阻塞队列被唤醒后出队并拿到锁资源后，发现“存放货物的队列是空的”，这种未加入“条件限制”的等待线程调度策略则显得不够明智。&lt;/p&gt;
&lt;p&gt;因此可以这么设计：给当前独占锁lock对象添加添加一个条件队列：如果有一个或者多消费者线程过来取“货物”，当遇到“仓库没有货物可取”这种条件时，那么这些消费者线程先被安排在条件队列等待（阻塞自己）：&lt;/p&gt;
&lt;p&gt;firstWaiter(c0)-&amp;gt;c1-&amp;gt;c2-c3-&amp;gt;c4-&amp;gt;lastWaiter(c5)-&amp;gt;null&lt;/p&gt;
&lt;p&gt;直到条件“仓库有货物可取时”，那么条件队列的消费者线程再转移到阻塞队列里面排队等候被唤醒去抢占锁资源以实施消费行为&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/tags/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（二）</title>
    <link href="https://yield-bytes.github.io/2021/06/19/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://yield-bytes.github.io/2021/06/19/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-06-18T16:00:00.000Z</published>
    <updated>2022-05-09T13:49:43.931Z</updated>
    
    <content type="html"><![CDATA[<p>在前面文章中，addCount方法分为两部分：</p><p>第一部分是put一个节点后，需要对size加1计数，这部分交由fullAddCount完成，它的设计和逻辑可谓精妙，非常值得在实际项目参考其代码实现。</p><p>第二部分是加1计数后，需要判断是否需要对table进行扩容，扩容思想设计及其源代码实现同样非常精妙，值得多次阅读和学以致用！</p><p>本文将重点深入分析CHM核心扩容逻辑：transfer、helpTransfer、以及resizeStamp。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8f6d46f059f62cc486c59068a58e948.png" alt="CHM的sc设置基数图示"></p><p>《gitee 博客文章封面》</p><h4 id="1、addCount的扩容判断设计"><a href="#1、addCount的扩容判断设计" class="headerlink" title="1、addCount的扩容判断设计"></a>1、addCount的扩容判断设计</h4><h5 id="第1个执行扩容线程"><a href="#第1个执行扩容线程" class="headerlink" title="第1个执行扩容线程"></a>第1个执行扩容线程</h5><p>本章节最精彩的地方：分析Doug Lea 如何安排“每个加入扩容任务线程对sc进行cas加1计数”、“每个结束自己扩容任务线程对sc进行减1”、以及“最后一个结束扩容线程要干些什么收尾工作”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putVal调用addCount(1L, binCount)，因此这里x就是1，check即binCount，对于put入一个key（key已存在,则binCount=0，新key,binCount&gt;0），那么binCount自然是&gt;=0</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">      CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 主分支1：完成加1计数逻辑，之前文章fullAddCount已经详细分析，本文重点讲解addCount主分支2</span></span><br><span class="line">    <span class="comment">// ......忽略部分</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 主分支2：当前线程检查是否需要扩容，若需要，则执行transfer扩容逻辑</span></span><br><span class="line">     <span class="comment">// check即binCount,每次新增节点，当然要检查是否需要扩容</span></span><br><span class="line">      <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 这里的s就是主分支1里面的 s = sumCount()，含义：完成加1计数后，统计当前CHM节点总数量s，看看s有无达到扩容阈值sizeCtl</span></span><br><span class="line">          <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// jdk 1.8这里的写法是一个bug，后面有指出原因。</span></span><br><span class="line">            <span class="comment">//分支2.1：sc的值为负数时，表明CHM还在扩容期，原因参考后面小节的sc、resizeStamp方法的解析</span></span><br><span class="line">              <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 分支2.1.1：while循环扩容结束点，扩容结束条件有5个，(nt = nextTable) == null 以及transferIndex &lt;= 0条件再看完transfer源码解析后，可以很容易理解，但前面3个条件目前理解会很困难，需要理解后面小节的sc、resizeStamp方法解析后才能准确理解其含义，也即这里先跳过这个5个条件的解释。</span></span><br><span class="line">                  <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                      sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                      transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">// 分支2.1.2：第1个执行扩容线程在分支2.2将sc设置基数值后，以后每进来一个扩容线程都会对sc进行cas加1</span></span><br><span class="line">                  <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                      transfer(tab, nt);</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//分支2.2：第1个执行扩容线程会执行此逻辑，将sc（sizeCtl）设为一个基础数（该数为负数），为什么设置一个负数呢？后面resizeStamp方法给出非常完整解答！没有充分积累，此处看起来将很难理解其设计意图。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                           (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                  transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">              s = sumCount();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>对于分支2.1：因为表示有其他线程在扩容，说明是并发状态，这部分逻辑先放着，我们先考察分支2.2的逻辑。</p><p>分支2.2: 对于ConcurrentHashMap 第1个进入扩容的线程会执行此逻辑，会将sc（sizeCtl）设为一个基础负数：<code>(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</code></p><p>“第1个执行扩容线程”:当ConcurrentHashMap首次扩容时，负责首次扩容任务的线程就是“第1个执行扩容线程”，这个概念很重要！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分支2.2：当ConcurrentHashMap首次扩容时，第1个执行扩容的线程会先执行此分支</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                              (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"> <span class="comment">//第1个负责扩容的线程执行以下扩容逻辑  </span></span><br><span class="line"> &#123;transfer(tab, <span class="keyword">null</span>);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正是因为有了“第1个执行扩容线程”将sc（sizeCtl）设为一个基础负数，此时回看分支2.1即可明白其含义：</p><p>此时sc是个基础负数，因此sc&lt;0必然成立，换句话说：只要有第2个以及后续更多的线程进入whlie，sc&lt;0成立，表明当前CHM正在扩容状态（或者有线程正在对CHM进行扩容处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//分支2.1    </span></span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>有了以上解析的铺垫，现在我们重新理顺以下执行流程：假设当前CHM已经达到扩容阈值时，“第1个执行扩容线程”以及“第2个以及以后更多线程加入到扩容”在进入addCount后的执行流，从序号①开始，按升序推进，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">//新put一个节点后，addCount(x=1, check=binCount=1)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">      CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line"><span class="comment">// 主分支1：完成fullAddCount加1计算后，计算</span></span><br><span class="line">     s = sumCount();</span><br><span class="line">      <span class="comment">// 主分支2：当前线程检查是否需要扩容，若需要，就执行transfer扩容逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//① 我们已假设需要扩容，也即整个CHM的节点数量s已经达到扩容阈值sc=sizeCtl,“第1个执行扩容线程”go to ②</span></span><br><span class="line">        <span class="comment">//④ 由于我们已经假设：第2个以及以后更多线程加入到扩容,这些线程能进入while，go to ⑤</span></span><br><span class="line">          <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">//② “第1个执行扩容线程”进来后，此时sc还是正值(扩容阈值sc=sizeCtl)，go to ③</span></span><br><span class="line">            <span class="comment">//⑤ 在上一轮“第1个执行扩容线程”执行③后，sc就是一个基数负值，因此“第2个以及以后更多线程加入扩容”的线程们会go to ⑥</span></span><br><span class="line">              <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里的条件先放着，等看完后面的transfer方法解析，这些条件自然能迎刃而解</span></span><br><span class="line">                  <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                      sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                      transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//⑥ “第2个以及以后更多线程加入到扩容”的线程们：在首轮中第1个线程将sc设置基数值后，以后每进来一个扩容线程，该线程对sc进行cas加1，为什么这么安排，请看下一节内容：sc设置为一个基础负数的实际意义</span></span><br><span class="line">                  <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//  “第2个以及以后更多线程执行扩容”真正进入扩容处理的逻辑</span></span><br><span class="line">                      transfer(tab, nt);</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">//③ “第1个执行扩容线程”用cas将sc设为一个基数负值</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                           (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// “第1个执行扩容线程”真正进入扩容处理的逻辑</span></span><br><span class="line">                  transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">              s = sumCount();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="sc设置为一个基础负数的实际意义"><a href="#sc设置为一个基础负数的实际意义" class="headerlink" title="sc设置为一个基础负数的实际意义"></a>sc设置为一个基础负数的实际意义</h5><p>sizeCtl在CHM扩容期间的用处大有来头：如下图所示</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8f6d46f059f62cc486c59068a58e948.png" alt="CHM的sc设置基数图示"></p><p>此图可以清晰解释Doug Lea设计<code>sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code>的意图：</p><p>第1个线程将sc设置基数值后，以后每进来一个扩容线程，该线程对sc进行cas加1（结合上图），代码实现是在上面的addCount的分支2.1.2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 分支2.1.2：第1个扩容线程将sc设置基数值后，以后每进来一个扩容线程，那个线程就会对sc进行cas加1后，再执行transfer扩容</span></span><br><span class="line">    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">        transfer(tab, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对sc加1有什么用？其实到这里应该可以理解了：<font color=red>Doug Lea用这种方式记录当前参与扩容线程的数量，</font>为何要记录参与扩容线程的数量？</p><p>两个目的，而且都是非常“聪明”的目的！</p><ul><li>第一个目的：为了限制参与扩容的总线程数</li></ul><p>因为一个JVM进程开启太过多的线程数量（例如10万个线程）参与到扩容，意味着当前OS大量线程在运行，高并发下的线程上下文切换、大量线程栈占用空间，一定程度上导致CHM性能不增加反降低，甚至影响到“系统层面的稳定性”，至于为何设计最大扩容线程数量为65535（对应二进制<code>1111 1111 1111 1111</code>）,需从文章后面的resizeStemp解析中找到答案。</p><blockquote><p>题外话：65535是不是很熟悉？windows 最大可开启的tcp端口号数量？想想为何是这个数2^16-1？或者思考：一个Java进程到底能创建多少线程，注意到最大线程理论值=进程的用户地址空间除以线程栈的大小，用户地址空间和线程栈又取决于操作系统、内存、jvm参数等，具体可参考这篇文章<a href="https://developer.aliyun.com/article/67090">JVM源码分析之一个Java进程究竟能创建多少线程</a></p><ul><li>JVM：<code>Xmx</code>，<code>Xss</code>，<code>MaxPermSize</code>，<code>MaxDirectMemorySize</code>，<code>ReservedCodeCacheSize</code>等</li><li>Kernel：<code>max_user_processes</code>，<code>max_map_count</code>，<code>max_threads</code>，<code>pid_max</code>等</li></ul></blockquote><p>如果参与扩容的线程数量达到了最大值，后面再来第65536、65537、65538个等更多线程，这些线程不会参与到扩容逻辑代码，控制实现在addCount的分支2.1.1的条件：如果sc == rs + MAX_RESIZERS，也即当前参与到扩容队伍的总线程数量达到设定的最大值，再进来的线程不再安排扩容，这些线程会直接break返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">       <span class="comment">// 完成加1计数后，算下当前CHM节点总数量s，看看s有无达到扩容阈值sizeCtl</span></span><br><span class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">           <span class="comment">//分支2.1：这里是sc=sizeCtl，如果sizeCtl是一个负数（因为第1个进来扩容的线程将sc设置为一个基数负值），说明有其他线程正在处理table扩容，那么当前线程自然要看看自己能否参与到扩容逻辑中</span></span><br><span class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 分支2.1.1：如果扩容线程达到最大值，那么后续进来再多扩容线程都会直接break掉，也即不参与扩容逻辑。</span></span><br><span class="line">                 <span class="keyword">if</span> ((条件<span class="number">1</span>|| 条件<span class="number">2</span> ||sc == rs + MAX_RESIZERS || 条件<span class="number">4</span> || 条件<span class="number">5</span>)</span><br><span class="line">                     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>第二个目的：为了确定到底哪个线程是“最后一个完成扩容的线程”？</li></ul><p>为了确定到底哪个线程是“最后一个完成扩容的线程”，并让它来告知外界整个CHM已经完成了扩容，具体如何实现？</p><font color=red>Doug Lea这么设计：每结束一个扩容线程，那个线程就对sc进行cas减1（结合上图理解），直到有一个线程对sc进行cas减1时恰好使得sc就是一开始设置的基础值，那么这个线程就是要找的“最后一个完成扩容的线程”，于是可以将finishing置为true，表示整个CHM的扩容已经完成，对应的源码如下，在transfer方法里面</font>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">     <span class="keyword">while</span> (advance) &#123;  </span><br><span class="line">       <span class="comment">//...省略部分        </span></span><br><span class="line">          <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">//① 这里的逻辑被可改为以下的②、③写法</span></span><br><span class="line">            <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">            i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//...省略部分</span></span><br></pre></td></tr></table></figure>可把`(sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT` 改写为`sc = (resizeStamp(n) << RESIZE_STAMP_SHIFT) +2`，所以以上①逻辑可以改写下面的②和③写法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">     <span class="keyword">while</span> (advance) &#123;  </span><br><span class="line">       <span class="comment">//...省略部分</span></span><br><span class="line">            <span class="comment">//  线程完成自己管辖的桶位节点转移到新表后,那么这个线程就对sc进行cas减1</span></span><br><span class="line">              <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//② 直到有一个线程对sc进行cas减1时恰好使得sc就是一开始设置的基础值，</span></span><br><span class="line">                    <span class="keyword">if</span> (sc==(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) +<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">// 说明这个线程就是“最后一个完成扩容的线程”，由它来结束整个CHM的扩容流程</span></span><br><span class="line">                      finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                      i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                   <span class="comment">//③   </span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 注意这里在transfer解析中给出，请看完下面transfer方法解析再回来看这个return</span></span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                    &#125;            </span><br><span class="line">                &#125;</span><br><span class="line">       <span class="comment">//...省略部分</span></span><br></pre></td></tr></table></figure>这下逻辑清晰了：执行`finishing = advance = true;i = n `后，“最后一个完成扩容的线程”在transfer内部就会按以下执行流程走（按序号升序来看执行流，从底下的①开始）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">    <span class="comment">//④ 因为③的advance=true，进入while，go to⑤</span></span><br><span class="line">  <span class="comment">//⑥ 因为⑤进入if后，advance会改为false，故这里退出while,go to⑦</span></span><br><span class="line">    <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">      <span class="comment">//⑤ 因为③的finishing=true，进入if</span></span><br><span class="line">        <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">          <span class="comment">//回到while⑥</span></span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 此分支与本次解析无关</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 此分支与本次解析无关</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                 (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                  nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                               nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">            bound = nextBound;</span><br><span class="line">            i = nextIndex - <span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//⑦ 因为③的i=n,因此满足条件2：i&gt;=n，进入if</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">        <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="comment">//⑧ 因为③的finishing=true，进入if</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">          <span class="comment">// 回收nextTable引用</span></span><br><span class="line">            nextTable = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将迁移好的新表赋给原来的table引用</span></span><br><span class="line">            table = nextTab;</span><br><span class="line">          <span class="comment">//设置下次扩容阈值</span></span><br><span class="line">            sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">          <span class="comment">//⑨ 退出for循环，代表：整个CHM已完成所有节点的迁移</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//① 线程完成自己管辖的桶位节点转移到新表后,那么这个线程就对sc进行cas减1</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="comment">//② 直到有一个线程对sc进行cas减1时恰好使得sc就是一开始设置的基础值,也即addCount分支2里面的：sc==(rs &lt;&lt; RESIZE_STAMP_SHIFT) +2)，go to ③</span></span><br><span class="line">            <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//③ go to ④</span></span><br><span class="line">            finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">            i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>当线程进入了transfer方法后，这些线程们是怎么知道自己负责第几号到第几号的桶位迁移呢、以及如何将自己管辖的桶位节点转移到新表中呢？这就是tranfer方法里面第二层要深入解析的内容。#### 2、transfer内部精密的并发设计##### 2.1 为每个扩容线程分配“桶位区间”假设现有4个线程并发同一时刻进入transfer逻辑，那么每个线程如何协同转移节点呢？  首先：为每个线程准确划分线程自己要管辖的“桶位区间”，既然要确定桶位区间`[left,right]`，就必然要在并发环境下计算每个线程自己区间的左边界下标和右边界下标，而右区间边界-左区间边界就是步长：stride，也即线程要完成转移的桶位个数（或者领取任务的个数/步长），如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">  <span class="comment">// 计算领取任务的步长，根据cpu个数来计算，如果计算值小于默认步长16，那么就采用默认步长16，否则步长采用计算值。本文为方便作图，将stride设为4</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br></pre></td></tr></table></figure>以下以4个线程为例，table长度16，为了方便作图，本文的stride长度设为4，那么四个线程各自分配到桶位范围如下图所以![WX20210705-212539](https://img-blog.csdnimg.cn/img_convert/f84cad5ea7c6c4d721c6e3a65cb41900.png)划分好每个线程自己的桶位区间有什么用？当然是各司其职，将自己管辖区间内的桶位节点迁移到新table上。那么每个线程分配的桶位区间是如何以并发方式（无锁方式）计算出? 考察现在有线程1，2，3，4共4个线程同一时刻执行到`for (int i = 0, bound = 0;;) ` ，基于当前table=16和本文stride长度设为4。不妨假设线程1先执行，而且线程1是作为“第1个扩容线程”进入到transfer方法里面：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"><span class="comment">// 首次扩容，transfer(table,null),也即nextTab为null，所以进入if</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          <span class="comment">// 线程1先创建一个新表，两倍于旧表容量</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">          <span class="comment">// 在本节中，我们假设旧table是16，因此线程1创建的新表为32,因此不会进入catch逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">          <span class="comment">// 如果线程本次扩容的新表容量恰好达到最大，就不再扩容，直接返回。</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>线程1上面流程走完后有：`transferIndex=n=16,stride=4`线程1：从for循环开始，因为i = 0，bound = 0，因此分支1条件不成立，因为nextIndex = transferIndex=16，显然分支2的条件也不成立，那么只能执行分支3，假设4个线程此时都来到分支3，不妨假设此时线程1抢到CAS，那么对于线程1就会进入分支3逻辑，其他3个线程继续`while`自旋再回到分支3的CAS。线程1执行流程如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">         <span class="comment">// ....省略部分        </span></span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">             <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">           <span class="comment">//分支1：线程1刚进入for循环时，i=0，bound=0，显然不满足分支1条件</span></span><br><span class="line">             <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                 advance = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//分支2:这里的transferIndex的值就是前面transferIndex = n，nextIndex = transferIndex=16，此分支作用：判断CHM剩余可分配给线程桶位的数量，如果&lt;=0,说明CHM所有桶位都分配给线程们了。</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 i = -<span class="number">1</span>;</span><br><span class="line">                 advance = <span class="keyword">false</span>;</span><br><span class="line">             &#125;                </span><br><span class="line"><span class="comment">//分支3：我们已经假设线程1首先抢到cas，故进入if。cas比较前有：nextIndex=transferIndex=16</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                       <span class="comment">// nextBound=(16&gt;4?) 16-4:0=12</span></span><br><span class="line">                       nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">               <span class="comment">// cas成功后，那么TRANSFERINDEX(transferIndex)就从16被设置成12.</span></span><br><span class="line">               <span class="comment">// bound=nextBound=12</span></span><br><span class="line">                 bound = nextBound;</span><br><span class="line">               <span class="comment">// i=16-1=15</span></span><br><span class="line">                 i = nextIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里advance=false后，线程1就可以退出while循环，表明线程1分配到了桶位区间[12,15]分配</span></span><br><span class="line">                 advance = <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>线程2：线程1完成cas逻辑后退出while，其他3个线程还得继续竞争分支3的cas，不妨假设线程2成功操作cas（线程3、线程4只能继续循环cas），那么线程2会执行以下逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">       <span class="comment">// ....省略部分        </span></span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">         <span class="comment">//分支1：线程2刚进入for循环时，i=0，bound=0，显然不满足分支1条件</span></span><br><span class="line">           <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//分支2:注意这里的transferIndex已经被线程1在上面的分支3cas阶段设置成12，含义：旧表16个桶位，目前还剩12个桶位未分配出去（线程1分配了4个）。nextIndex = transferIndex=12</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               i = -<span class="number">1</span>;</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;                </span><br><span class="line"><span class="comment">//分支3：已经假设本次由线程2抢到cas</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     <span class="comment">// nextBound=(12&gt;4?) 12-4:0=8</span></span><br><span class="line">                     nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                  nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">             <span class="comment">// 线程2cas成功后，那么TRANSFERINDEX(transferIndex)就从12被设置成8</span></span><br><span class="line">             <span class="comment">// bound=nextBound=8</span></span><br><span class="line">               bound = nextBound;</span><br><span class="line">             <span class="comment">// i=12-1=11</span></span><br><span class="line">               i = nextIndex - <span class="number">1</span>;</span><br><span class="line">             <span class="comment">// 这里advance=false后，线程2就可以退出while循环，表示线程2现在分配了对应的桶位区间[8,11]</span></span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>线程3：线程2完成cas逻辑后退出while，其他2个线程还是同时竞争分支3的cas，不妨假设线程3成功操作cas（此时线程4只能继续循环cas），那么线程3会执行以下逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">       <span class="comment">// ....省略部分        </span></span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">         <span class="comment">//分支1：线程3刚进入for循环时，i=0，bound=0，显然不满足分支1条件</span></span><br><span class="line">           <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//分支2:注意这里的transferIndex已经被线程2在上面的分支3cas阶段设置成8，含义：旧表16个桶位，目前还剩8个桶位未分配出去（线程1分配了4个，线程2分配了4个）。nextIndex = transferIndex=8</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               i = -<span class="number">1</span>;</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;                </span><br><span class="line"><span class="comment">//分支3：已经假设本次由线程3抢到cas</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     <span class="comment">// nextBound=(8&gt;4?) 8-4:0=4</span></span><br><span class="line">                     nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                  nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">             <span class="comment">// 线程3 cas成功后，那么TRANSFERINDEX(transferIndex)就从8被设置成4</span></span><br><span class="line">             <span class="comment">// bound=nextBound=4</span></span><br><span class="line">               bound = nextBound;</span><br><span class="line">             <span class="comment">// i=8-1=7</span></span><br><span class="line">               i = nextIndex - <span class="number">1</span>;</span><br><span class="line">             <span class="comment">// 这里advance=false后，线程3就可以退出while循环，表示线程3现在分配了对应的桶位区间[4,7]</span></span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>线程4：线程3完成cas逻辑后退出while，目前只有线程4操作分支3的cas，肯定能进入cas，那么线程4会执行以下逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">       <span class="comment">// ....省略部分        </span></span><br><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">         <span class="comment">//分支1：线程4刚进入for循环时，i=0，bound=0，显然不满足分支1条件</span></span><br><span class="line">           <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//分支2:注意这里的transferIndex已经被线程3在上面的分支3cas阶段设置成4，含义：旧表16个桶位，目前还剩4个桶位未分配出去（线程1分配了4个、线程2分配了4个、线程3分配了4个）。nextIndex = transferIndex=4</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               i = -<span class="number">1</span>;</span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;                </span><br><span class="line"><span class="comment">//分支3：本次由线程4抢到cas</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     <span class="comment">// nextBound=(4&gt;4?) 4-4:0=0</span></span><br><span class="line">                     nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                  nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">             <span class="comment">// 线程4 cas成功后，那么TRANSFERINDEX(transferIndex)就从4被设置成0，表示旧表16个桶位中，已经全部分配出去（给到各个线程）</span></span><br><span class="line">             <span class="comment">// bound=nextBound=0</span></span><br><span class="line">               bound = nextBound;</span><br><span class="line">             <span class="comment">// i=4-1=3</span></span><br><span class="line">               i = nextIndex - <span class="number">1</span>;</span><br><span class="line">             <span class="comment">// 这里advance=false后，线程4就可以退出while循环，表示线程4现在分配了对应的桶位区间[0,3]</span></span><br><span class="line">               advance = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><font color=red>经过以上四轮while推演，可以发现四个线程并发同一时刻进入`for (int i = 0, bound = 0;;) `并来到`whlie(advance)` 的实际目的：就是为扩容线程们分配好各自要迁移的桶位区间，分配方式是从table尾部往头部方向的倒序分配，正如上面计算的线程1=>15到12，线程2=>11到8，线程3=>7到4，线程4=>3到0，而且巧妙的是：每个线程分配的桶位区间都不会重叠，原因在于：分支3需要线程自己抢到cas权才能对transferIndex扣减步长值</font><p>在4个线程分配好桶位区间的情况下，此时若存在第5个线程、第6个线程…..它们能分配到桶位区间吗？答案是不能，可以分开两种线程时刻讨论：</p><ul><li>第一种线程时刻：</li></ul><p>不妨假设第5个线程、第6个线程…都是和线程1、线程2、线程3、线程4一起进入到<code>for (int i = 0, bound = 0;;)</code>并来到<code>whlie(advance)</code>，由于前面4个线程分配好了桶位区间（但这个4个线程正准备扩容），此时考察第5个线程，不妨假设从while的①步骤开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">    <span class="comment">// ....省略部分</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> finishing = <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">//① 线程5的首次advance为true，进入while</span></span><br><span class="line">   <span class="comment">//⑤ 来自④的advance=false,go to ⑥</span></span><br><span class="line">    <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">      <span class="comment">//② 线程5首次进入for循环时，i=0，bound=0，（且前面4个线程还没扩容完），显然不满足分支1条件finishing</span></span><br><span class="line">        <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//③ 从线程4的分支3可知，transferIndex已经被设置为0，含义：旧表16个桶位已经全部分配出去，所以线程5会进入该分支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//④ 回到⑤while</span></span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;                </span><br><span class="line"><span class="comment">// 线程5不会到此次分支</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                 (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                  nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                               nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">            bound = nextBound;</span><br><span class="line">            i = nextIndex - <span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//⑥ 因为④的i=-1，满足条件1，进入⑦  </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">        <span class="keyword">int</span> sc;</span><br><span class="line">      <span class="comment">// 前面4个线程还没扩容完，不会进入此if</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            nextTable = <span class="keyword">null</span>;</span><br><span class="line">            table = nextTab;</span><br><span class="line">            sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//⑦ 线程5对sc进行cas减1计数：表示在整个CHM有1个线程正准备离开扩容队伍</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="comment">//⑧ 由“前面4个线程还没扩容完”可知，线程5在⑦中对sc进行减1后，sc肯定还不是基础值，故去到⑨（在这里我们也可以知道，线程5不是“最后一个完成扩容的线程”）</span></span><br><span class="line">            <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">              <span class="comment">//⑨ 线程5返回到外部的addCount方法⑪。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">            i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由上面的①到⑨执行流，可以看出，由于transferIndex已经被线程4设置为0后（表示16个桶位都分配给前面4个线程），第5个线程就会进入③代码片区，最终从⑨结束并返回到外部addCount方法，可以清楚看到线程5在整个过程即没有“分配到桶位区间”也没有参与“桶位节点迁移工作”就直接返回了，继续看线程5返回点，从⑪开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新put一个节点后，addCount(x=1, check=binCount=1)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">     CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">   <span class="comment">// .......省略部分</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">         <span class="comment">//⑫ 因为“前面4个线程还没扩容完”，且sc还是一个负数，因此s必然&gt;=sc = sizeCtl,故线程5go to ⑬</span></span><br><span class="line">           <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">             <span class="comment">//⑬ 因为“前面4个线程还没扩容完”，那么sc还是个负值，故线程5go to ⑭</span></span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//⑭ 在上面tansfer方法的③步骤中已经知道，transferIndex已经是等于0，故满足条件5：transferIndex &lt;= 0，所以线程5会被break并退出了while循环。</span></span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>); <span class="comment">//⑪ 线程5返回点，接着线程5会回到while</span></span><br><span class="line">               s = sumCount();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在这里⑭步骤可以知道，线程5就退出了。</p><font color=red>由此，我们终于搞清楚这样的扩容安排：对于旧表16开始扩容时，已经有4个线程分配好各自待迁移桶位区间后，如果此时后续再来第5个线程、第6个线程等更多线程进入到扩容逻辑transfer方法，这些后来者线程（或者在分配桶位区间竞争失败的线程）最终即没有“分配到桶位区间”也没有参与“桶位节点迁移工作”，直接结束addCount方法调用。</font><ul><li>第二种线程时刻：</li></ul><p>假设线程1、线程2、线程3、线程4已经分配好了桶位区间，并假设此时第5个线程、第6个线程等其他线程开始进入AddCount方法内部的while位置：此时考察第5个线程，由于transferIndex已经等于0可知，其实此时线程5（线程6等）就会回到上面第一种情况分析的⑭步骤：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⑬ 因为“前面4个线程还没扩容完”，那么sc还是个负值，故线程5go to ⑭</span></span><br><span class="line"> <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">//⑭ 在上面tansfer方法的③步骤中已经知道，transferIndex已经是等于0，故满足条件5：transferIndex &lt;= 0，所以线程5会被break并退出了while循环。</span></span><br><span class="line">     <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">         sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">         transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>结论跟第一种情况一样，此处不再累赘。</p><p>关于以上四个线程并发分配桶位区间的计算过程，总结如下图</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f47502051e91952d11b6083955357035.png" alt="四个线程桶位分配过程"></p><h5 id="2-2-桶位区间迁移节点的设计"><a href="#2-2-桶位区间迁移节点的设计" class="headerlink" title="2.2 桶位区间迁移节点的设计"></a>2.2 桶位区间迁移节点的设计</h5><p>前面给4个线程分配好各自的桶位区间后，接下来四个线程要完成自己管辖的桶位区间节点迁移任务。</p><p>不妨以线程1作为考察：线程1管辖的桶位区间是<code>[12,15]</code>，从第i=15号桶位开始进行节点迁移，直到4个桶位节点都迁移完毕的图示流程：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c8943d787e863bb0df0f6bc57f8fcf95.png" alt="线程1迁移桶位区间过程"></p><p>图中的fwd节点：线程每完成一个节点迁移，就在旧表桶位放置一个fwd节点</p><p>以下的桶位区间节点迁移过程是基于i=15桶位开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Forwarding中文译为：转发、转投，因此ForwardingNode表示“转发节点”，这个类也是jdk1.8CHM一个关键设计，起着“通告作用”，只要有写线程进行put、replace、clear、compute看到桶位是一个fwd节点，那么这些线程就会转而去加入扩容队伍（帮助扩容helpTransfer）、而读线程约到fwd节点就会“转到”新表去读数据节点</span></span><br><span class="line">ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"><span class="comment">// 例如，线程1管辖的桶位区间是`[bound,i]`，第i个捅位节点迁移完毕后，advance为true时，表示线程1向前移动1步（i指针向右移动1步）以便继续迁移第--i个桶位节点</span></span><br><span class="line">      <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab        </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 逻辑1：线程1首次拿到桶位区间[12,15]会退出while，走到逻辑2</span></span><br><span class="line">          <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">              <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 分支1：接续下面的逻辑3、逻辑4、逻辑5，请看完逻辑3、逻辑4、逻辑5后再回来分支1的条件</span></span><br><span class="line">              <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 分支2</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  i = -<span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">             <span class="comment">// 分支3：</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                       (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                     nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                  bound = nextBound;</span><br><span class="line">                  i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 逻辑2：接逻辑1，i=15，不满足这三个判断条件，因此会跳过逻辑2走到逻辑3</span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">              <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 分支2.1</span></span><br><span class="line">              <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                  nextTable = <span class="keyword">null</span>;</span><br><span class="line">                  table = nextTab;</span><br><span class="line">                  sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="comment">// 分支2.2</span></span><br><span class="line">              <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                  i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* 逻辑3：旧表中不是每个桶位都有节点数据，当线程1发现桶位15为null时，就在此放入一个ForwardingNode节点，告知外界：当前桶位正在迁移节点，这样当其他线程看到桶位节点是fwd时，就转去执行帮助扩容逻辑，如下所示</span></span><br><span class="line"><span class="comment">      还记得putVal方法里面的以下设计吗:</span></span><br><span class="line"><span class="comment">      其他线程看到桶位节点是fwd时，就转去执行帮助扩容的逻辑。</span></span><br><span class="line"><span class="comment">      else if ((fh = f.hash) == MOVED)</span></span><br><span class="line"><span class="comment">              tab = helpTransfer(tab, f);   </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">              advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逻辑4：如果逻辑3条件不成立，就会走到逻辑4，也即线程1发现第15号桶位已经是一个fwd节点，说明当前桶位节点已经被其他线程迁移完毕，那么线程1可以跳过第15号桶位继续向前走1步，advance = true，也即去第14桶号桶，然后回到while逻辑1里面的分支1</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">// 逻辑5：若线程1走到这里，说明当前桶位节点是一个正常的数据节点（链表、红黑树），直接给当前桶位头节点加独占锁后，执行迁移节点到新表的逻辑</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) </span><br><span class="line">                <span class="comment">// 省略部分</span></span><br><span class="line">                <span class="comment">//将i位置低位节点链迁移到新表的i位置 </span></span><br><span class="line">                 setTabAt(nextTab, i, ln);</span><br><span class="line">             <span class="comment">//将i位置高位节点链迁移到新表的i+n位置 </span></span><br><span class="line">                 setTabAt(nextTab, i + n, hn);</span><br><span class="line">            <span class="comment">//在当前桶位放入fwd，告知外界：当前桶位已经迁移完</span></span><br><span class="line">                 setTabAt(tab, i, fwd);</span><br><span class="line">            <span class="comment">//advance = true让线程1回到逻辑1while里面的分支1，表示继续处理第14号（--i）桶位节点</span></span><br><span class="line">                 advance = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>有了以上扩容线程1对i=15桶节点迁移流程的说明后，那么接下里继续讨论线程1如何知道已经完成<code>[bound=12,i=15]</code>桶位区间所有节点迁移且退出for循环的流程。</p><p>不妨考察线程1当前迁移的桶位是第i=13桶号，之后的执行流程按以下序列号进行，从底部的①开始按升序知道第⑰步的return，以下逻辑一定耐心看完，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//addCount调用transfer(tab, null);</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ......省略部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">          <span class="comment">//③ 从底部②的advance为ture，故进入while，go to ④</span></span><br><span class="line">          <span class="comment">//⑥ 从⑤的advance为false，故退出while，go to ⑦</span></span><br><span class="line">          <span class="comment">//⑪ 从底部⑩的advance为ture，故进入while，go to ⑫</span></span><br><span class="line">          <span class="comment">//⑮ 从⑭的advance为false，故退出while，go to ⑯</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">              <span class="comment">//④ --i等于12&gt;=bound=12,进入if</span></span><br><span class="line">              <span class="comment">//⑫ --i等于11已经越过左边界bound=12，不进入if,go to ⑬</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                  <span class="comment">//⑤ 回到while⑥</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//⑬ 由于16个桶位已全部分配出去，因此transferIndex=0，满足条件，进入if</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//⑭ 说明线程1已经迁移完自己管辖的4个桶位节点，不需要继续前进处理下一个桶位了，go to⑮</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// 线程1已经分配好桶位区间，故分支与本次解析无关，可忽略</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//⑯ 因为⑭已经将i设为-1，这里满足条件i&lt;0,进入if，go to ⑰ </span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">              <span class="comment">// 我们假设线程1不是“最后一个完成扩容的线程”，故跳过逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//⑰ 线程1对sc进行cas减1操作：表示在整个CHM有1个线程正准备离开扩容队伍</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="comment">// 由于我们假设线程1不是“最后一个完成扩容的线程”，满足条件，执行return，退出for循环</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//⑦ 在这里我们假设第12号桶不为空，因此go to ⑧</span></span><br><span class="line">          <span class="comment">// (如果第12号（i）桶为空，就直接给该桶位设为fwd表示已处理，将advance设为true：表示让线程1继续迁移下一个（第--i个）桶位节点。回到上面while循环)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">          <span class="comment">//⑧ 在这里我们假设第12号桶不是fwd节点而是正常节点，因此go to ⑨</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              <span class="comment">//(如果第12号（i）桶是一个fwd节点，表示有其他“协助型线程”处理过（所以源码注释为already processed），那么线程1更省功夫了，直接将advance设为true：表示让线程1继续迁移下一个（第--i个）桶位节点。回到上面while循环)</span></span><br><span class="line">                advance = <span class="keyword">true</span>; </span><br><span class="line">          <span class="comment">//① 准备迁移i=13号桶位，去setTabAt等逻辑</span></span><br><span class="line">          <span class="comment">//⑨ 准备迁移i=12号桶位，去setTabAt等逻辑</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="comment">// 如果是桶位节点是普通链表</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">// 将低位链表、高位链表迁移到新表对应的i、i+n位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                      <span class="comment">// 在第i=13号桶位放置fwd节点，表明该桶位已经处理完</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                      <span class="comment">// ② 将advance设为true，回到while③</span></span><br><span class="line">                      <span class="comment">// ⑩ 再次将advance设为true，回到while⑪</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                  <span class="comment">// （类似链表的逻辑）如果是桶位节点是TreeBin（也即桶位是一棵红黑树）</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line"><span class="comment">//（类似链表的逻辑）</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在考察线程1执行完⑰的return后，它会在回到⑲while处，然后流程如下：最后发现线程1完成自己桶位区间节点迁移后，会在以下的㉑步骤退出while循环结束addCount方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addCount(long x, int check)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ......省略部分</span></span><br><span class="line">     <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">       <span class="comment">//⑲ 由于线程2、3、4还在迁移桶位节点中，因此这里sc = sizeCtl还是负值，而s=sumCount()是正值，因此能进入while，go to ⑳</span></span><br><span class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">           <span class="comment">//⑳ 由于线程2、3、4还在迁移桶位节点中，因此这里sc = sizeCtl还是负值</span></span><br><span class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//㉑  基于上面线程1到线程4的桶位分配完毕，因此transferIndex还是等于0，故线程1在这里就会break退出addCount方法</span></span><br><span class="line">                 <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                     sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                     transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                     transfer(tab, nt);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                          (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">               <span class="comment">//⑱ 来自内部transfer第⑰步的return，线程1继续返回到while</span></span><br><span class="line">                 transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">             s = sumCount();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-桶位节点转移到新表"><a href="#2-3-桶位节点转移到新表" class="headerlink" title="2.3 桶位节点转移到新表"></a>2.3 桶位节点转移到新表</h5><p>2.1关注的是线程自己如何一个桶位一个桶位迁移的控制逻辑，那么接下来就要解释扩容线程如何将旧表桶位节点转移到新表中的过程，其实只要掌握jdk1.8的HashMap双向链表到树和jdk1.7的ConcurrentHashMap链表转移设计思想，以下逻辑则很好理解：</p><p>针对两种数据节点类型对应两种迁移设计：</p><ul><li>链表迁移思路：</li></ul><p>1、synchronized锁住当前桶位头节点f，保证当前线程独占操作。<font color=red>换句话说：只能有1个线程负责迁移当前桶位节点到新数组，请别误解为：jdk1.8多线程并发协同扩容是指多个线程一起在同一个桶位上“并发协同”迁移桶位节点。</font></p><p>2、如果桶位头节点是一条链表，先找出lastRun节点为首的子链，然后根据高位节点（p.hash &amp; n 不等于0）和低位节点特征（p.hash &amp; n等于0）分别构建一条低位节点链ln和一条高位节点链hn</p><p>（如果你已经掌握jdk1.7CHM的Segment数组扩容算法，你会发现jdk1.8的处理方式比1.7更优，因为jdk1.8引入了低位节点链和高位节点链作为迁移前的中间容器，而这里的低位链和高位链的设计需要你掌握jdk1.8HashMap的数组扩容算法）</p><p>3、链表除去lastRun子链，还剩下位于lsatRun节点前面的节点，将这些节点使用头插法插入到ln或者hn中</p><p>4、此时冲突链被完整的拆开成低位链和高位链，接下来就好办了：使用cas方式，低位链放在新表的第i位置，高位链放在新表的第i+n位置</p><p>5、第4点迁移完后，线程在当前桶位放置一个fwd，表示当前桶位已迁移完。</p><p>6、线程将advance设为true，回到while继续处理“桶位区间”的下一个待迁移桶位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (advance) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">    <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">        advance = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这里再次提醒：“桶位区间”的迁移顺序是倒序的，例如当前线程负责的桶位区间为[12,15]，当第15号桶位迁移完后，—i继续处理下一个第14号桶位节点，以此类推，直到—i等于11越过左边界12，说明此时桶位区间包含的4个桶位节点全部被当前线程迁移到新表里面。</p><p>lastRun子链是什么？</p><p>就是从链表的尾部节点开始，找到具有相同的（e.hash &amp; n）值的连续最大子链，图示如下：</p><p>其中e.hash &amp; n的计算公式可找出低位节点和高位节点。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2ed6f93efc10facd087b82560a4c75f4.png" alt="lastRun示意图.001"></p><ul><li>TreeBin（红黑树）迁移思路</li></ul><p>因为TreeBin持有红黑树的root节点，关于红黑树扩容的分析在在jdk1.8的HashMap文章有详细的过程，CHM也类似逻辑，这里不再累赘。</p><p>以上两种迁移思路就是下面transfer方面里面：<code>synchronized (f)</code>代码片段要实现的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line"><span class="comment">//......省略部分</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 线程若能进入以下分支，说明此桶位头节点既不是null也不是转发节点fwd，那么该桶位头节点要么是一条冲突链表、要么是一个TreeBin节点（也即一棵红黑树）</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 链表的迁移逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                  <span class="comment">// ln:用于存放低位节点链，hn:用于存放高位节点链</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                      <span class="comment">//①</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                          <span class="comment">// 找出有相同特征的、以lastRun节点为首的子链</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// runBit也即p.hash &amp; n=0，说明是低位节点</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">// runBit == 0，说明lastRun子链是低位节点构成的，因此理应将lastRun放在低位链ln，此时hn还是设为null，hn在第②步骤会被用到</span></span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 也即runBit不为0，p.hash &amp; n !=0，说明是高位节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      </span><br><span class="line">                        <span class="comment">//②  </span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                          <span class="comment">//(ph &amp; n) == 0的节点是低位特征节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                              <span class="comment">// 将剩余的低位节点使用头插法插入到低位链中</span></span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="comment">//(ph &amp; n) !=0的节点是高位特征节点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                               <span class="comment">// 将剩余的低位节点使用头插法插入到高位链中</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                      </span><br><span class="line">                        <span class="comment">//使用cas机制：低位链放在新表的第i位置，</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                      <span class="comment">//使用cas机制：高位链放在新表的第i+n位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                      <span class="comment">//在旧表当前i桶位放置fwd节点，表示已迁移完</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                      <span class="comment">// 回到while继续处理下一个桶位</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">// 用于存放红黑树中低位节点的单向链表</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      <span class="comment">// 用于存放红黑树中高位节点的单向链表</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      <span class="comment">// lc计数器，用于判断低位节点链是否需要树化，hc同理</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                      </span><br><span class="line">                        <span class="comment">//③ jdk1.8的CHM红黑树本身也是一条单向链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                          <span class="comment">// 构建低位节点单向链表，并计数</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//如果p.prev和hiTail是空，说明当前p节点是头节点，放在lo位置</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                  <span class="comment">// 其他非头节点，按尾插法插入到链表尾部</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                              <span class="comment">//遍历下一个节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                              <span class="comment">//链表长度计数</span></span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 构建高位节点单向链表，并计数</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;                                  </span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 低位链表是否需要树化，计数小于等于6不进行树化，如果不存在高位链表，</span></span><br><span class="line">                      <span class="comment">/* 低位链表需要树化:</span></span><br><span class="line"><span class="comment">                       1、若hc!=0，将低位节点链表包装成TreeBin类型（内部会重新构建树），以便放入到新表对应的桶位头节点位置</span></span><br><span class="line"><span class="comment">                       2、若hc=0，说明新构建的低位链还是原来红黑树本身的链表，无需改动，直接返回ln=t。   TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span></span><br><span class="line"><span class="comment">                      */</span> </span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                      <span class="comment">// 同上，不再赘述。</span></span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-4-transfer扩容并发度讨论"><a href="#2-4-transfer扩容并发度讨论" class="headerlink" title="2.4 transfer扩容并发度讨论"></a>2.4 transfer扩容并发度讨论</h5><p>在jdk1.7的CHM中，它的并发度设计是相对受限的，在创建CHM中，可以指定CONCURRENCY_LEVEL的值来设并发度，遗憾的是：一旦创建好，CHM支持的并发度就不能更改。并且在jdk1.7的CHM中，指定的并发度设计的太大或者太小也会有问题：</p><ul><li>并发太小时，多个线程都在竞争数量不多的segment加剧竞争，可谓“僧多粥少”</li><li>并发度设为太大时（例如segment并发度设为65535最大值），使得key原本可定位在同一个segment的读、写操作就会被分配到不同的segment中，结果是cpu cache命中率会下降，会在一定程度上降低CHM性能</li></ul><p>而在jdk1.8创建CHM中，它不会限制并行度：</p><blockquote><p>考察put/transfer方法，内部在桶位迁移用时<code>synchronized</code>锁住桶位头节点f的设计，也即锁粒度为桶位，那么随着transfer方法扩容CHM使得底层table更大后，因为锁粒度为桶位，因此并发度也随着变大，换句话说，jdk1.8的CHM的并发度是动态变化：并发度大小等于底层数组长度，底层数组每扩容1次，并发度就变大1倍，而不是像jdk1.7那样再创建期间并发度就被限制死了。</p></blockquote><p>当然jdk1.8CHM的并发度因为是动态变大，当table容量太大时，也会面临cpu cache命中率会下降的性能问题。</p><h5 id="2-5-CHM扩容时，可以同时支持读取get节点吗？"><a href="#2-5-CHM扩容时，可以同时支持读取get节点吗？" class="headerlink" title="2.5 CHM扩容时，可以同时支持读取get节点吗？"></a>2.5 CHM扩容时，可以同时支持读取get节点吗？</h5><p>答案是支持的，CHM扩容完全不影响其他读线程读取key，为何？在“transfer方法桶位节点转移的处理逻辑”小节可以得到答案：</p><p>例如桶位的冲突链正在扩容，你发现它扩容时只是复制该链表的节点（ln = lastRun），也就是原链表还在桶位上，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runBit也即p.hash &amp; n=0，说明是低位节点</span></span><br><span class="line">  <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// runBit == 0，说明lastRun子链是低位节点构成的，因此理应将lastRun放在低位链ln，此时hn还是设为null，hn在第②步骤会被用到</span></span><br><span class="line">      ln = lastRun;</span><br><span class="line">      hn = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 也即runBit不为0，p.hash &amp; n !=0，说明是高位节点</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      hn = lastRun;</span><br><span class="line">      ln = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从红黑树的迁移更容易找到答案：</p><p>迁移线程将红黑树的节点复制到一条（lo—-&gt;loTail或者hi—-&gt;hiTail）或者两条新链表上（lo—-&gt;loTail以及hi—-&gt;hiTail），桶位上原链表结构（TreeNode的next属性构成）未发生任何改变，因此若此时有“读线程”来读桶位上key是完全OK的，不受扩容线程影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">    <span class="comment">// 用于存放红黑树中低位节点的单向链表</span></span><br><span class="line">    TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 用于存放红黑树中高位节点的单向链表</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// lc计数器，用于判断低位节点链是否需要树化，hc同理</span></span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//③ 将原链节点拷贝到hi/lo链上，这里可以证明：CHM扩容时也支持并发get原链表</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = e.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">            (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 用原节点的key和value创建一个新的TreeNode，不就相当于拷贝节点，且原链表结构没有收到影响。</span></span><br><span class="line">      <span class="comment">// 构建低位节点单向链表，并计数</span></span><br><span class="line">        <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果p.prev和hiTail是空，说明当前p节点是头节点，放在lo位置</span></span><br><span class="line">            <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                lo = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="comment">// 其他非头节点，按尾插法插入到链表尾部</span></span><br><span class="line">                loTail.next = p;</span><br><span class="line">          <span class="comment">//遍历下一个节点</span></span><br><span class="line">            loTail = p;</span><br><span class="line">          <span class="comment">//链表长度计数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3、helpTransfer方法解析"><a href="#3、helpTransfer方法解析" class="headerlink" title="3、helpTransfer方法解析"></a>3、helpTransfer方法解析</h4><p>有了上面transfer详细的多线程协同扩容细节铺垫后，那么helpTransfer方法则相当好理解：</p><p>该方法在CHM的相关“写操作”方法被调用，如：put、remove、replace、clear、compute、computeIfAbsent、merge，实际含义为：</p><blockquote><p>当一个线程去对CHM进行写操作时（put、remove、replace、clear、compute、computeIfAbsent、merge）”，如果恰好遇到桶位节点是一个ForwardingNode节点，那么这个线程先转而去帮助当前CHM扩容。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**留意源码官方注释</span></span><br><span class="line"><span class="comment"> * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="comment">//① 条件1和条件3都是判断底层table还在扩容中，条件2再次检查当前桶位是否是一个ForwardingNode节点</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">      <span class="comment">//③  while自旋配合cas进制是一套很常用的逻辑。三个条件都是能够判断“只要底层table还在扩容”</span></span><br><span class="line">      <span class="comment">//条件1：nextTab == nextTable，说明nextTable还未指向table变量，</span></span><br><span class="line">      <span class="comment">//条件2：table == tab，table变量还是指向旧表tab</span></span><br><span class="line">      <span class="comment">//条件3：有了前面小节内容的铺垫，这里sizeCtl是负数表示CHM在扩容中</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//④ 这4个条件都是判断是否协助扩容，任意一个条件成立都使得线程不需要再去参与扩容，直接break返回，当然前面3个判断条件的理解目前相对困难，可看完后面章节即可立即。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//⑤ 每个进入扩容的线程都要对sc进行加1计数，由于采用cas方法，一次cas不成功就继续回到③while重试，直到sc加1成功或者满足④判断条件才不会继续while重试</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//⑥ 只要③的while条件成立，说明底层table已经扩容完成，可直接返回新table引用：nextTab给到外部调用点：tab = helpTransfer(tab, f)，这是tab指向的是扩容后的table</span></span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//② 如果①有个一个条件不成立，说明已经完成底层数组扩容，那当前线程就不需要“帮助扩容”，直接返回table引用（注意此table引用其实是指向了newTab，也即扩容后的那个table）</span></span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、addCount主分支2为何使用while循环"><a href="#4、addCount主分支2为何使用while循环" class="headerlink" title="4、addCount主分支2为何使用while循环"></a>4、addCount主分支2为何使用while循环</h4><h5 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h5><p>只要CHM节点数量size达到扩容阈值且数组长度还未到最大值MAXIMUM_CAPACITY就可以进行扩容操作，这一点其实跟HashMap的扩容判断是一致的。</p><p>主分支2里面为何使用<code>while</code> 循环判断是否需要扩容呢？ 就不能用<code>if</code>来取代吗？答案：不能，因为CHM是并发扩容，不是单线程的HashMap扩容操作，如果将主分支2的<code>while</code>改为<code>if</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//addCount的主分支2  </span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"><span class="comment">//将while改成if</span></span><br><span class="line">         <span class="keyword">if</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">//扩容逻辑</span></span><br><span class="line">             s = sumCount();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>考察并发量高两种情形：</p><ul><li><p>情况1：使得扩容完成的线程能继续加入未完成的扩容任务</p><p>在原table还有桶位未分配出去时，也即transferIndex&gt;0，那么某线程A完成自己的桶位区间的节点迁移后，主分支2使用<code>while</code>语义就可以保证线程A继续加入到还未完成的扩容任务，而不是退出，显然线程A得到复用，而不需要创建新的线程，提高cpu效率。若使用<code>if</code>语义，当线程A完成自己的桶位区间的节点迁移后会直接退出，未充分利用已在执行态的线程A。</p></li><li><p>情况2：上一阶段刚扩容完因并发量高导致节点数量立即达到下一阶段扩容阈值</p><p>在CHM容量n0扩容到容量n1，有一扩容线程A完成扩容后退出，并发的其他线程很快把线程A扩容的容量n1的table写满，此时需要继续将容量n1的table扩容到容量n2（但线程A已经退出扩容处理），结果容量n2的新表很快又被并发的其他线程put满，此时急需第3次扩容（但线程A已经退出扩容处理），结果容量n3的新表很快又被并发的其他线程put满，以此类推…</p><font color=red>所以你会发现：既然线程第1次扩容的n1很快会被并发的其他线程put满，那么可以这么设计：线程完成扩容transfer逻辑后先不结束线程，而是使用`while`强制安排线程继续判断CHM是否需要下一阶段扩容，如果需要下一阶段扩容，线程立即设置基础值然后进入transfer开始下一阶段扩容，复用已经处在执行态的线程，而不是去创建新线程。</font></li></ul><h5 id="4-2-线程会不会无限次扩容"><a href="#4-2-线程会不会无限次扩容" class="headerlink" title="4.2 线程会不会无限次扩容"></a>4.2 线程会不会无限次扩容</h5><p>按情况2的解释，线程岂不是无限次扩容？这就是次分支1要解决的情况，里面有一个<code>break</code>，显然这就是<code>while</code>循环结束点，所以线程不会无限扩容下去，那么满足什么条件线程才会<code>break</code>，这里就需要第5节的<code>resizeStamp</code> 技术点来解释，请参考之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分支1</span></span><br><span class="line"> <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 次分支1</span></span><br><span class="line">     <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">         sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">         transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="5、resizeStamp-n-以及sc变量的解析（CHM最关键的设计之一）"><a href="#5、resizeStamp-n-以及sc变量的解析（CHM最关键的设计之一）" class="headerlink" title="5、resizeStamp(n)以及sc变量的解析（CHM最关键的设计之一）"></a>5、resizeStamp(n)以及sc变量的解析（CHM最关键的设计之一）</h4><h5 id="5-1-rs设计意图？"><a href="#5-1-rs设计意图？" class="headerlink" title="5.1 rs设计意图？"></a>5.1 rs设计意图？</h5><p>resizeStamp方法和sc变量在transfer方法里面给我们造成很大困扰，它们的设计意图不好理解，resizeStamp是CHM的最关键设计之一，因此需要一步一步用位运算去探索和推演Doug Lea为何采用二进制的角度来实现sizeCtl支持多种状态标记以及rs扩容印记的设计，具体如下：</p><p>首先，使用场景肯定是用于扩容，不管从其方法命名还是从下面源码官方注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Table Initialization and Resizing -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the stamp bits for resizing a table of size n.</span></span><br><span class="line"><span class="comment"> * Must be negative when shifted left by RESIZE_STAMP_SHIFT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>第二点，可以用resizeStamp的值和sc变量来判断整个CHM扩容是否结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>第三点，sc变量可以记录进入扩容逻辑的线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                   transfer(tab, nt);</span><br></pre></td></tr></table></figure><p>还可以实现对退出扩容逻辑线程的计数以及找出最后一个完成扩容的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">    i = n; <span class="comment">// recheck before commit</span></span><br></pre></td></tr></table></figure><p>带着以上思路，现在以table长度n=16需要扩容进行逐步深入分析，以下全部计算过程采用位计算方式，Int类型为32位，分为高16位和低16位，第32位是符号位。</p><p>对于resizeStamp(16)有以下计算结果，其中<code>Integer.numberOfLeadingZeros(n)</code> 返回n对应的二进制高位0的个数，例如n=16，其高位0个数为32-5=27，假设现有一个线程A作为首个扩容线程，开始执行AddCount分支2流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//AddCount方法的分支2</span></span><br><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 从这里开始推演相关位运算的逻辑</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算<code>int rs = resizeStamp(n=16);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0001 1011  # 27</span><br><span class="line">0000 0000 0000 0000 1000 0000 0000 0000  # 1&lt;&lt;15</span><br><span class="line"></span><br><span class="line">或运算结果如下,得到容量16的rs：</span><br><span class="line">0000 0000 0000 0000 1000 0000 0001 1011  # 32795</span><br></pre></td></tr></table></figure><p>可以看出：rs的低16位记录了“table长度16信息”，其设计意图是？</p><p>目的就是为了给table等于16这一容量值打上一个“戳（印记）”，或者称为”table长度为16的扩容印记”，简称“扩容印记”。<br>需要注意的是：下面小节的sc变量的“table长度16的信息”是记录在sc的高16位上，区别于rs的低16位记录“table长度16信息”。</p><p>作为对比，假设table容量32需要扩容处理，那么table此时对应的“扩容印记”rs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0001 1010  # 26</span><br><span class="line">0000 0000 0000 0000 1000 0000 0000 0000  # 32768</span><br><span class="line">或运算结果如下,得到容量32的rs：</span><br><span class="line">0000 0000 0000 0000 1000 0000 0001 1010 # 32794</span><br></pre></td></tr></table></figure><p>通过对比容量16和容量32的table扩容印记可知，不同容量下的扩容阶段都有其唯一“扩容印记”rs，那么只要线程在扩容时发现：前后读取的rs值不同，说明整个CHM已经完成上一阶段的扩容且正在进行下一阶段扩容，那么线程就可以直接退出，无需进入transfer方法，对应下面的代码片段的条件1用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 从这里开始推演相关位运算的逻辑</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">        <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*后面时刻读取的rs：sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT</span></span><br><span class="line"><span class="comment">          前面时刻读取的rs: rs</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="comment">//后面时刻读取的rs与前面时刻读取的rs不等,说明整个CHM已经完成了扩容，那么线程就可以直接退出，无需进入transfer方法// 条件1</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || 其他<span class="number">4</span>个条件)</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>因此<code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code> 是表达这种场景：线程进入CHM扩容任务发现CHM已经结束了本阶段的扩容，因此线程无需参与到扩容任务中，退出即可。</p><h5 id="5-2-sc相关位运算的设计意图？"><a href="#5-2-sc相关位运算的设计意图？" class="headerlink" title="5.2 sc相关位运算的设计意图？"></a>5.2 sc相关位运算的设计意图？</h5><p>条件1：<code>sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code> 已经由上面的小节详细分析，此小节尝试回答条件2：<code>sc == rs + 1</code> 和条件3：<code>sc == rs + MAX_RESIZERS</code>   设计目的？</p><p>不妨做个猜测：通过对比条件2和条件3发现，条件2像是sc变量的最小值，条件3像是sc变量允许的最大值，从最大值的MAX_RESIZERS含义可推出：扩容线程数量最大值，说明条件3可用于限制同时参与扩容线程的最大数量。根据条件3设计了扩容线程的上限，我们可以大胆推理出：条件2指的是当前CHM已经没有扩容线程在扩容了，也即所有扩容线程已经退出扩容任务，此时再来新的线程即可break</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 条件2：sc == rs + 1</span></span><br><span class="line">  <span class="comment">// 条件3：sc == rs + MAX_RESIZERS</span></span><br><span class="line">       <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">           sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">           transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>将上面基本猜测进行以下位计算的原理论证：</p><p>在第1节addCount给出的重要设计点“第一个执行扩容的线程”，它进入transfer方法前，将sc设为一个值：sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，下面看看这个二进制串隐藏了什么“隐秘信息”，以容量16的戳印记rs为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 1000 0000 0001 1011 #  </span><br><span class="line">右移RESIZE_STAMP_SHIFT&#x3D;16位后如下：</span><br><span class="line">1000 0000 0001 1011 0000 0000 0000 0000 # 第32位是符号位，1表示负值</span><br></pre></td></tr></table></figure><p>先看高16的含义：对比原来rs二进制串可知，“容量16的扩容印记”放在sc的高16位上。</p><p>再看低16位的含义：</p><p>第1个进入扩容的线程执行：sc=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，对应二进制串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0010 # 低16位+2</span><br></pre></td></tr></table></figure><p>第2个进入扩容transfer方法前，线程都会对sc加1操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0011 # 低16位+3</span><br></pre></td></tr></table></figure><p>第3个进入扩容transfer方法前，线程都会对sc加1操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0100 # 低16位+4</span><br></pre></td></tr></table></figure><p>易归纳：<br>当n个线程加1时使得sc的低16位达到以下值时，参与扩容线程总数达到最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 1111 1111 1111 1111 # 低16位&#x3D;65535</span><br></pre></td></tr></table></figure><p>此时，低16位的值65535不就是Doug Lea设计的最大扩容线程数量：<code>MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1</code>的值吗</p><p>以上流程可以得出这样一个规则：同一阶段扩容期，sc的高16位保持不变，对于sc低16位，除去第1个线程，后续每进一个扩容线程，低16位加1计数</p><p>综上，可以得出这样的结论：</p><p>① sc高16位是存放当前table容量的印记（扩容戳）信息，目的：只要是同一容量下CHM扩容，那么高16位的值固定不变</p><p>② sc低16位用于对参与扩容线程的计数。计数范围为： 0000 0000 0000 0010到1111 1111 1111 1111</p><p>在CHM还是扩容状态时，由高16位扩容印记的第32位1符号位可知，不管低16位现在记录了多少个扩容下线程，sc一定是负数，</p><p>因此在源码设计才有以下<code>if (sc &lt; 0)</code>  成立就能判断出CHM还在扩容状态中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// rs是正值：0000 0000 0000 0000 1000 0000 0001 1011 </span></span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//② 这里也有rs，是正值还是负值呢？</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">              <span class="comment">//③</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h5 id="5-3-解析sc-rs-1的真实含义（这是官方bug）"><a href="#5-3-解析sc-rs-1的真实含义（这是官方bug）" class="headerlink" title="5.3 解析sc == rs + 1的真实含义（这是官方bug）"></a>5.3 解析<code>sc == rs + 1</code>的真实含义（这是官方bug）</h5><p>这个条件很诡异，首先线程进入<code>if (sc &lt; 0)</code> 分支，说明sc是负数，在此之前<code>rs = resizeStamp(n)</code>扩容印记的计算结果是正值，那么<code>sc == rs+1</code> 以及<code>sc == rs + MAX_RESIZERS</code> （负数==正数）永远都不会成立，这个正是open jdk1.8的CHM出现一个重点bug。</p><p>本人一开始对此条件成立情况很是费解，但因为一直认为Doug Lea以及JSR-166 expert group在JUC造诣很深，因此还不曾怀疑此处设计有逻辑问题，接着出于要对resizeStamp方法和sc移位计算的设计彻底掌握的要求，去查阅了相关文章，恰好找到一篇高质量文章，它提到了这其实一个官方的bug：<a href="https://mp.weixin.qq.com/s/6HWJDKnNaceIEZQMOLZkog">文章连接</a>，到此本人才真正对<code>sc == rs + 1</code>诡异设计得到最官方的解决方案！！ <a href="https://bugs.openjdk.java.net/browse/JDK-8214427">这是官方bug描述的链接</a>，bug已经java 12版本得到修复。本人在另外一篇文章中也详细给出了官方对这个bug的处理过程。</p><font color=red>（ [这篇关于CHM源码研究的文章](https://mp.weixin.qq.com/s/6HWJDKnNaceIEZQMOLZkog)，作者水平确实不错，解析也足够细腻，但本人还是建议那些想要彻底掌握或者提升高级技术的人，切勿抄袭别人文章，务必独立完成相关源码的核心设计分析才能真正提升个人能力）</font><p>在去查阅了resizeStamp讨论的相关文章的过程中，你发下绝大部分的文章给出有效讨论真的很少，而且你会发现以下现象：</p><font color=red>当前CSDN大量文章、微信公众号文章、以及所谓的JAVA进阶培训班绝大部分是基于针对jdk1.8CHM的源码解析，而且他们也不能解释`sc == rs + 1`的上下文计算过程及其设计目的，他们无法发现或者感知如此隐秘而有意义的bug，所以他们一般都会停留在表面类似这样源码解释：当前已经没有扩容线程在扩容或者参与扩容线程总数量达到最大值” </font><p>如果你已经吃透本文的所有分析，那么你应该可以猜出Doug Lea写这两行代码的含义如下：</p><p><code>sc=rs+1</code> 其实是想表达<code>sc=(resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT)+1</code>，</p><p>而<code>sc=rs+MAX_RESIZERS</code> 其实是想表达<code>sc=(resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT)+MAX_RESIZERS</code></p><p>用代码来表示其真正的写法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;</span><br><span class="line"><span class="keyword">if</span>(sc&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">if</span>(条件<span class="number">1</span>||sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以rs其实应该是这样的二进制串，显然是一个负数，这样才能使得<code>sc == rs + 1</code>在某个时刻成立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>此外，因为rs已经是负值，那么在transfer有个地方不能直接用一开始计算的rs值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">/* 大家第一次代码解析到这里时：应该会无法理解，为何不用rs，而是要用resizeStamp(n) 重新计算rs：</span></span><br><span class="line"><span class="comment">  ((sc - 2) != rs &lt;&lt; RESIZE_STAMP_SHIFT)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>因为transfer方法执行过程中，表示扩容状态下，rs的值已经是<code>rs=resizeStamp(16) &lt;&lt; RESIZE_STAMP_SHIFT</code>  ，也即rs位于sc的高16位上了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>如果使用<code>((sc - 2) != rs &lt;&lt; RESIZE_STAMP_SHIFT)</code>  来判断，rs右移16位后，就变成0，此时sc没有实际含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>因此这里不能用原来的rs值来判断条件，而是使用<code>resizeStamp(n)</code>重新计算rs值得出sc值是否等于原始基数，以此判断当前线程是否是最后一个退出扩容的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">if</span> (sc != （resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT） +<span class="number">2</span> ) <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>基于以上详实的分析，才能真正从背后移位设计的原理去理解<code>sc==rs+1</code>含义：表示当前CHM已经没有扩容线程在扩容了，也即所有扩容线程已经退出扩容任务，此时再来新的线程即可break。</p><h5 id="5-4-为何用sc-rs-1来判断所有扩容线程已经退出而不是用sc-rs-0或者sc-rs-2呢？"><a href="#5-4-为何用sc-rs-1来判断所有扩容线程已经退出而不是用sc-rs-0或者sc-rs-2呢？" class="headerlink" title="5.4 为何用sc=rs+1来判断所有扩容线程已经退出而不是用sc=rs+0或者sc=rs+2呢？"></a>5.4 为何用sc=rs+1来判断所有扩容线程已经退出而不是用sc=rs+0或者sc=rs+2呢？</h5><p>假设当前有1个线程是最后一个完成扩容的线程，它在transfer方法中准备执行以下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 假设当前线程是最后一个扩容线程并持有sc值为rs+2，然后通过cas将主存上sizeCtl设置为sc-1，也即此时主存上的sizeCtl=（rs+2）-1=rs+1。</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// ② 注意下面的sc不是主存的上值，而是线程在①持有的sc=rs+2的值，因此仅当sc-2=rs，其中rs= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 那么这个线程就是要找的最后一个扩容线程。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>以上逻辑等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程</span></span><br><span class="line"><span class="keyword">int</span> sc=getAndAddInt(<span class="keyword">this</span>,sizeCtl,-<span class="number">1</span>) <span class="comment">//先取出sizeCtl的值：rs+2，然后再将cas设置sizeCtl在主存的值为rs+1</span></span><br><span class="line"><span class="comment">//其他线程：</span></span><br><span class="line"><span class="comment">//当其他线程进入transfer方法时，读取的sc就是rs+1这个值，满足扩容完成的退出条件`sc==rs+1`</span></span><br></pre></td></tr></table></figure></p><p>因此如果当前线程最后一个完成扩容的线程，那么它执行完以上逻辑后，主存中sizeCtl的值为rs+1，因此之后的线程读取sc的值并来到以下逻辑就会发现② 位置的<code>sc == rs + 1</code>成立，说明<font color=red>“当前CHM所有扩容线程已经退出，本阶段的CHM扩容已完成，因此可直接break退出transfer”</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n); <span class="comment">// rs是正值：0000 0000 0000 0000 1000 0000 0001 1011 </span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//② 这里也有rs，是正值还是负值呢？</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><h5 id="5-5-首次扩容时sc的基础值为何不是加1而是加2？"><a href="#5-5-首次扩容时sc的基础值为何不是加1而是加2？" class="headerlink" title="5.5 首次扩容时sc的基础值为何不是加1而是加2？"></a>5.5 首次扩容时sc的基础值为何不是加1而是加2？</h5><p>刚开始解析addCount源码时，让人无法理解的为何首个扩容线程进入扩容逻辑时是加2开始而不是加1开始计算呢，有点反正常思维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">    transfer(tab, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>考察<code>sizeCtl=-1</code> 这个特殊的-1，换成有符号的二进制串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001 &#x2F;&#x2F; ①低16位的最低位为1</span><br></pre></td></tr></table></figure><p>对比容量16且从加1开始线程计数：</p><p>第1个扩容线程进入transfer时：sc=rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0001 &#x2F;&#x2F; ②低16位的最低位为1</span><br></pre></td></tr></table></figure><p>第2个扩容线程进入transfer时：sc+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0002</span><br></pre></td></tr></table></figure><p>对比①<code>sizeCtl=-1</code>和②的二进制串可知，两者低16位的最低位都是1，状态标记冲突了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx xxxx xxxx xxxx 0000 0000 0000 0001 </span><br></pre></td></tr></table></figure><p>考虑到：sc是用来扩容状态标记、sizeCtl也是用在initTable对sizeClt cas置-1的初始化标记，如果两者都取-1，就不好判断当前CHM的状态，因此Doug Lea为避免这种状态位的冲突，因此将扩容线程计数从加2开始计数。</p><p>虽然本文给出这样相对”牵强“的解释，但无法理解为何Doug Lea不在源码中给大家注释清楚？ </p><h4 id="6、sizeCtl状态小结"><a href="#6、sizeCtl状态小结" class="headerlink" title="6、sizeCtl状态小结"></a>6、sizeCtl状态小结</h4><p>有了以上第4节和第5节深入的细节分析，现在可以总结sizeCtl也即sc取不同值的实际含义</p><p><strong>sizeCtl为正值部分好理解：</strong></p><p>① sizeCtl=0，默认值，在反序列化CHM对象时，如果CHM的size为0，那么此时sizeCtl设为0</p><p>② 当new CHM阶段，sizeCtl=table的初始默认容量或者指定的容量（会被修正为2的整数幂）</p><p>③ 当CHM扩容结束后，sizeCtl=下一次扩容阈值</p><p><strong>对于负值部分的理解需要结合resizeStamp章节内容：</strong></p><p>以table容量等于16作为分析，sizeCtl主要是以下四种特殊情况的负值：</p><p>①  sizeCtl=-1。在new CHM后，第一次put入key，table为null，需要使用tab = initTable()方法初始化，多线程环境下，线程使用cas将 sizeCtl设为-1加锁做初始化工作。</p><p>② 第一个进入扩容线程将sizeCtl设为一个基础值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0010 &#x2F;&#x2F; 最高位1，所以此值为负值</span><br></pre></td></tr></table></figure><p>③ 达到最大扩容线程数量sizeCtl的值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 1111 1111 1111 1111 &#x2F;&#x2F; 最高位1，所以此值为负值</span><br></pre></td></tr></table></figure><p>也即当CHM处于并发线程扩容时，sizeCtl的取值范围为：<code>[rs+2,rs+65535]</code> </p><p>④ 所有扩容线程退出扩容时，对应sc=rs+1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0001 1011 0000 0000 0000 0001  &#x2F;&#x2F; 最高位1，所以此值为负值</span><br></pre></td></tr></table></figure><p>以上sizeCtl用于管理多线程并发操作与状态标记的背后原理。</p><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>本文研究的重点放在CHM扩容设计逻辑上，不得不说，其并发源码写的确实高级，尤其是关于sizeCtl移位计数的逻辑设计让人佩服，也值得在项目尝试应用相关并发控制思想！<br>下一篇文章将重点讨论：jdk1.8 ConcurrentHashMap的TreeBin读写锁竞争机制</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面文章中，addCount方法分为两部分：&lt;/p&gt;
&lt;p&gt;第一部分是put一个节点后，需要对size加1计数，这部分交由fullAddCount完成，它的设计和逻辑可谓精妙，非常值得在实际项目参考其代码实现。&lt;/p&gt;
&lt;p&gt;第二部分是加1计数后，需要判断是否需要对table进行扩容，扩容思想设计及其源代码实现同样非常精妙，值得多次阅读和学以致用！&lt;/p&gt;
&lt;p&gt;本文将重点深入分析CHM核心扩容逻辑：transfer、helpTransfer、以及resizeStamp。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b8f6d46f059f62cc486c59068a58e948.png&quot; alt=&quot;CHM的sc设置基数图示&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;
&lt;h4 id=&quot;1、addCount的扩容判断设计&quot;&gt;&lt;a href=&quot;#1、addCount的扩容判断设计&quot; class=&quot;headerlink&quot; title=&quot;1、addCount的扩容判断设计&quot;&gt;&lt;/a&gt;1、addCount的扩容判断设计&lt;/h4&gt;&lt;h5 id=&quot;第1个执行扩容线程&quot;&gt;&lt;a href=&quot;#第1个执行扩容线程&quot; class=&quot;headerlink&quot; title=&quot;第1个执行扩容线程&quot;&gt;&lt;/a&gt;第1个执行扩容线程&lt;/h5&gt;&lt;p&gt;本章节最精彩的地方：分析Doug Lea 如何安排“每个加入扩容任务线程对sc进行cas加1计数”、“每个结束自己扩容任务线程对sc进行减1”、以及“最后一个结束扩容线程要干些什么收尾工作”。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// putVal调用addCount(1L, binCount)，因此这里x就是1，check即binCount，对于put入一个key（key已存在,则binCount=0，新key,binCount&amp;gt;0），那么binCount自然是&amp;gt;=0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; check)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      CounterCell[] as; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; b, s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// 主分支1：完成加1计数逻辑，之前文章fullAddCount已经详细分析，本文重点讲解addCount主分支2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;comment&quot;&gt;// ......忽略部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     	&lt;span class=&quot;comment&quot;&gt;// 主分支2：当前线程检查是否需要扩容，若需要，则执行transfer扩容逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     	&lt;span class=&quot;comment&quot;&gt;// check即binCount,每次新增节点，当然要检查是否需要扩容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (check &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          Node&amp;lt;K,V&amp;gt;[] tab, nt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, sc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	&lt;span class=&quot;comment&quot;&gt;// 这里的s就是主分支1里面的 s = sumCount()，含义：完成加1计数后，统计当前CHM节点总数量s，看看s有无达到扩容阈值sizeCtl&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (s &amp;gt;= (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;)(sc = sizeCtl) &amp;amp;&amp;amp; (tab = table) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 (n = tab.length) &amp;lt; MAXIMUM_CAPACITY) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rs = resizeStamp(n); &lt;span class=&quot;comment&quot;&gt;// jdk 1.8这里的写法是一个bug，后面有指出原因。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            	&lt;span class=&quot;comment&quot;&gt;//分支2.1：sc的值为负数时，表明CHM还在扩容期，原因参考后面小节的sc、resizeStamp方法的解析&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sc &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;comment&quot;&gt;// 分支2.1.1：while循环扩容结束点，扩容结束条件有5个，(nt = nextTable) == null 以及transferIndex &amp;lt;= 0条件再看完transfer源码解析后，可以很容易理解，但前面3个条件目前理解会很困难，需要理解后面小节的sc、resizeStamp方法解析后才能准确理解其含义，也即这里先跳过这个5个条件的解释。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      sc == rs + MAX_RESIZERS || (nt = nextTable) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      transferIndex &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;comment&quot;&gt;// 分支2.1.2：第1个执行扩容线程在分支2.2将sc设置基数值后，以后每进来一个扩容线程都会对sc进行cas加1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc, sc + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      transfer(tab, nt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            	&lt;span class=&quot;comment&quot;&gt;//分支2.2：第1个执行扩容线程会执行此逻辑，将sc（sizeCtl）设为一个基础数（该数为负数），为什么设置一个负数呢？后面resizeStamp方法给出非常完整解答！没有充分积累，此处看起来将很难理解其设计意图。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SIZECTL, sc,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                           (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  transfer(tab, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              s = sumCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：jdk1.8的ConcurrentHashMap源码深入分析（一）</title>
    <link href="https://yield-bytes.github.io/2021/05/23/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://yield-bytes.github.io/2021/05/23/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9Ajdk1.8%E7%9A%84ConcurrentHashMap%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-05-22T16:00:00.000Z</published>
    <updated>2022-05-09T13:49:23.637Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>虽然jdk1.7的CHM能够解决非阻塞高并发的读写情况，但它仍然不够理想，例如写并发度受限于Segment数组初始大小，一旦创建就无法再扩容并发度；如果key非常多且分布不均匀，例如都落在同一个Segment位置上，相当于多个线程竞争同一把“全局锁”，CHM“仿佛”退化为HashTable。此外，因为CHM的Segment上使用jdk1.7的HashMap，它的性能显然没有jdk1.8的HashMap强，jdk1.7resize扩容处理时只能单线程完成扩容操作，jdk1.7计算size方法可能要对每个Segment加阻塞锁，基于以上jdk1.7的CHM缺点，Doug Lea重新设计新版本的CHM，其源代码行数总共6312行，性能确实高了，但代价是代码逻辑的复杂度要高出很多。</p><p>理解本文所有源码分析以及相关技术都需要读者已经掌握1.8/1.7HashMap、1.7 CHM、Unsafe、CAS这些进阶知识，否则难以消化相关知识，可以提前阅读本博客相关文章：</p><p>（以下“CHM”表示ConcurrentHashMap简写）</p><h4 id="数据结构图示"><a href="#数据结构图示" class="headerlink" title="数据结构图示"></a>数据结构图示</h4><p>分为普通状态下（非扩容期间）和扩容期间</p><p>（1）CHM非扩容时，也即普通正常状态下的内部数据结构图：</p><p>可以看到跟jdk1.8的HashMap数据结构不同的地方：CHM用了一个称为TreeBin的节点作为桶位头节点，不是HashMap的TreeNode:<br><img src="https://img-blog.csdnimg.cn/ef0e55b37d5744cbb7f036ca5a19c6ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）CHM正在扩容时的内部数据结构图：</p><p>  可以看到正在扩容时的内部节点结构，数组尾部的一些桶位头节点放入了ForwardingNode节点。</p><a id="more"></a><p>  <img src="https://img-blog.csdnimg.cn/6455b8ed077d45548a4901bae17c44a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>其实还有一个情况，以上两张图也没有展示出来：当CHM调用computeIfAbsent或者compute方法来插入系节点时，会在桶位上放置一个ReservationNode用于占位操作，本博客也有关于相关深度分析的文章</p><h4 id="重要成员变量说明"><a href="#重要成员变量说明" class="headerlink" title="重要成员变量说明"></a>重要成员变量说明</h4><h5 id="CHM重要常量"><a href="#CHM重要常量" class="headerlink" title="CHM重要常量"></a>CHM重要常量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"><span class="comment">// CHM数组长度最大值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHM数组初始化默认长度</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 非最大2的整次幂数组长度：最大值-8。适用于toArray及其相关方法的场合</span></span><br><span class="line"><span class="comment">   * The largest possible (non-power of two) array size.</span></span><br><span class="line"><span class="comment">   * Needed by toArray and related methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为了兼容jdk1.7版本的CHM，在这里也给出相关成员变量的</span></span><br><span class="line"><span class="comment">   * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment">   * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与1.8 HashMap一致，此处不再说明</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于本文重点讨论fullAddCount，与扩容相关的常量在扩容文章给出。</span></span><br></pre></td></tr></table></figure><h5 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   HashMap的底层数组，注意它被volatile语义修饰:让table数组符合happen-before的规则，第一次put才会被初始化，长度为2的整数幂。</span></span><br><span class="line"><span class="comment">   * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下4个字段需要结合每小节内容去理解才能掌握其设计含义</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">   * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">   * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  设计最精妙的变量之一，对它实施位运算可以实现对CHM多种操作的控制</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 理解fullAddCount方法实现后才能明白此变量的意义。Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 理解fullAddCount方法实现后才能明白此变量的意义。Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>关于spread方法、tableSizeFor方法、comparableClassFor方法、compareComparables方法可以参考jdk1.8的HashMap，本文不再赘述。</p><p>put方法最适合作为源码分析入口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;foo3&quot;</span>);</span><br></pre></td></tr></table></figure><p>put方法内部调用的是putVal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于CHM来说，put一个key到桶桶上会有以下几种情况：<br>1、table为空  2、桶位为空  3、桶位是一条冲突链 4、桶位是一个treeBin节点  5、桶位是一个<code>ForwardingNode</code>节点（表示有其他线程正在扩容） 6、桶位是一个<code>ReservationNode</code>节点：表示有其他线程正在调用computeIfAbsent或者compute方法来插入在该桶位插入节点，注意同一桶位的同一时刻，5和6是不会同时发生在，两个情况都是表达插入节点的逻辑。</p><p>因此put主体逻辑设计主要分为以下7个步骤：</p><p>1、如果tab为空，那么进行table初始化，该方法里面使用自旋+CAS让线程自己竞争初始化权</p><p>2、如果key所定位的桶位头节点f为空节点，线程使用CAS竞争将key节点插入到该桶位中</p><p>3、如果key所定位的桶位头节点hash为-1，也即表示该桶位的节点是个fwd节点，说明当前CHM正在扩容，那么当前put线程遇到这个节点会让去帮助扩容线程。</p><p>4、若不是以上1~3三种情况，那么先使用synchronized锁在该桶位，如果该桶位上一条冲突链，遍历该链插入key，如果该桶位上是一个treeBin，说明桶位已经是一棵红黑树，则按红黑树插入节点方法来插入key</p><p>5、判断key插入的链表长度是否大于等于8，来决定是否需要树化</p><p>6、将CHM的节点总数size加1（采用并发计数器累加）</p><p>7、判断节点总数是否达到扩容阈值而进行扩容</p><p>本文重点分析1-6的设计，第7点是扩容逻辑，由于扩容逻辑相对复杂、内容丰富，需要单独起一篇文章研究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">      <span class="comment">// f是key所定位的first头节点，fh：first头节点的Hash值，n:当前table数组长度，i：key定位到的桶位下标 </span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 1、如果tab为空，那么进行table初始化，initTable方法里面使用自旋+CAS让线程去竞争初始化权</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">      <span class="comment">// 2、如果key所定位的桶位头节点f为空节点，线程使用CAS竞争将key节点插入到该桶位中，如果成功插入，则退出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 3、如果key所定位的桶位头节点hash为-1，说明当前CHM正在扩容，也即表示该桶位已被其他扩容线程迁移完数据，那么当前线程要进入扩容去帮助CHM扩容，注意不是帮助此桶位扩容！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 4、若不是以上1~3三种情况，那么先使用synchronized锁在该桶位first头节点，从这里开始看出jdk1.8的CHM锁粒度比1.7要小，锁对象就是桶位本身</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">            <span class="comment">// 再次确认当前first头节点有没变更过，如果f已被改变，则回到for循环，重新按1-4流程再来一次</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            <span class="comment">// 4.1 如果当前桶位是一条冲突链表，遍历冲突链，并对binCount进行计数，如果存在key则覆盖，否则使用尾插法将key节点插入到链表尾部，此逻辑跟jdk1.8的类似</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="comment">// 对冲突链表长度进行计数，用于树化判断</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                          <span class="comment">//来到链表尾部，尾插法</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 4.2 如果当前桶位头节点是一个TreeBin节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                      <span class="comment">// 这里binCount是从2开始，解释参考本博客的ThreeBin读写锁机制分析的文章</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 判断冲突链表长度是否需要树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 5、将CHM的节数总数size加1（采用并发计数器累加）</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对jdk1.8 HashMap有深入研究的话，其实CHM的put本身设计逻辑并不难理解，而最复杂且精妙的设计反而是put方面里面的辅助方法：initTable方法、helpTransfer方法、transfer方法、addCount方法、fullAddCount方法，每一个方法无不体现JUC并发代码的精巧设计。</p><p>在前面的“CHM重要常量”，特意将以下三个变量放在此来说明它们的作用，分别代表三种节点的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;<span class="comment">// ForwardingNode（扩容期间需要用到）的哈希值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>;<span class="comment">// TreeBin节点（树化需要用到）的哈希值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>;<span class="comment">// ReservationNode节点（在computeIfAbsent、compute方法需要到）</span></span><br></pre></td></tr></table></figure><p>在put一个节点需要判断当前桶位节点类型，其中用到以下逻辑，其中只要头节点的哈希值fh&gt;=0，我们就可以认为它是一条链表（或者单节点），所以可以使用遍历方式去put入key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">// 4.1 如果当前桶位是一条冲突链表，遍历冲突链，并对binCount进行计数，如果存在key则覆盖，否则使用尾插法将key节点插入到链表尾部，此逻辑跟jdk1.8的类似</span></span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 对冲突链表长度进行计数，用于树化判断</span></span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 4.2 若头节点哈希值小于0，要么是fwd节点要么是ThreeBin节点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p>如果头节点哈希值小于0也即：-1，-2，-3，它们代表第三种类型节点，因此还需要进一步判断f节点是否为TreeBin节点，因此有</p><p><code>if (f instanceof TreeBin)</code>， 为何不设计为: <code>if(fh==TREEBIN)</code>，个人认为：</p><p>纯粹是为了源代码的可读性，因为我们put一个key到桶位前，更关心关心的是key所在桶位的“节点”是什么类型，当开发者看到<code>if (f instanceof TreeBin)</code>，自然就会理解为：如果当前桶位头节点是一个TreeBin节点。</p><p>而如果写成<code>if(fh==TREEBIN)</code>， 显然就没上面的理解来得更加“人性化、可读性高”</p><h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><p>在重要成员变量里面，有一个叫sizeCtl的东西，在这里才能很好理解的它的作用:</p><p>initTable总体设计逻辑：例如线程A使用自旋+CAS去竞争table初始化权，CAS成功，则sizeCtl值会被改为-1表示“已成功抢到锁”，其他线程看到sizeCtl=-1就不再争抢初始化权而是让出cpu时间片。线程A接着完成new table初始化操作，并将sizeCtl设为当前table的扩容阈值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="comment">// 1、如果当前线程遇到table不为空，说明已经被其他线程完成了table初始化，直接返回</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 2、如果当前线程遇到sizeCtl=-1，说明其他线程早于当前线程将sc设为-1并正在table初始化，那么当前线程只能放弃初始化权</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">    <span class="comment">// 3、当前线程成功将sizeCtl用cas改为-1，表是：“我在对table正在初始化中”，注意SIZECTL是offset内存偏移地址，区别于sizeCtl</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 当前线程CAS成功后，再次判断tab是否为空，保证“以下操作仅由当前线程来初始化”的语义</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 4、创建新table</span></span><br><span class="line">                    <span class="comment">// sc已经是-1，因此这里的n将采用DEFAULT_CAPACITY，值为16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                  <span class="comment">// 创建新的节点数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                  table = tab = nt;</span><br><span class="line">                  <span class="comment">// 计算新表扩容阈值，这里使用位计算，原理不变，还是newTable.length*0.75,</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//=&gt; n-n/4=&gt;n(1-0.25)=&gt;n*0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 保证初始化后，sizeCtl一定是新数组的扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><p>首先回想jdk1.8 HashMap的put方法：插入key后，对size自增1，如果size超过阈值则对HashMap底层table进行2倍扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么addCount方法也是类似的设计思想：</p><p>先对size加1，然后根据size节点总数判断是否需要扩容。</p><p>但这里最复杂的地方在于：多线程并发情况下，如何正确实现对size原子加1？addCount及其内部的fullAddCount方法可以完成此任务，代价是：程序设计相对复杂（设计思路十分精巧，值得在日常项目引入），设计原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/dad538c261234249972fd48d844615ae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当线程竞争不激烈情况下，通过自旋+cas对baseCount进行加1计数</p><p>当线程竞争十分激烈的情况下，有一部分线程很幸运能够抢到cas权力成功对baseCount加1，而剩下对baseCount加1cas失败的线程，它们就会创建一个CounterCells计数的数组，然后线程给对应自己的桶位Cell对象进行cas加1操作，这样一来就实现了“线程分流”，减少竞争。</p><p>最后统计总数时，将baseCount和CounterCells数组每个桶位的计数值累加起来，就是size的大小。该原理对应的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// baseCount加上每一个桶位的value，最后就是总数sum</span></span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外一个有类似功能的类，专门设计给高并发计数的场景：LongAdder类（java.util.concurrent.atomic.LongAdder），它比AtomicLong原子计数器性能更强，本博客也给出相关性能测试。</p></blockquote><p>addCount骨架代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">  <span class="comment">// 1、使用baseCount以及 CounterCell数组完成并发环境下的加1计数</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x))&#123;...&#125;</span><br><span class="line">  <span class="comment">// 2、判断CHM是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>)&#123;...&#125; </span><br></pre></td></tr></table></figure><p>完整源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用addCount(1L, binCount)，因此以下的入参x是1，check是binCount，</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      CounterCell是一个简单的内部类，它有一个value属性，用于被线程CAS加值操作</span></span><br><span class="line"><span class="comment">      static final class CounterCell &#123;</span></span><br><span class="line"><span class="comment">        volatile long value;</span></span><br><span class="line"><span class="comment">        CounterCell(long x) &#123; value = x; &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">// as:存放如上图所示的CounterCell数组的临时变量，不同线程会对其不同段进行cas加1操作</span></span><br><span class="line">        <span class="comment">// b:baseCount变量</span></span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line"> <span class="comment">// 判断条件1:若counterCells数组不是空，说明已经有其他线程创建了它，也说明此刻出现线程竞争</span></span><br><span class="line"> <span class="comment">// 判断条件2: 当前线程对baseCount进行CAS加1操作失败，说明有其他线程竞争着baseCount，也说明此刻出现线程竞争</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"><span class="comment">// a变量：CounterCell数组某个桶位（也称某个段），v变量：CounterCell计数器里面value变量，m变量：CounterCell数组长度</span></span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">   <span class="comment">// uncontended线程之间有无激烈竞争标志，true：表示线程之间竞争还不激烈，false：表示线程之间竞争很激烈</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>; </span><br><span class="line">          <span class="comment">// 注意这里4个判断条件</span></span><br><span class="line"><span class="comment">// 判断条件1：该条件执行是因为第1个if走的是判断条件2，说明多个线程在竞争cas操作baseCount，但是还没线程去创建CounterCell数组，那么当前线程可用fullAddCount完成加1操作。</span></span><br><span class="line"><span class="comment">// 判断条件2：该条件执行是因为第1个if走的是判断条件1，你想想，能调用length属性说明as是非空对象，也即as = counterCells) != null，但还未放入cell对象，此时as.length=0或者as.length-1&lt;0</span></span><br><span class="line"><span class="comment">// 判断条件3：该条件执行是因为第1个if走的是判断条件1，当前线程通过hash定位到counterCells数组对应桶位为空，说明当前线程接下来将可以在桶位上对CounterCell的value进行加1操作，将交由fullAddCount完成。</span></span><br><span class="line"><span class="comment">// 判断条件4： 当线程对它所在的桶位cas加1操作失败，说明已经有多个线程正在激烈竞争counterCells数组，接下来需要对counterCells数组扩容来分散（降低）线程竞争，将交由fullAddCount完成</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 线程定位到CounterCell数组的hash方法：ThreadLocalRandom.getProbe() &amp; m</span></span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"><span class="comment">// 多个线程同时竞争修改baseCount时，竞争失败的线程会执行fullAddCount，把x的值插入到counterCell数组对应的单元value里面。从这里也可以立即看出uncontended=false真实含义：表示当前多线程并发计数竞争激烈</span></span><br><span class="line"><span class="comment">// fullAddCount(1,uncontended=false),该方法能保证完成加1操作             </span></span><br><span class="line">                 fullAddCount(x, uncontended);</span><br><span class="line">              <span class="comment">// 如果执行流执行到这里，说明fullAddCount已经完成加1操作，可以返回。</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果check（binCount）&lt;=1,显然不需要扩容，可直接return结束</span></span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount(); <span class="comment">// 计算CHM的总节点数量，以便之后用s &gt;= (long)(sc = sizeCtl) 判断是否需要扩容</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fullAddCount方法"><a href="#fullAddCount方法" class="headerlink" title="fullAddCount方法"></a>fullAddCount方法</h4><p>在源码中,第2500行，有一片代码段称为“Counter support”，作者指出它是用于分布式计数，fullAddCount方法改编自LongAdder and Striped64</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>fullAddCount方法的设计和实现是复杂且有精妙的，主要分为三个逻辑：</p><p>1、如果CounterCell数组不为空且数组里面已经有Cell对象，说明CounterCell数组已经被其他线程完成了创建，那么当前线程自然无需再创建它，而是尝试在当前下线程对应的空桶位放入Cell(1),相当于对value加1操作（如果桶位已有Cell对象，就使用cas对其加1计数）</p><p>2、在条件1不满足情况下，此时CounterCell数组为空表示还未被创建，那么当前线程把cellsBusy状态改为1（相当于加锁），并把CounterCell数组创建好，默认长度2，创建好后顺便在对应的桶位放入Cell(1)</p><p>3、桶位Cell加1操作失败、又没抢到CounterCell数组的创建权，总不能白跑一趟，因此到了这一步当前线程顺便再尝试对baseCount加1，若cas成功就可以直接break。</p><p>以上三个分支逻辑对应以下骨架代码：主分支1、主分支2、主分支3，其中主分支1的逻辑设计是最复杂的，它包含6个次分支：1.1到1.6。</p><p>这里一定要有一个基本常识：首先，线程的每次循环，只能执行3个主分支中的其中1个。另外一个基本常识：如果线程进入到主分支1，那么在1.1到1.6总共6个次分支中，线程也只能进入其中一个分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;   <span class="comment">// 主分支1，对应以上第1点</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.1</span></span><br><span class="line">        <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">        <span class="comment">// 1.2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">          wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1.3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 1.4</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">          collide = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 1.5</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">          collide = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 1.6</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 完成CounterCell数组容量2倍扩容</span></span><br><span class="line">          collide = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;   &#125;   </span><br><span class="line">        <span class="comment">// 为当前线程生成新的hash值，用于下一次遍历，（希望它可以定位到另外一个桶位）</span></span><br><span class="line">        h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主分支2，对应以上第2点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cellsBusy==<span class="number">0</span> &amp;&amp; counterCells==as &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>))&#123;&#125;</span><br><span class="line">    <span class="comment">// 主分支3，对应以上第3点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解完整源码之前，先了解cellsBusy“锁”的设计理论，cellsBusy本身只是一个volatile变量，而cellsBusy+CAS就可以用无锁方式实现“加锁功能”，线程就是用这种“轻锁机制”去完成CounterCell数组创建、将Cell对象放入桶位、CounterCell数组扩容，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 尝试“加锁”：若为true就相当于加锁成功，但该锁机制很轻量！</span></span><br><span class="line"><span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// ② 临界区代码：完成CounterCell数组创建或者将Cell对象放入桶位或者CounterCell数组扩容</span></span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// ③ 释放“锁”</span></span><br><span class="line">     cellsBusy == <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>完整源码解析，以下for(;;)循环内部逻辑按前面提到的三个主分支进行分段解析，这是因为太多if和else if条件，需要分段解析才比较清晰其内部设计逻辑</p><h5 id="fullAddCount主分支1"><a href="#fullAddCount主分支1" class="headerlink" title="fullAddCount主分支1"></a>fullAddCount主分支1</h5><p>线程从addCount首次进入到fullAddCount时，假设先进入到分支1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// fullAddCount(x=1, uncontended=false)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h; </span><br><span class="line"> <span class="comment">// 如果当前线程hash值为0，则强制进行线程hash初始化处理，这里为何直接用Random方法呢？因为从ThreadLocalRandom字面也可以看出，这里是每个线程生成自己用的随机数，可以理解高并发下每个线程都有自己的随机数。</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// collide：表示线程定位到的Cell桶位是否有冲突，显然当CounterCell数组最后一个桶位都不空，说明已经出现线程操作数组冲突</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"> <span class="comment">// as:CounterCell数组的临时变量，a：线程定位到桶位上的Cell对象，n: CounterCell数组的长度，v：桶位上的Cell对象的value属性       </span></span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 分支1、如果CounterCell数组已经被其他线程创建，接下来当前线程尝试占据桶位来完成加1的任务</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">// 1.1 线程所在的CounterCell桶位为空，有机会将Cell对象放入到桶位上</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 1.1.2 若cellsBusy未被加锁，则当前线程先创建一个Cell对象，准备放入桶位</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// 这里的x也就入参1，表示加1</span></span><br><span class="line">      <span class="comment">// 1.1.3 线程再次检查cellsBusy未被其他线程加锁且当前线程对cellsBusy加锁成功，那么接下来当前线程就可以尝试将Cell放入桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">// 1.1.4 Cell是否创建的标识，显然程序执行到这，Cell对象还未放入桶位</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">      <span class="comment">// cellsBusy标识锁并不是用于锁CounterCell数组本身，而是数组的某个桶位，CounterCell数组此时可能被线程扩容更改过，因此需要重新检查</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">      <span class="comment">// 如果counterCells数组还是一开始的那个数组且已被创建，这时当前线程可以放心将Cell对象放入线程hash定位到对应桶位，并将创建标识created置为true</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 当前线程操作完桶位放入cell对象后，释放cellsBusy锁</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">      <span class="comment">// 上面的CounterCell(1)能放入桶位，当然线程完成加1计数任务，可直接返回</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 源代码注释：Slot is now non-empty，说明线程未能成功将Cell(1)对象放在桶位，则再次回到for循环                        </span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">      <span class="comment">//  代码执行到这里时，说明分支1.1.2 的cellsBusy被其他线程加锁，自己没抢到更改权，此时先不认为是冲突，使用新hash值 h = ThreadLocalRandom.advanceProbe(h) 回到for循环重试</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 执行流下一条语句是执行h = ThreadLocalRandom.advanceProbe(h) 然后回到for循环，而不继续执行1.2次分支，这里很容易误解。</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure><h5 id="次分支1-2的设计目的："><a href="#次分支1-2的设计目的：" class="headerlink" title="次分支1.2的设计目的："></a>次分支1.2的设计目的：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1.2  // fullAddCount(long x=1, boolean wasUncontended=false)  </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br></pre></td></tr></table></figure><p>当前线程第1次遇到CounterCell数组不为空的情况下，且线程定位到的桶位不是空，并不急着安排线程对桶位上Cell对象进行cas加1计数。由于addCount方法调用fullAddCount入参wasUncontended时被设为false，因此线程会进入分支1.2，此时wasUncontended设为true表示当前线程暂时还没有遇到竞争，更新hash值（<code>h = ThreadLocalRandom.advanceProbe(h)</code>），再直接回到for进行第2次遍历重试。</p><font color=red>如果第2次遍历时，线程所定位的桶位又不为空，由于wasUncontended是true,因此会跳过次分支1.2，来到分支1.3：既然第2次定位到桶位又是不空，那么可以尝试去对桶位上Cell对象直接cas加1操作</font><blockquote><p>这里为何设计2次遍历？ 因为CounterCell首次被创建时容量为2，也即有<code>rs[0]</code>,<code>rs[1]</code>两个空桶位，假设线程第1次定位到<code>rs[0]</code>不为空（此时不能认为存在线程竞争导致的，只是<code>rs[0]</code>里面已经有Cell对象，这也是wasUncontende设为true的原因）接下来当然是再换线程的hash看看能不能定位到rs[1]桶位，如果恰好定位到rsp[1]是空桶位，那么线程就可以放入Cell对象。如果2次重试线程定位到的桶位都不为空，线程第3次遍历重试就会进入下文的次分支1.3（当然换完hash值也有可能又定位到rs[0]桶位）</p></blockquote><h5 id="次分支1-3的设计目的："><a href="#次分支1-3的设计目的：" class="headerlink" title="次分支1.3的设计目的："></a>次分支1.3的设计目的：</h5><p>如果第2次遍历时，线程所定位的桶位又不为空，由于wasUncontended是true，因此会跳过次分支1.2，尝试去对桶位上Cell对象直接cas加1操作，如果加1成功，线程就可以退出for循环了，如果失败就来到次分支1.4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.3</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h5 id="次分支1-5以及1-6的设计目的："><a href="#次分支1-5以及1-6的设计目的：" class="headerlink" title="次分支1.5以及1.6的设计目的："></a>次分支1.5以及1.6的设计目的：</h5><p>不妨先考察次分支1.4两个条件都不成立时的执行流：</p><p>这时线程就会跳过分支1.4去执行次分支1.5（因为collide默认为false，此时线程会进入分支1.5），将collide设为true，更新hash值，再直接回到for进行第3次遍历：</p><font color=green>**实际含义为：我（当前线程）第1次循环定位桶位不为空，第2次循环定位桶位也不为空，且对桶位上Cell对象cas加1失败，说明出现了明显线程竞争，那么第3次循环重试我就选择去扩容CounterCell数组**</font><font color=red>此时线程进行第3次循环时，因为collide已经在上一轮设为true，所以线程在第3次重试时会跳过次分支1.5，来到次分支1.6代码区，此时线程会将CounterCell数组做2倍扩容，然后将collide设为false，表示：既然都扩容了，说明有新空桶位可供操作，线程间的冲突得以解决，当前线程只需直接continue回到for重试，也即源码注释提到的： Retry with expanded table</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 1.4</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">            collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"><span class="comment">// 1.5</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">            collide = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 1.6 占有cellsBusy锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                    <span class="comment">// 两倍扩容</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                        rs[i] = as[i];</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 冲突得以解决</span></span><br><span class="line">            collide = <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 扩容后肯定有空桶位，当然可直接回到for循环重试 </span></span><br><span class="line">          <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="次分支1-4的设计目的（最难理解的次分支）"><a href="#次分支1-4的设计目的（最难理解的次分支）" class="headerlink" title="次分支1.4的设计目的（最难理解的次分支）"></a>次分支1.4的设计目的（最难理解的次分支）</h5><p>该分支必须结合分支1.5和分支1.6的设计意义来理解：</p><p>分支1.6说明：线程一旦遇到明显的冲突，也即多次for循环定位到桶位不为空且对非空桶位的Cell对象cas加1失败（collide=true），那它会执行分支1.6逻辑：对CounterCell数组进行2倍扩容。那么会不会出现这样的情况：<font color=red>如果不断有后续更多线程也遭遇“冲突”，那么就有线程会无休止对CounterCell数组进行2倍扩容，有无停止扩容的条件</font>？</p><p>当然是有的，这就是次分支1.4的设计目的：防止CounterCell数组无限被扩容，如何实现？</p><p>次分支1.4有2个判断条件：</p><p>先看条件2：n &gt;= NCPU，也即CounterCell数组长度达到cpu个数时，就将collide 改为false，更新hash值，再直接回到for重试</p><p>而分支1.5、1.6逻辑都被会跳过不执行，下一次循环如果又来到分支1.4，因为n &gt;= NCPU成立，所以分支1.5、1.6逻辑再次被跳过不执行，之后的循环也类似处理。</p><p>所以：CounterCell数组停止的条件是，只要它的长度达到cpu个数，当前线程就不会再执行次分支1.6扩容的代码，而是从分支1.4将collide改为false，然后直接回到for循环、</p><h5 id="当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢"><a href="#当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢" class="headerlink" title="当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢"></a><font color=red>当CounterCell数组不再扩容时，这些线程该如何执行多个分支代码呢</font></h5><p>显然，当CounterCell数组不再扩容时，那么空桶位很快会被线程们放满Cell对象，也即CounterCell数组数组没有空桶位，之后线程是这么执行的：</p><p>次分支1.1 <code>if ((a = as[(n - 1) &amp; h]) == null)</code>不再成立，所以会跳到次分支1.2，由于wasUncontended早已被设为true（请回去看次分支1.2的设计目的），次分支1.2也会被跳过，线程继续来到次分支1.3，此时线程会使用cas对Cell对象加1操作，若加成功就可以break，否则就来到次分支1.4，因为n=&gt;NCPU一直为true，将collide改为false，更新hash值，再直接回到for重试。</p><p><font color=red>简单总结：当CounterCell数组不再扩容时，且没有空桶位时，这些更新线程其实就会简化成以下的执行逻辑</font>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">// 当前线程使用cas对Cell对象加1操作，加成功就结束循环！，否则更新hash值重试</span></span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 更新当前线程hash值，以便下一次重试能够定位不同于本次的桶位</span></span><br><span class="line">        h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上简化代码可以看出，线程一定能在某个时刻在对应桶位的Cell对象上加1成功，然后退出循环，这也是fullAddCOunt设计真实目的：保证每个线程进入到fullAddCount到离开fullAddCount之前一定能够cas加1成功</p><p>此时，我们再来考察次分支1.4的条件1：</p><p>有了条件2的铺垫，其他条件1很好理解：counterCells != as，表明恰好有其他线程正在扩容CounterCell数组（导致as指向新的CounterCells数组对象），接下来可能在扩容后的CounterCell数组有更多的空桶位，那么当前线程就没必要去竞争扩容了，只需将collide 改为false，更新自己hash值，然后直接回到for循环重试看看能否运气好拿到新的空桶位。</p><h5 id="fullAddCount主分支2："><a href="#fullAddCount主分支2：" class="headerlink" title="fullAddCount主分支2："></a>fullAddCount主分支2：</h5><p>若CounterCell数组为空时（还未被创建），也即fullAddCount的主分支1会被跳过，当前线程会进入主分支2代码区，那么当前线程把cellsBusy状态改为1（相当于加锁），创建好一个默认长度为2的CounterCell数组，并顺便在对应的桶位放入Cell(1)完成加1计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">           U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line"><span class="comment">// 再次确认counterCells数组没有被其他线程改动过，如果被改动过，那么就跳过初始化并释放cellsBusy“锁”</span></span><br><span class="line">          <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line"><span class="comment">//  CounterCell数组就是在这里首次被创建</span></span><br><span class="line">              CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// h&amp;1结果：要么0要么1，也即将Cell(1)对象放在两个空桶位rs[0]、rs[1]中的任一个</span></span><br><span class="line">              rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">              counterCells = rs;</span><br><span class="line">              init = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 既然当前线程已经完成创建CounterCell数组，当然可以释放cellsBusy锁</span></span><br><span class="line">          cellsBusy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//当前线程完成CounterCell数组初始化后，因为在创建期间就完成Cell(1)加1计数，故可直接break退出。</span></span><br><span class="line">      <span class="keyword">if</span> (init)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="fullAddCount主分支3："><a href="#fullAddCount主分支3：" class="headerlink" title="fullAddCount主分支3："></a>fullAddCount主分支3：</h5><p> 主分支3：线程执行fullAddCount的主分支1桶位Cell加1操作失败，接着执行fullAddCount主分支2时又没抢到CounterCell数组的创建权，</p><p>那么当前线程总不能白跑一趟，因此到了这一步当前线程顺便尝试对baseCount做加加1计数（或者加x计数，x代表正负数都可以），若成功就退出，失败就回到for循环重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：从三个主分支的设计来看，主分支1无疑是最复杂的，因为判断多，条件多，理解起来象比较绕，需要用全局、逆向思维去分析，最好是先找到一个容易理解的分支，然后根据这个分支的实际含义来顺藤摸瓜再找到其他分支的实际含义</p><h5 id="从for循环退出的条件也可理解fullAddCount的内在设计逻辑"><a href="#从for循环退出的条件也可理解fullAddCount的内在设计逻辑" class="headerlink" title="从for循环退出的条件也可理解fullAddCount的内在设计逻辑"></a>从for循环退出的条件也可理解fullAddCount的内在设计逻辑</h5><p>有以上详细的源码解释后，考察线程for自旋退出的条件（成功计数加1的条件），其实就是对应前面提到的3个主分支。</p><p>1、第2552行，主分支1-次分支1.1，当前线程对应的桶位为null然后成功放入Cell对象时可退出for自旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (created)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>2、第2561行，主分支1-次分支1.3，进入CounterCell数组的操作逻辑，当前线程对非空桶位的Cell对象，使用CAS加1成功时可退出for自旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>3、第2597行，主分支2：当前线程创建默认长度2的CounterCell数组并选其中一个桶位放入Cell对象后可退出for自旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>4、第2600行，主分支3：当前线程以上尝试三种逻辑都失败时，总不能白跑一趟，再尝试去CAS对baseCount加1，成功时可退出for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">    <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br></pre></td></tr></table></figure><p>关于addcount完成计数加1后的CHM扩容逻辑分析，则单独在另外一篇博客给出，因为它的设计相对复杂，需要分析的内容较多。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;虽然jdk1.7的CHM能够解决非阻塞高并发的读写情况，但它仍然不够理想，例如写并发度受限于Segment数组初始大小，一旦创建就无法再扩容并发度；如果key非常多且分布不均匀，例如都落在同一个Segment位置上，相当于多个线程竞争同一把“全局锁”，CHM“仿佛”退化为HashTable。此外，因为CHM的Segment上使用jdk1.7的HashMap，它的性能显然没有jdk1.8的HashMap强，jdk1.7resize扩容处理时只能单线程完成扩容操作，jdk1.7计算size方法可能要对每个Segment加阻塞锁，基于以上jdk1.7的CHM缺点，Doug Lea重新设计新版本的CHM，其源代码行数总共6312行，性能确实高了，但代价是代码逻辑的复杂度要高出很多。&lt;/p&gt;
&lt;p&gt;理解本文所有源码分析以及相关技术都需要读者已经掌握1.8/1.7HashMap、1.7 CHM、Unsafe、CAS这些进阶知识，否则难以消化相关知识，可以提前阅读本博客相关文章：&lt;/p&gt;
&lt;p&gt;（以下“CHM”表示ConcurrentHashMap简写）&lt;/p&gt;
&lt;h4 id=&quot;数据结构图示&quot;&gt;&lt;a href=&quot;#数据结构图示&quot; class=&quot;headerlink&quot; title=&quot;数据结构图示&quot;&gt;&lt;/a&gt;数据结构图示&lt;/h4&gt;&lt;p&gt;分为普通状态下（非扩容期间）和扩容期间&lt;/p&gt;
&lt;p&gt;（1）CHM非扩容时，也即普通正常状态下的内部数据结构图：&lt;/p&gt;
&lt;p&gt;可以看到跟jdk1.8的HashMap数据结构不同的地方：CHM用了一个称为TreeBin的节点作为桶位头节点，不是HashMap的TreeNode:&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/ef0e55b37d5744cbb7f036ca5a19c6ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;（2）CHM正在扩容时的内部数据结构图：&lt;/p&gt;
&lt;p&gt;  可以看到正在扩容时的内部节点结构，数组尾部的一些桶位头节点放入了ForwardingNode节点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：AQS核心源代码实现之共享模式的深入解析</title>
    <link href="https://yield-bytes.github.io/2021/05/16/AQS%E6%A0%B8%E5%BF%83%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/05/16/AQS%E6%A0%B8%E5%BF%83%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</id>
    <published>2021-05-15T16:00:00.000Z</published>
    <updated>2022-05-10T03:19:25.678Z</updated>
    
    <content type="html"><![CDATA[<p>信号量是典型的共享模式：</p><p>何为共享模式：同一时间可以有多个线程同时持有锁资源，强调的是线程并行概念。</p><p>独占模式：同一时间只能有一个线程持有锁资源</p><h4 id="1、Semaphore信号量说明"><a href="#1、Semaphore信号量说明" class="headerlink" title="1、Semaphore信号量说明"></a>1、Semaphore信号量说明</h4><p>底层实现原理：使用AQS同步状态的state来保存信号量的当前计数。<code>release(1)</code>表示线程释放了1个锁资源，对应的state值加1，<code>acquire(1)</code>表示线程消耗1个数量的锁资源，对应的state值减1。一般用于限制线程并发工作数量。</p><h4 id="2、Semaphore使用acquire-的小demo"><a href="#2、Semaphore使用acquire-的小demo" class="headerlink" title="2、Semaphore使用acquire()的小demo"></a>2、Semaphore使用acquire()的小demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        List&lt;Thread&gt;  threadList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;已拿到锁资源&quot;</span>);</span><br><span class="line">                     Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threadList) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threadList) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以观察到结果：5个线程能够同时成功抢到锁资源并执行了5秒，后面5个线程因为已经没有可用资源，只能等待前面5个线程运行结束后才能继续。</p><p>注意Semaphore在初始化的构造器也是可以指定公平模式和非公平模式，以下将以默认的公平模式去讨论AQS是如何支撑Semaphore的工作过程</p><h4 id="3、Semaphore获取锁资源acquire的工作流程"><a href="#3、Semaphore获取锁资源acquire的工作流程" class="headerlink" title="3、Semaphore获取锁资源acquire的工作流程"></a>3、Semaphore获取锁资源acquire的工作流程</h4><a id="more"></a><p>构造器默认使用非公平模式，指定最大可用资源数（也可以称为可用信号量、许可证permits、最大可用锁资源等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实Semaphore类也是跟ReentrantLock设计如出一辙，内部定义了AQS的子类Sync类，并分别定义非公平模式实现类<code>NonfairSync</code>和公平模式的实现类<code>FairSync</code>。</p><p>流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ① 用户代码：</span></span><br><span class="line">        Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">10</span>); <span class="comment">// 默认非公平模式</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ② Semaphore 内部的acquire方法其实调用的是可立即响应中断的获取锁资源方法：acquireSharedInterruptibly</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// ③ AQS定义的acquireSharedInterruptibly方法：在共享模式下获取锁资源，如果当前正在抢锁资源的线程被外界中断，则该线程会马上抛出中断异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 这里通过读取线程自己的中断标记来判断释放需要响应外界中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      <span class="comment">// 如果没有外界中断当前线程，且当前线程使用子类的tryAcquireShared具体逻辑去尝试获取锁资源时，已无剩余量，则进入排队逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//④ 上面的tryAcquireShared(arg)显然就是Semaphore子类Sync要实现的模板方法，也即NonfairSync的tryAcquireShared方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NonFair version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//⑤ 来自Semaphore子类Sync的非公平方式抢占共享锁资源</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">// 非公平性是指：所有新来的线程都通过自旋去竞争锁资源</span></span><br><span class="line">                <span class="keyword">int</span> available = getState(); <span class="comment">// 可以看到，state的值表示当前可用资源数</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires; <span class="comment">// 剩余量=当前可用数量-请求量</span></span><br><span class="line">              <span class="comment">// 使用CAS更新扣减之后的剩余量，将剩余量返回给外面调用方，例如`tryAcquireShared`方法</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || </span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ⑥</span></span><br><span class="line"><span class="comment">如果tryAcquireShared没有可用资源量，则线程可能会放入阻塞队列里面，具体由AQS里面的doAcquireSharedInterruptibly方法实现</span></span><br><span class="line"><span class="comment">    if (tryAcquireShared(arg) &lt; 0)</span></span><br><span class="line"><span class="comment">        doAcquireSharedInterruptibly(arg);        </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// AQS的可响应中断的共享模式获取锁资源方法，注意区别于doAcquireShared</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// new一个有共享标记的节点，将其添加到阻塞队列的队尾</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 以下的设计流程其实跟独占模式的acquireQueued类似：当前线程节点node进入队尾后，立即检查它的前驱节点p，若p是head节点，说明node是阻塞队列的第一个线程节点，则可以再利用tryAcquireShared去尝试请求可用资源。这种设计就是所谓的“fast try,failed acquire then do enq”</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// ① 前驱节点是头节点，则可以进入尝试获取资源逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                  <span class="comment">// 这里还是使用Semaphore内部的NonfairSync的tryAcquireShared方法实现</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                     <span class="comment">/* ② 如果剩余的可用资源&gt;=0，那么将node设为head，并且将唤醒动作传播到下一个线程节点上。这里要重点解释为何共享模式下不能用setHead，而是需要使用setHeadAndPropagate(node, r)：</span></span><br><span class="line"><span class="comment">                     例如有10个线程，5个可用资源，假设前面5个线程抢用完资源后，第6到10个线程将进入阻塞队列并在等待中，在某一刻，前面5个线程同时释放资源，那么第6个线程唤醒后使用r = tryAcquireShared(arg)就会剩下4个可用资源，意味着第7、8、9、10这四个在阻塞队列的线程根本无需再等待，外面已经有4个资源够他们抢用了(除非此时外界又来了新线程直接跟7到10号线程竞争资源)，因此需要在第6个线程唤醒获得资源后，马上将唤醒动作传播给第7个线程（第7个线程传播给第8个线程，类似多米诺骨牌效益），这就是共享模式为何采用Propagating wake up——将唤醒动作传播持续下去的设计思路</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r); <span class="comment">// 获取到锁资源的第6号线程可以出队，同时将第7号线程唤醒，完成“唤醒传播”操作</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//③ 说明线程节点不是第一个线程节点，阻塞自己，避免浪费cpu时间片，这一点设计跟acquireQueued是一致的。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                  <span class="comment">// ④在进入对尾阻塞自己后，parkAndCheckInterrupt()唤醒后，若发现自己阻塞期间被外界中断过，那么就通过抛出中断异常来响应“外界的中断请求”，try捕获到此异常后进入finally的“取消排队处理”</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//⑤ 既然当前线程唤醒后，发现自己阻塞期间被外界中断过，那么线程取消排队，不再和阻塞队列里面的线程竞争共享锁资源</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4、doAcquireShared"><a href="#4、doAcquireShared" class="headerlink" title="4、doAcquireShared"></a>4、doAcquireShared</h4><p>注意其源码解释：Acquires in shared uninterruptible mode，强调了该方法是不响应中断的，而上面的<code>doAcquireSharedInterruptibly</code> 能响应外界设置中断标志且会抛出中断异常。</p><p><code>doAcquireShared</code>在什么情况下会被调用呢？</p><p>用户层代码使用<code>semaphore.acquireUninterruptibly()</code>请求锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Semaphore</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireShared(arg); <span class="comment">// 此处可以看到semaphore.acquireUninterruptibly()底层调用的是不响应中断的doAcquireShared</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以下是doAcquireShared的设计解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// ① 假设node的前驱节点还不是head节点，则进入④流程，等到该node唤醒后重新来到①且此时p==head</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC </span></span><br><span class="line">                    <span class="comment">// ③ 接④的interrupted = true的标志后，唤醒的线程将外界中断信号在这里补充了一个自我中断，注意：别错误认为此时线程就是抛出异常，doAcquireShared是被设计为“获取锁资源的过程中都不会响应中断处理”</span></span><br><span class="line">                  <span class="comment">// 如果线程是被unpark正常唤醒正常唤醒，那么就会跳过以下if的selfInterrupt()逻辑。</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                  <span class="comment">// 虽然补充了自我中断标志，但是线程已经成功获得锁资源，因此不是“failed”，可直接返回。</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// ④</span></span><br><span class="line">            <span class="comment">// 说明线程节点不是第一个线程节点，那么入队后，阻塞自己，避免浪费cpu时间片。</span></span><br><span class="line">          <span class="comment">// shouldParkAfterFailedAcquire(p, node) 主要负责将node的前驱节点waitStatus改为SIGNAL，parkAndCheckInterrupt()主要负责阻塞线程并且在线程唤醒后，返回该线程有被中断的标志</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;  <span class="comment">// 这里指明了线程节点使用doAcquireShared成功获取锁资源前，是不会抛出中断异常的。当线程节点被唤醒时，对于被唤醒的情况有两种：一种是使用unpark正常唤醒，一种是被外界线程使用interrupt()中断，对于后面这种中断情况，当前唤醒线程并不会马上响应它（并将interrupted标志设为ture），而是继续后面的流程：在下一轮自旋将回到①处，如果p==head成立，则尝试获取锁资源，如果剩余的可用资源&gt;=0,那么就会进入②位置，然后在③位置去处理“外界的中断信号”</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果线程节点node请求可用资源出现其他异常（显然不会是中断异常），则取消该线程节点排队，这一点设计跟acquireQueued是一致的。</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、setHeadAndPropagate"><a href="#5、setHeadAndPropagate" class="headerlink" title="5、setHeadAndPropagate"></a>5、setHeadAndPropagate</h4><p><code>setHeadAndPropagate</code>方法是共享模式获取锁资源的的一个核心设计，需要独立再给出详细分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">因为阻塞队列第一个线程节点使用 tryAcquireShared获取可用资源后，剩余量r&gt;=0,因此它可以出队，并且检查后驱节点是否以共享模式等待，如果是那么只要满足剩余量大于0或者后驱节点的PROPAGATE已经设置，那么就要讲唤醒动作传播下去，也即调用doReleaseShared来实现唤醒动作接力。注意到Doug lea有提到该方法会引起不必要的唤醒动作。                 </span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below 保留旧头节点，用于之后检查</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里设计很机智：</span></span><br><span class="line"><span class="comment">      条件① 如果可用资源量propagate&gt;0,当然可以和后驱节点（如果存在）说：你们可以醒来啦，state这边还有资源可以抢占</span></span><br><span class="line"><span class="comment">      条件②条件③是联合设计：如果旧头节点不为null那么就可以判断h.waitStatus头结点同步状态值，如果&lt;0,说明waitStatus可能是SIGNAL或者PROPAGATE，故考虑唤醒传播逻辑</span></span><br><span class="line"><span class="comment">      条件④：其实条件④就是Doug Lea经常用的一个trick写法，对于高并发场景下，可以在判断条件里面进行双重检查，也即前一刻读取一次，在后一刻马上读取一次</span></span><br><span class="line"><span class="comment">        在这里，直接在条件里面重新读取新的阻塞队列头节点，如果为不空，就会跟前一刻的条件②条件③联合起来的逻辑一样。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next; <span class="comment">// 取出第一个线程节点的后驱节点，它可能null也可能是一个正在等待的线程节点</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            唤醒后继共享节点</span></span><br><span class="line"><span class="comment">            ① s后驱节点为null，为何还要将唤醒动作接力下去？ 这是因为虽然上一课刻读取node.next为null，但是在下一刻如果恰好有新的线程节点入队，那么此时doReleaseShared就可以派上用场，但如果下一刻还是没有新线程入队，那么doReleaseShared也会被调用，这就是注释提到的“may cause unnecessary wake-ups”，也即引起不必要的唤醒调用。</span></span><br><span class="line"><span class="comment">            ② 若s不为null，恰好保证第二个条件s.isShared()不会发生空指针异常且可以只要s.isShared()为true，说明后驱节点是共享模式，需要被唤醒去抢锁资源的。</span></span><br><span class="line"><span class="comment">            这里之所以加入判断后驱节点s是共享模式节点的前提下才能执行唤醒操作，是因为在ReentrantReadWriteLock的读写锁同步器设计内部的阻塞队列中可能同时存在读线程节点（共享模式，需要继续被唤醒）和写线程节点（独占模式），而对于Semaphore同步器，只有s.isShared()为true才会将唤醒动作接力下去，否则说明此s节点是独占模式的节点（或者说此时用户使用的是ReentrantReadWriteLock同步器场景），不需要执行唤醒传播逻辑。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())  <span class="comment">// 如果s不是null且s.isShared()不是true,说明当前使用setHeadAndPropagate是ReentrantReadWriteLock使用场景，那么此时该节点是一个写节点，不需要传播唤醒，因为这个写线程会等之前那个获得独占锁的写线程去唤醒。</span></span><br><span class="line"><span class="comment">// 当然这部分内容最好有了ReentrantReadWriteLock设计原理的基础后再来理解则更容易明白。              </span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、doReleaseShared"><a href="#6、doReleaseShared" class="headerlink" title="6、doReleaseShared()"></a>6、doReleaseShared()</h4><p>正如注释里面的说明：signals successor and ensures propagation，通知后驱节点以及保证唤醒传播（接力）下去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment"> * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment"> * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 由于在ReentrantReadWriteLock的阻塞队列里面可能同时存在独占模式的线程节点和共享模式的线程节点，因此该唤醒方法分为两种情况：如果遇到阻塞队列第一个线程节点是需要唤醒的</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 注意到这里用到自旋，确保唤醒动作能够传播到下一个节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">// 只要阻塞队列不是空链表（至少存在一个线程节点）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// ① 共享模式下，阻塞队列里面的线程节点的前驱节点waitStatus都会被设置SIGNAL，因此可以到这里如果直到head的ws是SIGNAL，就可以进行唤醒操作</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">              <span class="comment">// 确保能将头节点从SIGNAL改为0才能进行唤醒后驱节点的操作</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ② 如果此时头节点ws是0，就将其设为PROPAGATE，以保证唤醒操作能够传播到下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果头节点已经被更新（也即inconsistent read），只能回到for循环继续重试</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、Semaphore的释放资源release"><a href="#7、Semaphore的释放资源release" class="headerlink" title="7、Semaphore的释放资源release()"></a>7、Semaphore的释放资源release()</h4><p>release的逻辑相对简单，这里不再过多说明。对比<code>doAcquireShared</code>方法，原来共享模式的同步器，不仅在释放资源时要求去唤醒阻塞队列的节点，被唤醒的线程节点在请求资源后，也要将唤醒操作传播下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 用户代码</span></span><br><span class="line">        semaphore.release();</span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 在成功是否锁资源后，底层是调用AQS的doReleaseShared唤醒阻塞队列的首个等待的线程节点，tryReleaseShared(arg)是模板方法     </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Semaphore内部tryReleaseShared实现逻辑，对state进行CAS累加</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current=getState();</span><br><span class="line">                <span class="keyword">int</span> next=current+releases;</span><br><span class="line">                <span class="keyword">if</span> (next&lt;current)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current,next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果释放资源成功，也即state值加1（假设每次请求1个资源），那么进入AQS的共享模式下的唤醒操作：</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br></pre></td></tr></table></figure><p>其实释放资源的<code>release()</code>方法内部的<code>doReleaseShared</code>的唤醒设计在CountDownLatch的countDown里面也是同样的设计。</p><h4 id="8、共享模式下的公平模式"><a href="#8、共享模式下的公平模式" class="headerlink" title="8、共享模式下的公平模式"></a>8、共享模式下的公平模式</h4><p>此设计相对简单，和ReentrantLock的公平模式如出一辙，通过<code>hasQueuedPredecessors()</code>判断阻塞队列是否有正在排队的线程节点，如果有，那么只能乖乖的入队：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;信号量是典型的共享模式：&lt;/p&gt;
&lt;p&gt;何为共享模式：同一时间可以有多个线程同时持有锁资源，强调的是线程并行概念。&lt;/p&gt;
&lt;p&gt;独占模式：同一时间只能有一个线程持有锁资源&lt;/p&gt;
&lt;h4 id=&quot;1、Semaphore信号量说明&quot;&gt;&lt;a href=&quot;#1、Semaphore信号量说明&quot; class=&quot;headerlink&quot; title=&quot;1、Semaphore信号量说明&quot;&gt;&lt;/a&gt;1、Semaphore信号量说明&lt;/h4&gt;&lt;p&gt;底层实现原理：使用AQS同步状态的state来保存信号量的当前计数。&lt;code&gt;release(1)&lt;/code&gt;表示线程释放了1个锁资源，对应的state值加1，&lt;code&gt;acquire(1)&lt;/code&gt;表示线程消耗1个数量的锁资源，对应的state值减1。一般用于限制线程并发工作数量。&lt;/p&gt;
&lt;h4 id=&quot;2、Semaphore使用acquire-的小demo&quot;&gt;&lt;a href=&quot;#2、Semaphore使用acquire-的小demo&quot; class=&quot;headerlink&quot; title=&quot;2、Semaphore使用acquire()的小demo&quot;&gt;&lt;/a&gt;2、Semaphore使用acquire()的小demo&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SemaphoreDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Semaphore semaphore = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Thread&amp;gt;  threadList=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread t= &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(()-&amp;gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    semaphore.acquire();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;线程&amp;quot;&lt;/span&gt; + Thread.currentThread().getId() + &lt;span class=&quot;string&quot;&gt;&amp;quot;已拿到锁资源&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     Thread.sleep(&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    semaphore.release();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threadList.add(t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Thread t : threadList) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Thread t : threadList) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t.join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以观察到结果：5个线程能够同时成功抢到锁资源并执行了5秒，后面5个线程因为已经没有可用资源，只能等待前面5个线程运行结束后才能继续。&lt;/p&gt;
&lt;p&gt;注意Semaphore在初始化的构造器也是可以指定公平模式和非公平模式，以下将以默认的公平模式去讨论AQS是如何支撑Semaphore的工作过程&lt;/p&gt;
&lt;h4 id=&quot;3、Semaphore获取锁资源acquire的工作流程&quot;&gt;&lt;a href=&quot;#3、Semaphore获取锁资源acquire的工作流程&quot; class=&quot;headerlink&quot; title=&quot;3、Semaphore获取锁资源acquire的工作流程&quot;&gt;&lt;/a&gt;3、Semaphore获取锁资源acquire的工作流程&lt;/h4&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：Unsafe类实现的JUC框架free-lock设计原理讨论</title>
    <link href="https://yield-bytes.github.io/2021/05/09/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9AUnsafe%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84JUC%E6%A1%86%E6%9E%B6free-lock%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%AE%A8%E8%AE%BA/"/>
    <id>https://yield-bytes.github.io/2021/05/09/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9AUnsafe%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84JUC%E6%A1%86%E6%9E%B6free-lock%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%AE%A8%E8%AE%BA/</id>
    <published>2021-05-08T16:00:00.000Z</published>
    <updated>2022-05-09T13:49:07.482Z</updated>
    
    <content type="html"><![CDATA[<p>Unsafe类在整套JUC框架中绝对是核心的一个概念，它是实现free-lock的底层核心设计，它内部直接调用的是Java的JNI，只有理解它的CAS原子操作的内部设计原理，才能更加深入理解JUC的free-lock设计。</p><h4 id="使用unsafe操作数组"><a href="#使用unsafe操作数组" class="headerlink" title="使用unsafe操作数组"></a>使用unsafe操作数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashmap.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe)field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] intArr1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] intArr2=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// byte类型数组内存每个&quot;单元格&quot;容量是1个字节，对应Scale就是1</span></span><br><span class="line">        <span class="keyword">int</span> byteScale=unsafe.arrayIndexScale(<span class="keyword">byte</span>[].class);</span><br><span class="line">        <span class="comment">// short类型数组内存每个&quot;单元格&quot;容量是2个字节，对应Scale就是2</span></span><br><span class="line">        <span class="keyword">int</span> shortScale=unsafe.arrayIndexScale(<span class="keyword">short</span>[].class);</span><br><span class="line">        <span class="comment">// int类型数组内存每个&quot;单元格&quot;容量是4个字节，对应Scale就是4</span></span><br><span class="line">        <span class="keyword">int</span> intScale=unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="comment">// long类型数组内存每个&quot;单元格&quot;容量是8个字节，对应Scale就是8</span></span><br><span class="line">        <span class="keyword">int</span> longScale=unsafe.arrayIndexScale(<span class="keyword">long</span>[].class);</span><br><span class="line">        <span class="comment">// Integer类型数组内存每个&quot;单元格&quot;容量是4个字节，对应Scale就是4</span></span><br><span class="line">        <span class="keyword">int</span> integerScale=unsafe.arrayIndexScale(Integer[].class);</span><br><span class="line">        <span class="comment">// String类型数组内存每个&quot;单元格&quot;容量是4个字节，对应Scale就是4</span></span><br><span class="line">        <span class="keyword">int</span> stringScale=unsafe.arrayIndexScale(String[].class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> b=intArr1.getClass().equals(intArr2.getClass()) &amp;&amp; <span class="keyword">int</span>[].class.equals(intArr1.getClass()) &amp;&amp; <span class="keyword">int</span>[].class.equals(intArr2.getClass());</span><br><span class="line">        System.out.println(b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// intArr1数组实例和intArr2的数组实例都是同一对象，指向int[]</span></span><br><span class="line">        System.out.println(intArr1.getClass().equals(intArr2.getClass()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前intArr1数组实例的相对基址</span></span><br><span class="line">        <span class="keyword">long</span> baseOffset1=unsafe.arrayBaseOffset(intArr1.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(baseOffset1); <span class="comment">// 16</span></span><br><span class="line">        <span class="comment">// 获取当前intArr2数组实例的相对基址</span></span><br><span class="line">        <span class="keyword">long</span> baseOffset2=unsafe.arrayBaseOffset(intArr2.getClass());</span><br><span class="line">        System.out.println(baseOffset2); <span class="comment">// 16</span></span><br><span class="line">        <span class="comment">// 从baseOffset1和baseOffset2的值都是16可以看出，这是他们指向对象的相对基址，而不是指向对象绝对地址（如果是执行对象绝对地址，那么这里两个值一定不同）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1)); <span class="comment">//打印intArr1第1个（首地址）对应的元素，也就是intArr1[0]</span></span><br><span class="line">        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale)); <span class="comment">//打印intArr1的第2个元素，也就是intArr1[1]</span></span><br><span class="line">        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale* <span class="number">2L</span>)); <span class="comment">//打印intArr1的第3个元素，也就是intArr1[2]</span></span><br><span class="line">        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale* <span class="number">3L</span>)); <span class="comment">//打印intArr1的第4个元素，也就是intArr1[3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取intArr2的数据的第3个元素</span></span><br><span class="line">        System.out.println(unsafe.getIntVolatile(intArr2,baseOffset2+intScale* <span class="number">2L</span>)); <span class="comment">//打印intArr2第3个对应的元素，也就是intArr2[2]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="使用Unsafe操作自定义类（非并发条件下）"><a href="#使用Unsafe操作自定义类（非并发条件下）" class="headerlink" title="使用Unsafe操作自定义类（非并发条件下）"></a>使用Unsafe操作自定义类（非并发条件下）</h4><p>以下定义个三个类及其属性，可以清楚看到unsafe操作对象的逻辑：</p><p>首先使用objectFieldOffset取到该对象的字段相对基址</p><p>其次，getXX取值方面，也即“读”：</p><ul><li><p>A、非并发编程条件下，基础类型使用getInt、getDouble等方法获取字段值，引用类型使用getObject取值</p></li><li><p>B、并发编程条件下，基础类型使用getIntVolatile、getDoubleVolatile等方法获取字段值，引用类型使用getObjectVolatile取值</p></li></ul><p>putXX设置值方面（也即set字段值），也即“写”：</p><ul><li><p>A、非并发编程条件下，基础类型使用putInt、putDouble等方法对字段进行赋值，引用类型使用putObject等方法对字段进行赋值</p></li><li><p>B、并发编程条件下，由于涉及多线程对临界区的写入，因此需要使用CAS机制去写入，而不是简单的putObject方法，对于基础类型和引用类型常用的CAS方法：</p></li><li><p>```<br>compareAndSwapInt、compareAndSwapLong、compareAndSwapObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的demo程序如下：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">package hashmap.demo;</span><br><span class="line"></span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    private int a &#x3D; 1;</span><br><span class="line">    private String aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private int b &#x3D; 2;</span><br><span class="line">    private String bb &#x3D; &quot;Unsafe looks like a C Pointer&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    private int c &#x3D; 3;</span><br><span class="line">    private String cc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Unsafe4 &#123;</span><br><span class="line">    private static Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            unsafe &#x3D; (Unsafe) field.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        long baseOffset1 &#x3D; unsafe.objectFieldOffset(A.class.getDeclaredField(&quot;a&quot;));</span><br><span class="line">        long baseOffset2 &#x3D; unsafe.objectFieldOffset(B.class.getDeclaredField(&quot;b&quot;));</span><br><span class="line">        long baseOffset3 &#x3D; unsafe.objectFieldOffset(C.class.getDeclaredField(&quot;c&quot;));</span><br><span class="line">        long baseOffset4 &#x3D; unsafe.objectFieldOffset(B.class.getDeclaredField(&quot;bb&quot;));</span><br><span class="line">        long baseOffset5 &#x3D; unsafe.objectFieldOffset(C.class.getDeclaredField(&quot;cc&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(baseOffset1); &#x2F;&#x2F; 12</span><br><span class="line">        System.out.println(baseOffset2); &#x2F;&#x2F; 12</span><br><span class="line">        System.out.println(baseOffset3); &#x2F;&#x2F; 12</span><br><span class="line">        System.out.println(baseOffset4); &#x2F;&#x2F; 16</span><br><span class="line">        System.out.println(baseOffset5); &#x2F;&#x2F; 16</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 非并发情况下，使用getInt方法获取字段值</span><br><span class="line">        System.out.println(unsafe.getInt(new A(), baseOffset1)); &#x2F;&#x2F; a&#x3D;1</span><br><span class="line">        System.out.println(unsafe.getInt(new B(), baseOffset2)); &#x2F;&#x2F; a&#x3D;1</span><br><span class="line">        System.out.println(unsafe.getInt(new C(), baseOffset3)); &#x2F;&#x2F; c&#x3D;3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 引用类型的字段需要使用getObject或者getObjectVolatile获取其值</span><br><span class="line">        System.out.println(unsafe.getObject(new B(), baseOffset4)); &#x2F;&#x2F; Unsafe looks like a C Pointer</span><br><span class="line">        System.out.println(unsafe.getObject(new C(), baseOffset5)); &#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 并发情况下，因为同一对象的同一字段可能有多线程并发get或者set，线程栈内部的字段值和主存字段值可能会不一致，因此需要使用getIntVolatile方法获取字段值</span><br><span class="line">        System.out.println(unsafe.getIntVolatile(new A(), baseOffset1)); &#x2F;&#x2F; a&#x3D;1</span><br><span class="line">        System.out.println(unsafe.getIntVolatile(new B(), baseOffset2)); &#x2F;&#x2F; a&#x3D;1</span><br><span class="line">        System.out.println(unsafe.getIntVolatile(new C(), baseOffset3)); &#x2F;&#x2F; c&#x3D;3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(unsafe.getObjectVolatile(new B(), baseOffset4)); &#x2F;&#x2F; Unsafe looks like a C Pointer</span><br><span class="line"></span><br><span class="line">        &#x2F;* unsafe.getObjectVolatile返回的是Object类型，那么这个Object类型具体代表是Person类型、Integer类型、C类型还是其他什么类型？</span><br><span class="line">        * 转型的依据：cc字段是什么类型就转型为什么类型，例如在ConcurrentHashMap的源码中：</span><br><span class="line">        * seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)</span><br><span class="line">        * 直接从Segments数组取出位于u下标的Object具体来说一个Segment&lt;K,V&gt;类型元素，因此需将取出的Object转型为对应的Segment&lt;K,V&gt;类型</span><br><span class="line">        * 其实这里取到的是cc字段，因此可以转型为String类型</span><br><span class="line">        * 这里需要说明的是：String类型其实不需要显式转型</span><br><span class="line">        *&#x2F;</span><br><span class="line">        String ccField &#x3D; (String) unsafe.getObjectVolatile(new C(), baseOffset5);</span><br><span class="line">        System.out.println(ccField); &#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="关于使用getObject和getObjectVolatile返回值为Object的转型说明"><a href="#关于使用getObject和getObjectVolatile返回值为Object的转型说明" class="headerlink" title="关于使用getObject和getObjectVolatile返回值为Object的转型说明"></a>关于使用<code>getObject</code>和<code>getObjectVolatile</code>返回值为Object的转型说明</h4><p>两个方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObjectVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>这里需要清楚一个基本常识：</p><p>往内存某个地址put一个“Person”类型对象，那么从相同的地址取出来也应该是相同的Person类型对象，如果取出来是Dog类型，那么就不符合设计规范了！或者取出的Object应该转型为Person类型，你给它强制转换为Dog类型，编译器当然会抛出一个：<code>ClassCastException</code></p><p>因此使用getObject和getObjectVolatile方法时，需显式转型为具体类型的实例，以便操作该实例相关方法，这里以在ConcurrentHashMap的某个ensureSegment方法源码作为说明：</p><p><code>UNSAFE.getObjectVolatile(ss, u)</code>表示直接Segments数组取出位于u下标的Object，而这个Object结合上下文可知它是一个Segment<K,V>类型的实例，因此对取出的Object将其转型为对应的Segment<K,V>类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">       == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现在ConcurrentHashMap有13个关于getObjectXX类型方法，无一例外都是这样固定转型用法，不管是上面的ensureSegment方法还是下面segmentForHash方法：</p><p> <code>(Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">segmentForHash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">return</span> (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Unsafe操作自定义类（并发写和读条件下）"><a href="#使用Unsafe操作自定义类（并发写和读条件下）" class="headerlink" title="使用Unsafe操作自定义类（并发写和读条件下）"></a>使用Unsafe操作自定义类（并发写和读条件下）</h4><p>首先使用以下demo程序在单线程情况下compareAndSwapInt的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashmap.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> baseOffset = unsafe.objectFieldOffset(Counter.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、单线程情况，对Counter的value字段进行读和写</span></span><br><span class="line">        Counter&lt;Integer&gt; counter=<span class="keyword">new</span> Counter&lt;&gt;();</span><br><span class="line">        System.out.println(unsafe.getInt(counter, baseOffset)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用非CAS机制的putInt方法将counter的value字段写入10</span></span><br><span class="line">        unsafe.putInt(counter,baseOffset,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 3、取出value字段值是否为10</span></span><br><span class="line">        System.out.println(unsafe.getInt(counter, baseOffset)); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、使用CAS机制的原子写入value的值，写入条件描述为：如果主存里面的value字段值等于所期待的10，那么就将该value字段值更新为新值20</span></span><br><span class="line">        <span class="keyword">boolean</span> isSet= unsafe.compareAndSwapInt(counter,baseOffset,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 5、从第3点可知，主存里面的value字段值一定为10，因此compareAndSwapInt会对value进行更新为20</span></span><br><span class="line">        System.out.println(isSet); <span class="comment">// true</span></span><br><span class="line">        System.out.println(unsafe.getInt(counter, baseOffset)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、使用CAS机制的原子写入value的值，写入条件描述为：如果主存里面的value字段值等于所期待的21，那么就将该value字段值使用原子操作更新为新值30</span></span><br><span class="line">        <span class="keyword">boolean</span> isSet1= unsafe.compareAndSwapInt(counter,baseOffset,<span class="number">21</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 7、从第5点可知，主存里面的value字段值一定为20，显然不符合所期待的21，因此compareAndSwapInt会放弃本次对value写入（更新）</span></span><br><span class="line">        System.out.println(isSet1); <span class="comment">// false</span></span><br><span class="line">        System.out.println(unsafe.getInt(counter, baseOffset)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有个简单的类比：</p><p>counter.value就好比桌子的一张白纸，假设白纸上当前写的初始值为0，同学A此时准备走到桌子前使用compareAndSwapInt去更改白纸的数字，但要满足这样条件：</p><p>1、如果同学A走到桌子前发现白纸的数字是0，与他期待的数字0一致，说明当前没有其他同学抢先更改白纸数字，因此同学A能安全的原子性更改白纸的数字，对其加1，也即同学A使用CAS对白纸的数字改为1，CAS返回true。</p><p>2、如果同学A走到桌子前发现白纸的数字是1，与他期待的数字0一致，说明在他之前已经有另外一个同学早就把白纸数字改为1，因此同学A此时需要放弃对白纸数字的写入，CAS返回false，那么同学A只能重新再到桌子上该，并且他期待白纸的数字是1</p><p>再看一下说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(counter, baseOffest, expect, update);</span><br></pre></td></tr></table></figure><p>可以这样理解：对应counter实例，value字段对应的在主存相对地址为baseOffest，如果该value在主存的值等于线程栈空间存放的expect值，说明没有其他线程去主动更新主存的value字段，此时本线程使用compareAndSwapInt原子更新value字段一定不会产生冲突，而且能成功更新主存value的值。</p><p>这里有个理解技巧：<code>compareAndSwapInt(counter, baseOffest, expect, update)</code> 首先expect跟update是没有任何联系的，不要混淆错看为：expect等于update时才写入，这是非常典型的误解。CAS整个用法只关注线程栈空间的expect值即可，expect会被native方法拿去跟主存中的value字段比较。</p><p>有了以上“只关注线程栈空间的expect去比较主存的值”，接着我们再来理解Unsafe类的getAndSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            V x = get();</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(x, newValue))</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// compareAndSet其实封装了`compareAndSwapInt(counter, baseOffest, expect, update)`</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然getAndSet的思想是：</p><p>1、先去主存去取值回来：x = get()</p><p>2、将取出的值作为expect，也即compareAndSet(x, newValue)的x变量</p><p>3、按照“只关注线程栈空间的expect去比较主存的值”思路：当前期待的值即为x，它被取出来后(暂时存放到线程栈空间)，然后再被拿去跟主存的x去比较，如果两者相等，说明在它之前没有其他线程去更改主存的x，这时当前线程就可以放心用newValue写入主存的x，而且写入操作是原子性的；否则进入下一次尝试</p><p>有了上面的CAS机制铺垫，以下是无锁并发的编程demo:</p><p>使用1万个线程对Counter类的value字段进行加1的CAS原子操作，如果能正确工作，那么最终打印counter.value的是10000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashmap.demo;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; <span class="comment">// 多线程情况下爱，value字段需要使用volatile原语定义，以保证线程间对它的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建unsafe实例以及获取counter.value字段的相对地址，static块是按照源码组织形式的写法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Counter counter=<span class="keyword">new</span> Counter();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> baseOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">            baseOffset = unsafe.objectFieldOffset(Counter.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            <span class="comment">//或者 baseOffset = unsafe.objectFieldOffset(counter.getClass().getDeclaredField(&quot;value&quot;));</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2、创建1万个线程，每个线程对counter.value进行加1操作，这里使用的自旋+CAS，也即直到当前线程能够成功完成对主存的value进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                        <span class="comment">// 在每个线程内部，使用CAS无锁操作对主存中的 counter实例的value字段进行原子加1，如果写入成功，则当前线程退出</span></span><br><span class="line">                        <span class="keyword">int</span> x = counter.value;</span><br><span class="line">                        <span class="keyword">if</span> (unsafe.compareAndSwapInt(counter, baseOffset, x, x + <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            threadList.add(t);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadList)&#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// value最终的值应为100000</span></span><br><span class="line">        System.out.println(counter.value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从此demo程序对于counter.value的加1操作设计，可以总结出一套基于unsafe的原子操作类的模板，这就是<code>java.util.concurrent.atomic</code>里面所有AtomicXXX的设计原理:</p><p>具体来说，java.util.concurrent.atomic中的类可以分成4种：</p><ul><li><p>基本类型：AtomicBoolean，AtomicInteger，AtomicLong</p></li><li><p>引用类型：AtomicReference</p></li><li><p>数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p></li><li><p>更新器类：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p></li><li><p>复合变量类：AtomicMarkableReference，AtomicStampedReference</p></li></ul><h4 id="CAS引起的ABA问题"><a href="#CAS引起的ABA问题" class="headerlink" title="CAS引起的ABA问题"></a>CAS引起的ABA问题</h4><p>CAS的思想主要是：如果主存的值跟expect值相同，说明主存的值没有被其他线程改动过，那么当前线程（以下称为T1）当然可以去原子写入</p><p>这里有个重要的前提，“如果主存的值跟expect值相同”，包含以下两种情况：</p><p>1、主存的值为A，在被T1更新前，这个A没有被其他线程更改过，那么就是我们熟悉的compareAndSet，T1一定可以CAS操作成功，这个没有问题。</p><p>2、主存的值为A，中间被其他线程改为B，随后又被其他线程改回A，那么对于T1来说它看到主存的值还是A（实际上此A已经非彼A），因此T1使用compareAndSet成功操作，尽管在这里T1是操作成功了，但CAS竟然无法发现“A变为B再变为A”的特殊情况，这会引起一些潜在的bug：</p><p>现在考察以下暴露的隐藏问题：</p><p>多个线程对栈进行操作，这个栈为：A-&gt;B-&gt;C-&gt;D，现在线程T1要使用compareAndSet(A,F)对这个栈的栈顶改为B，在T1准备CAS时，线程T2被cpu优先调度执行</p><p>线程T2对A,B,C出栈后，再对A入栈，此时栈变为A-&gt;D，线程T1此时被cpu调度执行</p><p>线程T1使用compareAndSet(A,F)，此刻它认为栈顶的A和它期待的A显然是相同的，于是更新栈顶为B，T1返回的栈为为F-&gt;D，问题出现在哪里？</p><p>正常来说在阻塞式多线程并发情况下：T1执行compareAndSet(A,F)后，T1返回的栈为F-&gt;B-&gt;C-&gt;D</p><p>但是在并发CAS情况下，T1执行compareAndSet(A,F)后，T1返回的栈为F-&gt;D，B和C两个元素就这样凭空消失了！！！</p><p>这就是所谓的“ABA问题”，根本原因就是CAS只是简单比较主存的值和expect的值比较是否相同，它无法发现主存的值是否被改变了多次</p><h4 id="如何解决ABA问题？"><a href="#如何解决ABA问题？" class="headerlink" title="如何解决ABA问题？"></a>如何解决ABA问题？</h4><p>CAS为对A添加一个版本号，即[A,oldVersion]，执行CAS时，不仅要比较主存的值和A是否相同，而且也要比较主存的值的版本号oldVersion有无变化，只有当</p><p>[主存的值,oldVersion] 等于[A,oldVersion]时，才可以执行原子写入操作。</p><p>这就是AtomicStampedReference的设计原理，它有一个内部类Pair，目的就是构造一个具有值和版本号标识的”结对子对象”：Pair(reference,stamp)，它可以唯一表示出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br></pre></td></tr></table></figure><p>还是以“A同学更改桌子上白纸上的数字（或者字符）”作为例子说明</p><p>1、首先白纸上已经写着一个初始值“A”，在A的旁边还写着一个版本0</p><p>2、A同学成功更改白纸字符对应的过程：A同学手上拿着期待值“A”和版本号0走到桌子前，看到白纸上值恰好写着A而且版本也是0，说明没有其他同学主动来更改白纸，因此A同学可以使用CAS原子更改白纸的值，对应代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String paper = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="comment">//asr：模拟桌子上的白纸，白纸的初始值为A，初始版本为0</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(paper, <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 白纸被更新前对应的值和版本号</span></span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp()); <span class="comment">// A:0</span></span><br><span class="line">                <span class="comment">// A同学手上拿着期待值A和期待版本0，以及准备写入的新值B，准备写入的新版号</span></span><br><span class="line">                <span class="keyword">boolean</span> isSet = asr.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">                System.out.println(isSet); <span class="comment">//true</span></span><br><span class="line">              <span class="comment">// 白纸被CAS成功更新后对应的值和版本号</span></span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp());<span class="comment">// B:1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、A同学放弃此次更改白纸字符对应的过程：同学A手上拿着期待值“A”和版本号0走到桌子，看到白纸上写着A但是版本号写着2，虽然值相同，但两者版本不一样，说明其他同学主动来更改白纸的值A，A同学放弃本次更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String paper = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(paper, <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// B同学优先使用CAS对白纸进行写入</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp()); <span class="comment">// A:0</span></span><br><span class="line">                <span class="keyword">boolean</span> isSet = asr.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                System.out.println(isSet);<span class="comment">// true</span></span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp());<span class="comment">//B:1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C同学优先使用CAS对白纸进行写入</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp()); <span class="comment">//B:1</span></span><br><span class="line">                <span class="keyword">boolean</span> isSet = asr.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                System.out.println(isSet);<span class="comment">//true</span></span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp());<span class="comment">//A:2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等前面两个同学对白纸完成CAS操作后，白纸的值和版本号为A:2</span></span><br><span class="line">        <span class="comment">// 此时A同学手上拿着期待值A和期待版本0，以及准备写入的新值B，准备写入的新版号</span></span><br><span class="line">        <span class="comment">// 结果发现白纸的值虽然为A，但是版本号为2，因此isSet为false也即CAS操作失败,白纸的值维持为A</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp());<span class="comment">// A:2</span></span><br><span class="line">                <span class="keyword">boolean</span> isSet = asr.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                System.out.println(isSet);<span class="comment">//false</span></span><br><span class="line">                System.out.println(asr.getReference() + <span class="string">&quot;:&quot;</span> + asr.getStamp());<span class="comment">//A:2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了demo例子的铺垫，结合前面的unsafe多个demo的案例，AtomicStampedReference就是基于compareAndSwapObject方法进行设计的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br></pre></td></tr></table></figure><p>AtomicStampedReference在内部中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, expectPair, newPair);</span><br></pre></td></tr></table></figure><p>源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference; <span class="comment">// 用于被比较的引用类型（当然可以传入任意类型，因为这里是T泛型)，在以下被称为值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//  版本号</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 内部结对类，是辅助类，用于解决ABA的关键手段之一</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于构建一个值和版本号绑在一起的“结对”实例</span></span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// unsafe进行CAS操作的实例object，考虑并发场景下，需要使用volatile内存可见性原语</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用促使的引用类型实例和促使版本号构造AtomicStampedReference实例，例如</span></span><br><span class="line"><span class="comment">    AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);</span></span><br><span class="line"><span class="comment">    那么这里initialRef就是&quot;A&quot;，initialStamp就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">        pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能返回获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pair.reference;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 只能返回获取值对应的版本号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pair.stamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//可以同时返回值和版本号，注意这里返回的版本号是放在入参数组stampHolder[0]中,至于为何不是直接用整型变量返回版本号？使用整型数据更方便让get方法将版本号放在给定的入参数据里，算是普通思路。</span></span><br><span class="line">    <span class="comment">/*常见用法：</span></span><br><span class="line"><span class="comment">      int[] stampHolder=new int[1];</span></span><br><span class="line"><span class="comment">      这时asr.get(stampHolder)取到值，而stampHolder[0]就取到值对应的版本号</span></span><br><span class="line"><span class="comment">      System.out.println(&quot;ref:&quot;+asr.get(stampHolder)+&quot; stamp:&quot;+stampHolder[0]);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] stampHolder)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; pair = <span class="keyword">this</span>.pair;</span><br><span class="line">        stampHolder[<span class="number">0</span>] = pair.stamp;</span><br><span class="line">        <span class="keyword">return</span> pair.reference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟compareAndSet类似，可以看做是弱CAS，不常用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(expectedReference, newReference,</span><br><span class="line">                             expectedStamp, newStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    该方法就是用户调用的CAS方法，这里做了一个优化小技巧：如果新值和新版本号恰好等于主存的的值以及主存的版本号，显然连CAS操作都省了，直接返回true，有点点耍小聪明和碰运气</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">          <span class="comment">// 通过对比期待值和主存值、期待版本号和主存值对应的版本号，可以确保不再出现所谓的ABA问题，能“感知”值的改变次数</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用CAS去更新，只是简单的更新操作，这一方法适合用在单线程或者冲突不严重的并发情况，看你对业务的经验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">if</span> (newReference != current.reference || newStamp != current.stamp)</span><br><span class="line">            <span class="keyword">this</span>.pair = Pair.of(newReference, newStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   不管版本号是否相同，只要期待值和主存的值相等，就用新版本号更新主存值的旧版本号，</span></span><br><span class="line"><span class="comment">   注意：每次调用该方法都可能会更新失败，需要结合自旋直到更新成功为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attemptStamp</span><span class="params">(V expectedReference, <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            (newStamp == current.stamp ||</span><br><span class="line">             casPair(current, Pair.of(expectedReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="comment">// 以下就是前面我们熟悉的unsafe相关操作：创建unsafe实例、pair的相对地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> pairOffset =</span><br><span class="line">        objectFieldOffset(UNSAFE, <span class="string">&quot;pair&quot;</span>, AtomicStampedReference.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到了这里才是真正执行对主存对象进行操作的逻辑，可以看到这里使用compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span></span><br><span class="line">    <span class="comment">// 注意对比前面的unsafe.compareAndSwapInt(被更新的对象,相对地址,期待值,新值);</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(sun.misc.Unsafe UNSAFE,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String field, Class&lt;?&gt; klazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.objectFieldOffset(klazz.getDeclaredField(field));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// Convert Exception to corresponding Error</span></span><br><span class="line">            NoSuchFieldError error = <span class="keyword">new</span> NoSuchFieldError(field);</span><br><span class="line">            error.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与AtomicStampedReference的内部的结对对象是[值,版本]设计思想类似的还有AtomicMarkableReference，它内部是结对对象是[值,标志位]，也即[值,1]或者[值,0]，如下面所示</p><p>AtomicStampedReference内部是结对类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> T reference;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reference = reference;</span><br><span class="line">    <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicMarkableReference内部是结对类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> T reference;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> mark;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">boolean</span> mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reference = reference;</span><br><span class="line">    <span class="keyword">this</span>.mark = mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们两个在使用场合有什么不同呢？</p><p>AtomicStampedReference可以给值(reference)加上版本号后，可以追踪到这个值的整个变化过程，如：<br><code>[A,0] =&gt; [B,1] =&gt; [C,2] =&gt; [A,3]</code>，通过getStamp返回的版本号大小，可以知道值在中途被更改了3次。</p><p>场景另外一种并发场景：也需要你并不关心值（reference）中途更改了多少次，而是只关注这个主存的值是否有被修改过，AtomicMarkableReference显然很适合。</p><p>ABA 问题</p><p><a href="https://blog.csdn.net/tiandao321/article/details/80811103?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">https://blog.csdn.net/tiandao321/article/details/80811103?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p><h4 id="ReentrantLock里面的阻塞锁和非柱塞锁的区别"><a href="#ReentrantLock里面的阻塞锁和非柱塞锁的区别" class="headerlink" title="ReentrantLock里面的阻塞锁和非柱塞锁的区别"></a>ReentrantLock里面的阻塞锁和非柱塞锁的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock reentrantLock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A在工作时，线程B被阻塞了，啥事都做不了，干等，浪费资源</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B在运行中&quot;</span>);</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的运行结果来看：线程A在工作时，线程B被阻塞了，啥事都做不了，干等，浪费资源</p><p>如果使用非阻塞锁，那么线程A在工作时，线程B不会被阻塞，线程B可以自由做其他事情，没有白白自旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock reentrantLock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A在工作时，使用tryLock非阻塞锁，这样线程B不会被线程A阻塞，线程A工作的同时，线程B也可以去干点别的事情！</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!reentrantLock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B在工作中，对链表扫描是否存在key节点&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：可以看到在第5秒后，线程B获取到了锁因此退出while循环，使用trylock非阻塞锁后，在这5秒时间内，至少线程B没有白白浪费，而是干了一些查询key节点的工作，这就是scanAndLockForPut的设计思想</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A在运行中</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br></pre></td></tr></table></figure><p>对比scanAndLockForPut的<code>while (!tryLock())</code>即可理解其设计思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 某线程没有获取锁的期间，顺便完成了链表的遍历以及新key节点的创建工作</span></span><br><span class="line"> <span class="comment">// ......         </span></span><br><span class="line">         node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// ...... </span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Unsafe类在整套JUC框架中绝对是核心的一个概念，它是实现free-lock的底层核心设计，它内部直接调用的是Java的JNI，只有理解它的CAS原子操作的内部设计原理，才能更加深入理解JUC的free-lock设计。&lt;/p&gt;
&lt;h4 id=&quot;使用unsafe操作数组&quot;&gt;&lt;a href=&quot;#使用unsafe操作数组&quot; class=&quot;headerlink&quot; title=&quot;使用unsafe操作数组&quot;&gt;&lt;/a&gt;使用unsafe操作数组&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; hashmap.demo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.lang.reflect.Field;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sun.misc.Unsafe;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Unsafe3&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Unsafe unsafe;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Field field = Unsafe.class.getDeclaredField(&lt;span class=&quot;string&quot;&gt;&amp;quot;theUnsafe&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            field.setAccessible(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            unsafe = (Unsafe)field.get(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] intArr1=&amp;#123;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] intArr2=&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// byte类型数组内存每个&amp;quot;单元格&amp;quot;容量是1个字节，对应Scale就是1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; byteScale=unsafe.arrayIndexScale(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// short类型数组内存每个&amp;quot;单元格&amp;quot;容量是2个字节，对应Scale就是2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; shortScale=unsafe.arrayIndexScale(&lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt;[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// int类型数组内存每个&amp;quot;单元格&amp;quot;容量是4个字节，对应Scale就是4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; intScale=unsafe.arrayIndexScale(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// long类型数组内存每个&amp;quot;单元格&amp;quot;容量是8个字节，对应Scale就是8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; longScale=unsafe.arrayIndexScale(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Integer类型数组内存每个&amp;quot;单元格&amp;quot;容量是4个字节，对应Scale就是4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; integerScale=unsafe.arrayIndexScale(Integer[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// String类型数组内存每个&amp;quot;单元格&amp;quot;容量是4个字节，对应Scale就是4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stringScale=unsafe.arrayIndexScale(String[].class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; b=intArr1.getClass().equals(intArr2.getClass()) &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[].class.equals(intArr1.getClass()) &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[].class.equals(intArr2.getClass());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(b); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// intArr1数组实例和intArr2的数组实例都是同一对象，指向int[]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(intArr1.getClass().equals(intArr2.getClass()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取当前intArr1数组实例的相对基址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; baseOffset1=unsafe.arrayBaseOffset(intArr1.getClass());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(baseOffset1); &lt;span class=&quot;comment&quot;&gt;// 16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取当前intArr2数组实例的相对基址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; baseOffset2=unsafe.arrayBaseOffset(intArr2.getClass());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(baseOffset2); &lt;span class=&quot;comment&quot;&gt;// 16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从baseOffset1和baseOffset2的值都是16可以看出，这是他们指向对象的相对基址，而不是指向对象绝对地址（如果是执行对象绝对地址，那么这里两个值一定不同）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1)); &lt;span class=&quot;comment&quot;&gt;//打印intArr1第1个（首地址）对应的元素，也就是intArr1[0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale)); &lt;span class=&quot;comment&quot;&gt;//打印intArr1的第2个元素，也就是intArr1[1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale* &lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;//打印intArr1的第3个元素，也就是intArr1[2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(unsafe.getIntVolatile(intArr1,baseOffset1+intScale* &lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;//打印intArr1的第4个元素，也就是intArr1[3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取intArr2的数据的第3个元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(unsafe.getIntVolatile(intArr2,baseOffset2+intScale* &lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;//打印intArr2第3个对应的元素，也就是intArr2[2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：基于AQS驱动的ReentrantLock公平锁和非公平锁实现原理解析</title>
    <link href="https://yield-bytes.github.io/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://yield-bytes.github.io/2021/04/25/%E5%9F%BA%E4%BA%8EAQS%E9%A9%B1%E5%8A%A8%E7%9A%84ReentrantLock%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2021-04-24T16:00:00.000Z</published>
    <updated>2022-05-10T03:16:34.043Z</updated>
    
    <content type="html"><![CDATA[<p>本文是入门和理解AQS框架的重要文章，尽管AQS还有共享模式以及条件Condition等设计，但重入锁仍然是最适合理解AQS底层数据结构及其算法设计的切入点。</p><h4 id="单线程使用可重入锁的内部简单工作机制"><a href="#单线程使用可重入锁的内部简单工作机制" class="headerlink" title="单线程使用可重入锁的内部简单工作机制"></a>单线程使用可重入锁的内部简单工作机制</h4><p>分别在以下两个断点位置进行debug，断点条件i==5，并且在variables窗口watch一个特殊的变量<code>state</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 断点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.unlock();<span class="comment">// 断点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到<code>lock.lock()</code>的内部执行流程如下所示，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、java.util.concurrent.locks.ReentrantLock$NonfairSync@29444d75[State = 4, empty queue]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;                  </span><br><span class="line">          sync.lock();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 重点：使用cas更新state的值</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用下面5在ReentrantLock定义的tryAcquire方法</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();<span class="comment">// 重点：获取state变量当前值</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc); <span class="comment">// 重点：更新state变量值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>经过这么一轮debug，可以观察到原来<code>lock.lock()</code> 通过cas更改state变量值来实现“可重入性”，例如，这里for循环5次使得该线程在同一锁对象上加锁了5次，可以看到对应的state累加计数等于5，基于此可以推出<code>lock.unlock()</code>操作则是每次<code>unlock()</code>就是对state进行cas减1操作，如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; </span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;  <span class="comment">// 当i=5次循环时，这里getState=1,releases=1</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 所有的重入都退出后，此刻不再有线程持有独占锁。</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c); <span class="comment">// 当i=5次循环时，state被置为0</span></span><br><span class="line">            <span class="keyword">return</span> free;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其实这个state变量是一个非常重要的“同步状态”，记录了当前持有独占锁的线程的重入加锁次数，它在AbstractQueuedSynchronizer内部定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The synchronization state.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从<code>ReentrantLock</code>以上两个流程来看，重点需要解析<code>sync.lock()</code>、<code>sync.release(1)</code>，而这里sync实例是来自<code>ReentrantLock</code>内部定义<code>Sync</code>类，该类继承至<code>AbstractQueuedSynchronizer</code>，因此如果要真正理解<code>ReentrantLock</code>的可重入性，则需要深入底层的`AbstractQueuedSynchronizer，这是JUC众多锁工具的底层实现。</p><h4 id="从Sync类了解AQS"><a href="#从Sync类了解AQS" class="headerlink" title="从Sync类了解AQS"></a>从Sync类了解AQS</h4><p>在真正解析AQS之前，可以先看看在ReentrantLock内部定义的Sync，以下按<code>ReentrantLock</code>默认构造器进入分析流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NonfairSync</code>是实现非公平锁的主要逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     # 这里说，当前线程当前直接无需排队去争抢锁资源，也即不是先到先到，所以是才称为非公平模式。抢不到才去阻塞队列里面排队</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync类定义了获取锁的分配逻辑，这里涉及到对同步状态state更改、同一线程的锁重入、锁重入释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment"> * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment"> * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1、AQS工作原理"><a href="#1、AQS工作原理" class="headerlink" title="1、AQS工作原理"></a>1、AQS工作原理</h4><p>源码给出的官方设计思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Even though this class is based on an internal FIFO queue, it does not automatically enforce FIFO acquisition policies. The core of exclusive synchronization takes the form:</span><br><span class="line">   Acquire:</span><br><span class="line">       while (!tryAcquire(arg)) &#123;</span><br><span class="line">          enqueue thread if it is not already queued;</span><br><span class="line">          possibly block current thread;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">   Release:</span><br><span class="line">       if (tryRelease(arg))</span><br><span class="line">          unblock the first queued thread;</span><br><span class="line">   </span><br><span class="line">(Shared mode is similar but may involve cascading signals.)</span><br></pre></td></tr></table></figure><p>等待队列（又称阻塞队列、阻塞链表、）内部工作原理：我们建议此工作原理在深度掌握AQS设计之前预读几遍，在深度掌握AQS源代码设计之后再回头理解它，你会发现能完全掌握AQS的整体设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Wait queue node class.</span><br><span class="line">The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait.</span><br><span class="line">To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field.</span><br><span class="line">            +------+  prev +-----+       +-----+</span><br><span class="line">       head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">            +------+       +-----+       +-----+</span><br><span class="line">       </span><br><span class="line">Insertion into a CLH queue requires only a single atomic operation on &quot;tail&quot;, so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the &quot;head&quot;. However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts.</span><br><span class="line">The &quot;prev&quot; links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;u&#x2F;scott&#x2F;synchronization&#x2F;</span><br><span class="line">We also use &quot;next&quot; links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the &quot;next&quot; fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated &quot;tail&quot; when a node&#39;s successor appears to be null. (Or, said differently, the next-links are an optimization so that we don&#39;t usually need a backward scan.)</span><br><span class="line">Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility.</span><br><span class="line">CLH queues need a dummy header node to get started. But we don&#39;t create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention.</span><br><span class="line">Wait queue node class.</span><br><span class="line"></span><br><span class="line">Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on.</span><br><span class="line">Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class.</span><br></pre></td></tr></table></figure><p>这里当然最权威的方式是解析AQS源代码的开发注释</p><blockquote><p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.</p><p>AQS为众多同步器（例如semaphores，events，reentrantLock）提供了一个实现框架，该框架的底层是基于变体的FIFO等待队列（注意：此等待队列又称为阻塞队列）实现的，大部分同步器只需通过原子更改一个变量名为state值的方式即可完成相关同步状态控制，AQS的子类（也即自行设计的同步器）必须重新定义相关的protected方法——以更新state状态变量，从而实现state值得变化能够表征获得锁或者释放锁，AQS的其他所有方法则实现了排队和阻塞机制。AQS的子类可以维护其他状态字段，但只有子类使用getState、setState和compareAndSetState方法去原子更新这个state值才能追踪到同步状态的变化。</p></blockquote><p>上面所说的FIFO等待队列其实就是CLH队列（Craig, Landin, Hagersten这三个人发明的数据结构，因此用他们名字命名），它在AQS内部使用双向链表队列+CAS原子锁实现，功能如下：</p><ul><li><p>FIFO的设计，保证线程在阻塞队列中的公平性，也即先进去阻塞队列等待抢锁资源的线程，也将是最先被唤醒出队</p></li><li><p>未成功拿到独占锁的线程们将通过自旋和CAS插入到队尾，显然是非阻塞设计，在短时间内能够实现无锁并发插入这些线程。</p></li></ul><h4 id="2、从构造方法解析"><a href="#2、从构造方法解析" class="headerlink" title="2、从构造方法解析"></a>2、从构造方法解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> AbstractQueuedSynchronizer&#125; instance</span></span><br><span class="line"><span class="comment">     * with initial synchronization state of zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue node class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     # 这里就解释了CLH阻塞队列的设计细节</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span></span><br><span class="line"><span class="comment">     * Hagersten) lock queue. CLH locks are normally used for</span></span><br><span class="line"><span class="comment">     * spinlocks.  We instead use them for blocking synchronizers, but</span></span><br><span class="line"><span class="comment">     * use the same basic tactic of holding some of the control</span></span><br><span class="line"><span class="comment">     * information about a thread in the predecessor of its node.  A</span></span><br><span class="line"><span class="comment">     * &quot;status&quot; field in each node keeps track of whether a thread</span></span><br><span class="line"><span class="comment">     * should block.  A node is signalled when its predecessor</span></span><br><span class="line"><span class="comment">     * releases.  Each node of the queue otherwise serves as a</span></span><br><span class="line"><span class="comment">     * specific-notification-style monitor holding a single waiting</span></span><br><span class="line"><span class="comment">     * thread. The status field does NOT control whether threads are</span></span><br><span class="line"><span class="comment">     * granted locks etc though.  A thread may try to acquire if it is</span></span><br><span class="line"><span class="comment">     * first in the queue. But being first does not guarantee success;</span></span><br><span class="line"><span class="comment">     * it only gives the right to contend.  So the currently released</span></span><br><span class="line"><span class="comment">     * contender thread may need to rewait.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span></span><br><span class="line"><span class="comment">     * tail. To dequeue, you just set the head field.</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span></span><br><span class="line"><span class="comment">     * operation on &quot;tail&quot;, so there is a simple atomic point of</span></span><br><span class="line"><span class="comment">     * demarcation from unqueued to queued. Similarly, dequeuing</span></span><br><span class="line"><span class="comment">     * involves only updating the &quot;head&quot;. However, it takes a bit</span></span><br><span class="line"><span class="comment">     * more work for nodes to determine who their successors are,</span></span><br><span class="line"><span class="comment">     * in part to deal with possible cancellation due to timeouts</span></span><br><span class="line"><span class="comment">     * and interrupts.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">     * needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">     * successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">     * predecessor. For explanation of similar mechanics in the case</span></span><br><span class="line"><span class="comment">     * of spin locks, see the papers by Scott and Scherer at</span></span><br><span class="line"><span class="comment">     * http://www.cs.rochester.edu/u/scott/synchronization/</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span></span><br><span class="line"><span class="comment">     * The thread id for each node is kept in its own node, so a</span></span><br><span class="line"><span class="comment">     * predecessor signals the next node to wake up by traversing</span></span><br><span class="line"><span class="comment">     * next link to determine which thread it is.  Determination of</span></span><br><span class="line"><span class="comment">     * successor must avoid races with newly queued nodes to set</span></span><br><span class="line"><span class="comment">     * the &quot;next&quot; fields of their predecessors.  This is solved</span></span><br><span class="line"><span class="comment">     * when necessary by checking backwards from the atomically</span></span><br><span class="line"><span class="comment">     * updated &quot;tail&quot; when a node&#x27;s successor appears to be null.</span></span><br><span class="line"><span class="comment">     * (Or, said differently, the next-links are an optimization</span></span><br><span class="line"><span class="comment">     * so that we don&#x27;t usually need a backward scan.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cancellation introduces some conservatism to the basic</span></span><br><span class="line"><span class="comment">     * algorithms.  Since we must poll for cancellation of other</span></span><br><span class="line"><span class="comment">     * nodes, we can miss noticing whether a cancelled node is</span></span><br><span class="line"><span class="comment">     * ahead or behind us. This is dealt with by always unparking</span></span><br><span class="line"><span class="comment">     * successors upon cancellation, allowing them to stabilize on</span></span><br><span class="line"><span class="comment">     * a new predecessor, unless we can identify an uncancelled</span></span><br><span class="line"><span class="comment">     * predecessor who will carry this responsibility.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;CLH queues need a dummy header node to get started. But</span></span><br><span class="line"><span class="comment">     * we don&#x27;t create them on construction, because it would be wasted</span></span><br><span class="line"><span class="comment">     * effort if there is never contention. Instead, the node</span></span><br><span class="line"><span class="comment">     * is constructed and head and tail pointers are set upon first</span></span><br><span class="line"><span class="comment">     * contention.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span></span><br><span class="line"><span class="comment">     * use an additional link. Conditions only need to link nodes</span></span><br><span class="line"><span class="comment">     * in simple (non-concurrent) linked queues because they are</span></span><br><span class="line"><span class="comment">     * only accessed when exclusively held.  Upon await, a node is</span></span><br><span class="line"><span class="comment">     * inserted into a condition queue.  Upon signal, the node is</span></span><br><span class="line"><span class="comment">     * transferred to the main queue.  A special value of status</span></span><br><span class="line"><span class="comment">     * field is used to mark which queue a node is on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span></span><br><span class="line"><span class="comment">     * Scherer and Michael Scott, along with members of JSR-166</span></span><br><span class="line"><span class="comment">     * expert group, for helpful ideas, discussions, and critiques</span></span><br><span class="line"><span class="comment">     * on the design of this class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="comment">// SHARED变量表示节点被标记为共享模式，可以看到是一个空的Node()对象，用于Semaphore这种共享模式的加锁工具</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">       <span class="comment">// EXCLUSIVE为null表示节点被标记为独占模式，用于类似ReentrantLock这种独占锁工具</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">      <span class="comment">// waitStatus变量值若为1，表示当前线程节点已经被取消排队（注意虽然被标记为取消状态，但还未出队）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="comment">// waitStatus变量值若为-1，表示当前线程节点的后驱线程节点需要被唤醒</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="comment">// waitStatus变量值若为-2，表示当前线程节点处在条件等待当中</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于共享模式的锁工具的连续唤醒操作设计，ReentrantLock用不上此设计，Semaphore这种工具可以用上。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 以下是关于waitStatus变量取不同值时对应的场景说明</span></span><br><span class="line"><span class="comment">         * waitStatus用来表示当前线程节点的状态，仅取以下5个值</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         * SIGNAL的说明：当前线程节点的后驱节点发出SIGNAL唤醒的通知，当前线程需要在释放资源后或者自身被标记为取消状态后去唤醒挂在身后的后驱节点，为了避免无畏线程竞争，实现acquire功能的方法必须首先给出自己需要被通知，然后再重试“atomic acquire”,如果获取失败，则阻塞自己（而不是一直去CAS重试）</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         * SIGNAL的说明：由于超时或中断，节点被取消。此类节点不会脱落此取消状态。取消节点的线程不会再次阻塞。</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         * CONDITION的说明：节点当前位于“condition queue”，在被放到CLH队列之前，它不会用作同步队列节点，此时状态将设置为0。表示节点在等待队列上，当其他线程调用了Condition的signal方法后，CONDITION状态的节点将从等待队列转移到同步队列中，等待获取资源。</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         * PROPAGATE的说明：应将releaseShared操作传播到其他节点，这是在doReleaseShared中设置的（仅针对头部节点），以确保releaseShared操作能够传播继续进行，即使其他操作已经介入。</span></span><br><span class="line"><span class="comment">         * 换句话说：在共享模式下，前驱节点线程节点不仅要唤醒其后驱线程节点，同时也会唤醒后驱线程节点的后驱线程节点，类似一路唤醒下去。</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         * waitStatus采用这几个值得设计是为了方便使用，非负值表示节点不需要signal，所以，大多数代码不需要检查特定的值，只需要检查符号即可。</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         * waitStatus状态值，对于正常同步节点，它会被初始化为0，而对于condition nodes，则会被置为“CONDITION”，一般使用CAS去更新waitStatus的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        结合前面的prev指针用于处理线程被取消的情形。</span></span><br><span class="line"><span class="comment">     The &quot;prev&quot; links (not used in original CLH locks), are mainly</span></span><br><span class="line"><span class="comment">     needed to handle cancellation. If a node is cancelled, its</span></span><br><span class="line"><span class="comment">     successor is (normally) relinked to a non-cancelled</span></span><br><span class="line"><span class="comment">     predecessor. </span></span><br><span class="line"><span class="comment">          non-callcelled node -&gt; a node -&gt;successor</span></span><br><span class="line"><span class="comment">          non-callcelled node -&gt;successor</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      next指针被设计为“We also use &quot;next&quot; links to implement blocking mechanics”。 已经被取消的节点会将next指针指向自己而不是把next指向null，这一点设计很像SkipList里面的remove设计逻辑这种设计有利于GC。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用于指向获取锁的线程，可以看到其实Node节点就是包装需要获取锁的线程，因此也可以称为线程节点。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      ReentrantLock用不到此属性，CountDownLatch、CyclicBarrier等这种共享模式锁工具可以用到此属性。</span></span><br><span class="line"><span class="comment">nextWaiter特殊标记,Node在CLH队列时，nextWaiter表示共享式或独占式标记，也即nextWaiter=SHARED;Node在条件队列时，nextWaiter表示下个Node节点指针</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         判断线程节点是否处于共享模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有成功获取资源（例如锁）的线程就会使用此包装为一个Node，此节点会被addWaiter方法使用，也即将节点入队（此队列称为wait queue）</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">   * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">   * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">   * CANCELLED.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 阻塞队列（双向链表）的头结点，惰性创建，仅能在setHead方法能够对head指向做调整</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">   * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="comment">// 阻塞队列（双向链表）的尾结点，惰性创建，仅能在enq方法能够对tail指向做调整</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The synchronization state.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 这个state变量就是AQS子类需要去更爱的，用于控制资源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">   * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="3、关于线程是如何被”Queuing”-入队操作"><a href="#3、关于线程是如何被”Queuing”-入队操作" class="headerlink" title="3、关于线程是如何被”Queuing” 入队操作"></a>3、关于线程是如何被”Queuing” 入队操作</h4><p>AQS本身并不会触发线程去入队的操作，那么是在什么时机才会有这个操作发生？这里不妨还是以</p><p><code>ReentrantLock</code>使用为例：根据基本的demo用法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建新线程执行任务</span></span><br><span class="line">    &#125;   <span class="keyword">catch</span> ( Exception e)&#123;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造器可以看出，默认创建的是非公平的同步锁，具体逻辑由<code>NonfairSync</code>类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-1-NonfairSync"><a href="#3-1-NonfairSync" class="headerlink" title="3.1 NonfairSync"></a>3.1 NonfairSync</h5><p>Sync object for non-fair locks，也即<code>NonfairSync</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 线程执行lock.lock()也即对应以下逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这个动词短语immediate barge用得很贴切：线程可以立即&quot;乱闯&quot;,也即新线程使用lock.lock()时，可以不排队直接参加竞争资源，如何竞争？ 只要将state状态CAS更新为1则抢占成功，这就是所谓的非公平锁。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">          <span class="comment">//该线程成功竞争后，将自己独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 新来的线程compareAndSetState(0, 1)失败，那么进入逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-acquire-1"><a href="#3-2-acquire-1" class="headerlink" title="3.2 acquire(1)"></a>3.2 acquire(1)</h5><p><code>acquire(1)</code> 是AQS内部的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      从该方法可以看出：线程在NonfairSync里面抢占更新state失败，也还有机会再来去申请资源，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也即上面的tryAcquire，如果成功，那么就返回true，如果线程还是tryAcquire失败，那么此时线程就会被排队：acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ，然后进入selfInterrupt()</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于AQS的<code>tryAcquire</code>需要子类实现具体的逻辑，也即ReentrantLock内部的tryAcquire，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-nonfairTryAcquire"><a href="#3-3-nonfairTryAcquire" class="headerlink" title="3.3 nonfairTryAcquire"></a>3.3 nonfairTryAcquire</h5><p>ReentrantLock内部的tryAcquire内部是由<code>ReentrantLock</code>内部的Sync类的<code>nonfairTryAcquire</code>方法实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment"> * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment"> * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NonfairSync类的lock()方法实现了该抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 这里就是AQS的tryAcquire在子类Sync的具体实现逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取同步状态state值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="comment">//①如果同步状态此时为0，说明没有其他线程在竞争，那么当前线程果断使用CAS尝试将state从0更新为1，这里也再次证明新线程使用lock.lock()第一次if (compareAndSetState(0, 1))不成功，在tryAcquire里面还有机会再尝试一次compareAndSetState，如果本次成功CAS那么将自己设为独占线程，获得锁资源，返回true。</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      ② 如果当前线程就是之前设置的独占线程，说明当前线程再次“重入”获取锁，那么只要重入次数最大值只要不溢出，那么就可以让当前线程再次“重入”并更新同步状态state的值，这就是ReentrantLock可重入锁设计的原理,最多可以重入多少次？ 首先state是int类型，因此最大值为：</span></span><br><span class="line"><span class="comment">      max=(1&lt;&lt;31)-1</span></span><br><span class="line"><span class="comment">      所以才会有以下的用法：</span></span><br><span class="line"><span class="comment">    double tooLarge=Math.pow(2,31);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= tooLarge; i++) &#123;</span></span><br><span class="line"><span class="comment">        lock.lock();  // 同一线程，重入加锁到最大值，其实内部就是对state进行CAS累加，也即setState(nextc)，直到state值累加到超过最大值则抛出&quot;Maximum lock count exceeded&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">        lock.unlock();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*③ 若无法满足①、②条件，说明当前线程面临激烈锁资源竞争，那么只能返回false，接着就被安排去入队，也即AQS里面的</span></span><br><span class="line"><span class="comment">if (!tryAcquire(arg) &amp;&amp;</span></span><br><span class="line"><span class="comment">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span><br><span class="line"><span class="comment">        selfInterrupt();      </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  到此我们已经找出了线程从开始使用<code>lock.lock()</code> 到被<code>Queuing</code>入队的时机，因此接下里入队操作就是核心逻辑了</p><h4 id="4、AQS-的acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#4、AQS-的acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="4、AQS 的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))"></a>4、AQS 的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</h4><p>这里接着第3章节的内容，此时线程需要被入队，执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> ,这里的arg就是<code>acquire(1)</code>里面的1，表示需要对state加1或者需要获取1个锁资源</p><h5 id="4-1-addWaiter-Node-EXCLUSIVE"><a href="#4-1-addWaiter-Node-EXCLUSIVE" class="headerlink" title="4.1 addWaiter(Node.EXCLUSIVE)"></a>4.1 addWaiter(Node.EXCLUSIVE)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/*对于独占模式来说，addWaiter的功能就是将当前线程包装为线程节点，并使用CAS将自己添加到阻塞队列的尾部，分两个步骤：</span></span><br><span class="line"><span class="comment"> 1、优先快速尝试将自己通过CAS加到阻塞队列尾部，如果入队失败就进入2</span></span><br><span class="line"><span class="comment"> 2、使用enq(node)确保自己最后可以加入到阻塞队列尾部（或者入队成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">      Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">      <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">      Node pred = tail;</span><br><span class="line">      <span class="comment">//1、 node&lt;=&gt;node&lt;=&gt;pred 变成 node&lt;=&gt;node&lt;=&gt;pred&lt;=&gt;new Node</span></span><br><span class="line">      <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 新线程节点的前驱节点指针指向pred，如果pred节点没有被其他线程更改，那么CAS成功就会将pred的next指针指向新线程节点，从而使得新线程节点成功入队。</span></span><br><span class="line">          node.prev = pred;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">              pred.next = node;</span><br><span class="line">            <span class="comment">//返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//2、enq内部使用自旋（for循环）保证线程一定能入队</span></span><br><span class="line">      enq(node);</span><br><span class="line">     <span class="comment">//返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-enq-node"><a href="#4-2-enq-node" class="headerlink" title="4.2 enq(node)"></a>4.2 enq(node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 将线程节点插入双向链表（阻塞队列）尾部，如果链表为空，则需要先初始化后再插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 自旋，保证线程一定能在某次循环中CAS入队成功</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">          <span class="comment">// 如果链表尾节点为空，说明阻塞队列还未创建，因此需要初始化，这时新建一个非线程节点放在链表头部。</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"> <span class="comment">/* 这里非常关键：双向链表的头节点不是线程节点，而是一个无参构造方法的节点，这里可以称为辅助节点，就像ConcurrentSkipList底层的数据链表头节点(BASE_HEADER)也是辅助节点的设计:</span></span><br><span class="line"><span class="comment"> head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null),null, null, 1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            <span class="comment">// 如果双向链表已经存在，则线程节点尝试使用CAS将自己添加到队列尾部</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                  <span class="comment">// 返回线程节点给到外部调用方，也即acquireQueued方法</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>未能获取的锁资源（未能对state更新成功的）新线程通过<code>addWaiter</code>或者<code>enq</code>方法让自己添加到阻塞队列尾部，或者这样理解：在<code>addWaiter</code>里面首先尝试，也就代码里面的注释所表达的意思：Try the fast path of enq; backup to full enq on failure</p><p>接下里还需要做什么？线程加入阻塞队列以后，是马上把自己阻塞起来，还是刚好位于队列第一个线程节点位置然后马上尝试获取锁资源呢？这就是<code>acquireQueued(addWaiter(Node.EXCLUSIVE),1))</code>核心设计</p><h5 id="4-3-acquireQueued-addWaiter-Node-EXCLUSIVE-1"><a href="#4-3-acquireQueued-addWaiter-Node-EXCLUSIVE-1" class="headerlink" title="4.3 acquireQueued(addWaiter(Node.EXCLUSIVE),1))"></a>4.3 acquireQueued(addWaiter(Node.EXCLUSIVE),1))</h5><p>从上面4.1和4.2可知，阻塞队列里面放的都是未能成功获取锁资源的线程节点（除了头节点辅助节点），这些节点已经入队，但总不能放着它们在队列里面就不管了，接下来还要做一件事情：</p><p>从队列取出线程节点，让它重新去尝试获取已经被外面活动线程释放的锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 已在队列中的线程以独占且不可中断的模式获取锁资源</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// failed表示是否成功获得锁资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 表示线程是否被中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 核心逻辑：取出当前入队线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          （注意区分阻塞队列的head节点（辅助节点又称哨兵节点）和阻塞队列的第一个线程节点）</span></span><br><span class="line"><span class="comment">          如果当前线程节点前驱节点恰好是head节点，说明当前线程节点就是阻塞队列的第一个线程节点，当然有资格且第一个先去尝试获取锁资源，如下结构</span></span><br><span class="line"><span class="comment">          head(辅助节点) &lt;-&gt; node（第一个线程节点） -&gt; null</span></span><br><span class="line"><span class="comment">          */</span> </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">             <span class="comment">// 这里的tryAcquire表示你（阻塞队列的第一个线程节点）有资格去抢锁资源，但也要看看能否抢赢外界线程</span></span><br><span class="line">            <span class="comment">/* 如果线程节点获取资源成功，那么就可以做出队操作，这里出队很巧妙:</span></span><br><span class="line"><span class="comment">            经过setHead之后，线程节点node.thread不再指向线程，而是变成了辅助节点而且成为阻塞队列的新head，原head节点通过p.next = null 完成GC，这就是为何阻塞队列将head节点设计辅助节点new Node()的原因：第一个线程节点获取锁资源后需要出队以及方便回收设计</span></span><br><span class="line"><span class="comment">                    private void setHead(Node node) &#123;</span></span><br><span class="line"><span class="comment">                    head = node;</span></span><br><span class="line"><span class="comment">                    node.thread = null;</span></span><br><span class="line"><span class="comment">                    node.prev = null;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">          两种情况会进入if逻辑：</span></span><br><span class="line"><span class="comment">          ①如果当前节点是第一个线程节点或者说其前驱节点是head节点，但在tryAcquire(arg)竞争失败（因为外面有新的线程在lock.lock()里面CAS成功）</span></span><br><span class="line"><span class="comment">          ②当前线程节点不是第一个线程节点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-shouldParkAfterFailedAcquire-p-node"><a href="#4-4-shouldParkAfterFailedAcquire-p-node" class="headerlink" title="4.4 shouldParkAfterFailedAcquire(p, node)"></a>4.4 shouldParkAfterFailedAcquire(p, node)</h5><p>接4.3内容，这部分内容可以解析阻塞队列为何被称为“阻塞”队列的原因，<code>shouldParkAfterFailedAcquire</code>从方法名字也可以看出其设计目的：既然第一个线程节点获取锁资源失败，那么就不能一直无限去<code>Acquire</code>，而是在阻塞队列是自己变成“阻塞状态”去等待，这样就不会白白消耗cpu。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">    * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">    * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/*非常重要的源码注释：根据4.3，如果线程节点未能p == head &amp;&amp; tryAcquire(arg)，则检查并更新该节点里面的Node.SIGNAL状态值。如果线程节点应该被阻塞，则返回true。</span></span><br><span class="line"><span class="comment">为了理解以下设计逻辑，这里不妨先假设当前链表结构为：</span></span><br><span class="line"><span class="comment">head(waitStatus=0) &lt;-&gt; node(waitStatus=0) -&gt; null</span></span><br><span class="line"><span class="comment">那么这里pred显然指向head(waitStatus=0) ，node指向第一个线程节点node（waitStatus=0）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// waitStatus也即线程节点的等待状态，新线程节点创建时waitStatus默认为0， </span></span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">   <span class="comment">// ①waitStatus变量值若为Node.SIGNAL也即等于-1，说明对于pred(-1)&lt;-&gt;node(ws=0)来说，pred节点其实已经是阻塞状态了，那么node作为pred的后驱节点也肯定要被阻塞，因此返回true后，在parkAndCheckInterrupt里面node就会被阻塞起来</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">/* ② 如果waitStatus的值&gt;0,也即waitStatus=Node.CANCELLED=1,说明pred线程节点取消排队，考察以下阻塞队列结构</span></span><br><span class="line"><span class="comment">  head(ws=-1)&lt;-&gt;node1(ws=-1)&lt;-&gt;node2(ws=1)&lt;-&gt;node3(ws=0)-&gt; null</span></span><br><span class="line"><span class="comment">  假设pred=node2,node=node3,显然node2已经取消排队，那么node3不能跟在它后面，因此需要将node2出队，也即node.prev = pred = pred.prev，有：</span></span><br><span class="line"><span class="comment">  head(ws=-1)&lt;-&gt;node1(ws=-1)&lt;-&gt;node3(ws=0)-&gt; null</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  如果链表中不止一个node2取消排队，还有很多节点也是处于“取消排队状态”，那么就使用前向遍历，直到找到有一个前驱线程节点不是取消排队的节点（说明此节点状态可靠），然后把它作为node3的前驱节点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">             <span class="comment">//将原来写法 node.prev = pred = pred.prev拆分为下面写法</span></span><br><span class="line">               pred=pred.prev;</span><br><span class="line">               node.prev = pred</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">         <span class="comment">// 经过前向遍历后，所有取消状态的节点都被出队，那么到这里就可以找到一个可靠状态的pred前驱节点，将要处理的node挂在它后面即可</span></span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*注意这里的注释，非常重要：</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">         <span class="comment">//③ 执行流来到这里说明前驱节点waitStatus要么是0要么是PROPAGATE，此时需要将待处理的node节点前驱节点pred的waitStatus设为SIGNAL值，以表示我作为pred的后驱节点需要等待被唤醒，但还没进入park阻塞状态。</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>流程：</p><p>1、构造器使用非公平同步类对象new NonfairSync()</p><p>2、lock.lock()调用1定义的lock()方法，尝试对父类AQS的state变量使用CAS从0更新为1，成功就将自己设为独占锁，失败就进入3</p><p>3、使用acquire(1)继续去竞争资源，其内部调用AQS的acquire方法，</p><p>4、AQS的acquire方法是模板方法，因此会调用子类的tryAcquire(arg)再次尝试更新state</p><p>5、子类tryAcquire里面的nonfairTryAcquire(1)，再次读取state，如果为0就尝试CAS加1，如果成功就跟2类似，失败CAS且当前线程是独占线程，就可以再次对state加1</p><p>6、否则AQS的tryAcquire(1)返回false，表示当前线程两次获取锁资源失败，那么就开始7</p><p>7、将当前线程包装为线程节点，将在addWaiter尝试加入双向链表：如果链表已经存在，快速执行CASTail，成功就返回，失败则使用enq使用for循环入队：第一次循环判断是否需要初始化双向链表，如果需要则新建一个辅助节点头结点，第二次循环才是CASTail，由于使用自旋，因此enq一定可以使得线程节点加入双向链表尾部。</p><p>8、在acquireQueued中，刚入队的线程节点如果恰好又是第一个线程节点就会马上尝试tryAcquire(1)，如果成功获取锁资源，就会将setHead操作，并将当前线程节点设为辅助节点（也即线程出队），如果tryAcquire(1)失败来到9</p><p>9、使用shouldParkAfterFailedAcquire(pred, node)  ，第一个线程节点尝试tryAcquire(1)失败后不能无限循环再获取资源，因此将它的前驱节点设为SIGNAL状态（要求：pred == node.prev 读一致性），表示当前节点等待阻塞中，需要被唤醒</p><p>10、由于当前节点的前驱节点可能处于“取消排队状态”，因此当前节点不能将此类节点作为自己的前驱节点，因此需要不断前向遍历，直到找到waitStatus&lt;=0的前驱节点 pred(waitStatus&lt;=0)（找到一个可以“挂靠”的、非取消状态的前驱节点）由于使用</p><p><code>node.prev = pred = pred.prev</code> 因此只要处于“取消排队状态”的前驱节点都会被删掉而不在链表中。</p><p>11、只要将前驱节点的ws设为Node.SIGNAL，那么就可以返回true，来到parkAndCheckInterrupt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>线程节点就可以自己阻塞了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>12、回到acquire(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment"> * acquire on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上流程完成了 线程入队、尝试获取锁资源、阻塞自己变成等待唤醒，接下来</p><p>需要了解清楚，在线程节点执行阻塞自己的时候使用shouldParkAfterFailedAcquire，里面能够向前遍历阻塞队列并会有side-effect作用：沿途清除“处在取消状态的线程节点”，那么为何会出现又取消状态的节点呢？以及在什么时机变成取消状态节点？</p><h5 id="4-5-acquireQueued里面的cancelAcquire-node"><a href="#4-5-acquireQueued里面的cancelAcquire-node" class="headerlink" title="4.5  acquireQueued里面的cancelAcquire(node)"></a>4.5  acquireQueued里面的cancelAcquire(node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ul><li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li><li>是在什么时间释放节点通知到被挂起的线程呢？</li></ul><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utilities for various versions of acquire</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* cancelAcquire流程将结合以下链表结构作为解释，其中node4就是当前要被设为取消排队的线程节点，如果node5是null，那么说明node4是tail节点，如果node5是线程节点，说明node4不在链表尾部：</span></span><br><span class="line"><span class="comment">  head&lt;-&gt;node1(非取消)&lt;-&gt;node2(CANCELLED)&lt;-&gt;node3(CANCELLED)&lt;-&gt;node4(非取消)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">  <span class="comment">// 准备执行时发现node4已结被回收，则可以直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 既然当前节点取消排队，那么node.thread不再指向线程，转而执行null，用于GC</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ① </span></span><br><span class="line"><span class="comment">    例如按上面的链表节点结构假设，node4被设为CANCELLED状态前，必须先找到一个非CANCELLED的前驱节点，以便node4取消排队后，其后驱节点node5才可以挂靠在一个“可靠的前驱节点”pred，显然这个pred就是node1节点：</span></span><br><span class="line"><span class="comment">    也即：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(非取消)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">    而node2和node3线程节点都是取消排队状态，因此需要跳过它们：Skip cancelled predecessors</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">   <span class="comment">// pred.next=node ,pred=node.prev</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ②</span></span><br><span class="line"><span class="comment">   继续上面已经跳过cancelled predecessors，有：</span></span><br><span class="line"><span class="comment">   head&lt;-&gt;node1(非取消)&lt;-&gt;node4(非取消)&lt;-&gt;node5，此时可以把node4设为取消状态</span></span><br><span class="line"><span class="comment">   也即：</span></span><br><span class="line"><span class="comment">   head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">   做这个操作有个收益： other Nodes can skip past us，也就是说其他当外面有新线程入队需要做shouldParkAfterFailedAcquire等操作时，都会忽略这个已经是CANCELLED状态的node4节点，这样cancelAcquire操作就不会被外界线程节点干扰到。</span></span><br><span class="line"><span class="comment">     acquireQueued和shouldParkAfterFailedAcquire回答了准备设置“CANCELLED”线程节点时机，而cancelAcquire的设计回答在什么条件下将“准备取消节点”设为“CANCELLED”</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">     node.waitStatus = Node.CANCELLED;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ③</span></span><br><span class="line"><span class="comment">   对于②链表结构：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5，如果node4本身就是tail节点（此时node5其实是null），那么将node4进行CAS设为null后，链表结构变为：</span></span><br><span class="line"><span class="comment">   head&lt;-&gt;node1(非取消)-&gt;null，也即注释里面说到的：If we are the tail, remove ourselves.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">         ④ </span></span><br><span class="line"><span class="comment">         根据③得到的链表结构且node4不是tail节点（此时node5是线程节点），</span></span><br><span class="line"><span class="comment">         有：head&lt;-&gt;node1(非取消)&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">         if条件1：如果pred不是头节点而且指向具体线程（也即node1不是头节点）且pred节点也即node1.ws是SIGNAL，那么则进入if</span></span><br><span class="line"><span class="comment">         if条件2：如果pred不是头节点而且指向具体线程（也即node1不是头节点）且pred节点也即node1.ws&lt;=0且经过CAS将node1.ws设为SIGNAL，那么则进入if。</span></span><br><span class="line"><span class="comment">         条件1意思是说如果node1.ws已经是SIGNAL，那么直接将node5（不是null且未取消）设为node1的后驱节点，这样就能正确的删除node4节点，而且能正确的将后面的线程节点挂在node1后面</span></span><br><span class="line"><span class="comment">         head&lt;-&gt;node1(ws=SIGNAL)&lt;-&gt;node5(ws非取消)</span></span><br><span class="line"><span class="comment">         条件2的意思是说如果node1.ws是未取消状态值那么就用CAS将node1.ws设为SIGNAL，然后再把node5（要求不是null且未取消）挂在node1后面</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">          <span class="comment">// 要求即将被删除的node4节点的后驱节点node5既不是null且未取消状态才能将node5挂在node4前驱节点pred的后面</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">       ⑤ </span></span><br><span class="line"><span class="comment">       若不满足④说明，node4的前驱节点就是head节点，也即：</span></span><br><span class="line"><span class="comment">       head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5</span></span><br><span class="line"><span class="comment">       那么，node4很快会被删除，那么node5（如果node5不是null也不是非取消节点）就作为阻塞队列的第一个线程节点当然可以优先出队去获外面其他线程释放的锁资源</span></span><br><span class="line"><span class="comment">       因此ndoe4删除前，需要先唤醒后驱节点node5，接下来就来到4.6下面的章节逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-6unparkSuccessor"><a href="#4-6unparkSuccessor" class="headerlink" title="4.6unparkSuccessor"></a>4.6<code>unparkSuccessor</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 接上面4.5的⑤内容，如果node4有后驱节点，那么就node4需要唤醒这个后驱节点（假设后驱节点不是null也不是取消状态）</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">       * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">       * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="comment">// 由于接上面4.5流程，node4已经设为CANCELLED，那么以下if逻辑会被跳过</span></span><br><span class="line">      <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">          compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">       * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">       * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">       * non-cancelled successor.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    node4的后驱节点一定是个正常的线程节点吗？ node4.next可能是以下几种情况：</span></span><br><span class="line"><span class="comment">    ① node4-&gt;null</span></span><br><span class="line"><span class="comment">      ② head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5(CANCELLED)&lt;-&gt;node6(CANCELLED)&lt;-&gt;node7(非取消状态)....</span></span><br><span class="line"><span class="comment">      ③ head&lt;-&gt;node4(CANCELLED)&lt;-&gt;node5(非取消)....</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      Node s = node.next; <span class="comment">// 先取出node4的后驱节点</span></span><br><span class="line">    <span class="comment">// 针对后驱节点为null或者后驱节点是取消状态的情况，如①、②链表结构所示</span></span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从阻塞链表（阻塞队列）尾部向前遍历，找出一个waitStatus是不取消状态的的后驱节点，这个节点就是node4要唤醒的正常状态节点（总不能让node4唤醒一个已经取消排队或者为null的后驱节点吧）</span></span><br><span class="line">          <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  s = t;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 针对情况③ node4的直接后驱节点就是正常状态节点或者经过&quot;traverse backwards&quot;找到的the actual non-cancelled successor，唤醒之</span></span><br><span class="line">      <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">          LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上完成<code>reentrantlock</code>的加锁lock.lcok() 过程</p><p>在<code>unparkSuccessor</code>为何采用从链表尾部向前遍历，而不是正序遍历去找一个<code>the actual non-cancelled successor</code> ?</p><p>首先在AQS的开头源代码注释里面有提到：</p><blockquote><p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor.</p><p>prev前驱指针主要用于解决线程节点取消排队的情况（注意CLH locks并没有使用prev前驱指针），如果一个线程节点已经取消，那么它的后驱节点就会重新链接到一个非取消状态的前驱节点</p><p>例如  现有阻塞队列结构：node1(非取消)&lt;—&gt;node2(取消)&lt;—&gt;node3(非取消)&lt;—&gt;node4(非取消)，假设现在要将node3设为取消节点，最终队列肯定要变成：node1(非取消)&lt;—&gt;node4(非取消)，过程就是按照cancelAcquire的流程：</p><p>①  跳过node3“已经是取消状态”的节点，也即node2</p><p>② 此时node1就是node3的后驱节点node4需要挂靠的前驱节点</p><p>③ 根据以下逻辑<code>compareAndSetNext(pred, predNext, next)</code>,也即<code>compareAndSetNext(pred=node1, predNext=node3, next=node4);</code>，可以推出：在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此只能利用prev指针从后往前遍历才能够遍历完全部的Node。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">     ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">         (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">        pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">      <span class="comment">// 要求即将被删除的node4节点的后驱节点node5既不是null且未取消状态才能将node5挂在node4前驱节点pred的后面</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            compareAndSetNext(pred, predNext, next);</span><br></pre></td></tr></table></figure></blockquote><h5 id="4-7关于阻塞队列本身的其他方法：-Queue-inspection-methods"><a href="#4-7关于阻塞队列本身的其他方法：-Queue-inspection-methods" class="headerlink" title="4.7关于阻塞队列本身的其他方法： Queue inspection methods"></a>4.7关于阻塞队列本身的其他方法： Queue inspection methods</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Queries whether any threads are waiting to acquire. Note that</span></span><br><span class="line"><span class="comment">    * because cancellations due to interrupts and timeouts may occur</span></span><br><span class="line"><span class="comment">    * at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not guarantee that any</span></span><br><span class="line"><span class="comment">    * other thread will ever acquire.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">    * constant time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there may be other threads waiting to acquire</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回队列里面是否有正在等待获取锁资源的线程节点，返回true也不代表存在“正在等待获取锁资源的线程节点”，因为“线程取消排队或者timeout”的情况随时可以发生，这会导致head != tail有二义性。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head != tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Queries whether any threads have ever contended to acquire this</span></span><br><span class="line"><span class="comment">    * synchronizer; that is if an acquire method has ever blocked.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation returns in</span></span><br><span class="line"><span class="comment">    * constant time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there has ever been contention</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回是否曾经有线程出现过竞争同步器以获取锁资源，或者说acquire方法被阻塞过。简单的说：若head不为null，说明有线程节点执行enq方法里面的`compareAndSetHead(new Node())`，也即有竞争</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasContended</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;In this implementation, this operation normally returns in</span></span><br><span class="line"><span class="comment">    * constant time, but may iterate upon contention if other threads are</span></span><br><span class="line"><span class="comment">    * concurrently modifying the queue.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the first (longest-waiting) thread in the queue, or</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> null&#125; if no threads are currently queued</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="comment">// 返回阻塞队列中的第一个（等待时间最长的）线程节点，注意这可不是返回head这个头结点（辅助节点）。如果当前没有线程节点排队，则为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">       <span class="comment">// 先快速判断。head==tail说明阻塞队列还未创建，直接返回null即可，否则使用fullGetFirstQueuedThread去获取第一个线程节点。这种“投机性先实施A失败再实施B”的设计其实在ConcurrentHashMap里面的addCount：先尝试对baseCount累加失败则使用fullAddCount确保能够累加计数成功。</span></span><br><span class="line">       <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Version of getFirstQueuedThread called when fastpath fails</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Thread <span class="title">fullGetFirstQueuedThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The first node is normally head.next. Try to get its</span></span><br><span class="line"><span class="comment">        * thread field, ensuring consistent reads: If thread</span></span><br><span class="line"><span class="comment">        * field is nulled out or s.prev is no longer head, then</span></span><br><span class="line"><span class="comment">        * some other thread(s) concurrently performed setHead in</span></span><br><span class="line"><span class="comment">        * between some of our reads. We try this twice before</span></span><br><span class="line"><span class="comment">        * resorting to traversal.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// h:head节点的临时变量，s：head节点的后驱节点(successor)临时变量</span></span><br><span class="line">       Node h, s;</span><br><span class="line">       Thread st;<span class="comment">// 后驱节点指向的线程:successorthread</span></span><br><span class="line">     </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       此设计非常巧妙：</span></span><br><span class="line"><span class="comment">       正常来说，阻塞队列的第一个线程节点就是我们要找的“first queued thread”节点,那么为了确保获取该节点刚开始读的线程节点，必须要保证前后一致性读：不一致性读是如何出现的呢？ 考察这种情况，第一次读node.thread不为空但第二读node.thread已经是null，或者第一次读s.prev是原来的head节点，第二次读s.prev已经不是原来的head节点，这是因为在这两次读的过程中，有其他线程节点正在并发执行setHead操作，那么如何快速实现一致性读呢？ 直接实施两次尝试即可！</span></span><br><span class="line"><span class="comment">       if ( (第一次尝试)|| (第二次尝试))</span></span><br><span class="line"><span class="comment">       第一次尝试：要求head节点不是null且后驱节点s不为null且s.prev还是指向原head节点且后驱节点的thread引用不为null</span></span><br><span class="line"><span class="comment">       第二次尝试： 要求head节点不是null且后驱节点s不为null且s.prev还是指向原head节点且后驱节点的thread引用不为null</span></span><br><span class="line"><span class="comment">       第一次尝试成功说明没有其他线程干扰确实是一致性读，那么head的后驱节点s就是要返回的first queued thread</span></span><br><span class="line"><span class="comment">       第一次尝试失败说明有其他线程正在进行setHead操作，那么需要再投机性的进行第二次尝试。</span></span><br><span class="line"><span class="comment">       如果第一次尝试失败、第二次尝试也失败，那么只能通过遍历阻塞队列的方式去找`first queued thread`</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span> (((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>) ||</span><br><span class="line">           ((h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span>))</span><br><span class="line">           <span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Head&#x27;s next field might not have been set yet, or may have</span></span><br><span class="line"><span class="comment">        * been unset after setHead. So we must check to see if tail</span></span><br><span class="line"><span class="comment">        * is actually first node. If not, we continue on, safely</span></span><br><span class="line"><span class="comment">        * traversing from tail back to head to find first,</span></span><br><span class="line"><span class="comment">        * guaranteeing termination.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">因为head节点next指针可能还未开始设置，又或者有线程在执行setHead过程中head的next还未设置好，因此直接无法利用next指针从链表头部往后遍历。</span></span><br><span class="line"><span class="comment">所以需要这么做：先检查tail节点不为空时且tail节点不是head节点，说明此时有阻塞队列且有线程节点队列里面，这样就可以safely从链表尾部开始遍历，直到t指针指向head节点时说明t的前驱节点已经来到head位置即可结束遍历，</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">       Node t = tail;</span><br><span class="line">       Thread firstThread = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (t != <span class="keyword">null</span> &amp;&amp; t != head) &#123;</span><br><span class="line">           Thread tt = t.thread;</span><br><span class="line">         <span class="comment">// firstThread不断更新指向途中经过的“非取消”的线程节点的线程引用</span></span><br><span class="line">         <span class="comment">// 或者说跳过“取消排队”的线程节点</span></span><br><span class="line">           <span class="keyword">if</span> (tt != <span class="keyword">null</span>)</span><br><span class="line">               firstThread = tt;</span><br><span class="line">           t = t.prev;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> firstThread;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * Returns true if the given thread is currently queued.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This implementation traverses the queue to determine</span></span><br><span class="line"><span class="comment">    * presence of the given thread.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> thread the thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given thread is on the queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the thread is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 判断给定线程是否在阻塞队列里面</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isQueued</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (thread == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// 从链表尾部开始遍历（safely traversing from tail back to head），只要遍历节点的thread==给定的thread引用，返回true。</span></span><br><span class="line">       <span class="keyword">for</span> (Node p = tail; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">           <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 还有其他共享模式下的队列方法，这里不在讨论范围。</span></span><br></pre></td></tr></table></figure><h4 id="5、解锁过程"><a href="#5、解锁过程" class="headerlink" title="5、解锁过程"></a>5、解锁过程</h4><p>其实只要掌握了加锁lock.lcok() 过程，也即<code>renntrantlock</code>和AQS之间的交互，那么解锁过程则相对节点</p><p>调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock() </span><br></pre></td></tr></table></figure><p><code>reentrantlock内部的</code>unlock`：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">// 加锁每次对state加1，释放锁则对state减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS内部的<code>release</code>方法：这里说明真正释放锁的所有操作都是在AQS内部完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的tryRelease就是子类Sync具体要实现的方法：将state值进行CAS减1操作</span></span><br><span class="line">    <span class="comment">// (1)如果子类的tryRelease更新state同步状态且state值为0，就会返回true，那么说明外面有线程能够释放锁资源，此时就需要将阻塞队列里面的第一个线程节点唤醒</span></span><br><span class="line">   <span class="comment">// (2) 如果子类的tryRelease更新state同步状态成功且state值不为0，则会返回false，说明当前有同一线程多次重入的锁并准备多次释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      取出头节点（辅助节点），如果阻塞队列存在或者头节点的后驱节点非取消非初始化，则该后驱节点需要被h唤醒</span></span><br><span class="line"><span class="comment">        ①对于h=null，说明阻塞队列已经不存在或者还未创建，或者刚创建Head=null，但是还未有线程节点入队，显然这些情况都不需要再做“唤醒操作”</span></span><br><span class="line"><span class="comment">        ②对于h不是null，说明头节点已经是一个new Node()辅助节点，此时如果h.waitStatus == 0，说明阻塞队列刚完成初始化，仅有一个head辅助节点，单还未有其他线程节点入队，因此也不需要再做“唤醒操作”</span></span><br><span class="line"><span class="comment">        ③对于h不是null，h.waitStatus != 0取值有哪些呢，因为reentrant是独占模式，waitStatus的取值分别是1，-1，而-2，-3是共享模式不在讨论范围，因此当h.waitStatus=-1，那么恰好head的后驱节点就是需要唤醒的节点当然使用unparkSuccessor逻辑，而h.waitStatus=1，说明head节点的后驱节点是一个“取消排队”的节点，那么需要借助unparkSuccessor方面里面找到一个真正的非取消状态节点（the actual non-cancelled successor）作为要唤醒的节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AQS内部的<code>release</code>方法中的<code>tryRelease</code>调用子类的Sysc的<code>tryRelease</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 读取最新的state值并扣减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="comment">// 因为是独占模式，要求必须持有锁资源的线程才能去释放锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"><span class="comment">// 表示是否成功释放资源</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 如果c=0，说明当前state值已经是0，说明没有其他线程占用锁资源，将独占线程引用设为null即可，并将释放资源标志设为true</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将state更新为扣减后的c值：state=getState() - releases</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free; <span class="comment">// true或者false将影响AQS的release流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、唤醒线程节点后的执行流"><a href="#6、唤醒线程节点后的执行流" class="headerlink" title="6、唤醒线程节点后的执行流"></a>6、唤醒线程节点后的执行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 这里是线程节点在acquireQueued里面被阻塞自己的地方，</span></span><br><span class="line">      <span class="comment">// 唤醒后，将会执行下面这一句：返回线程是否中断状态</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于Thread.interrupted();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span></span><br><span class="line"><span class="comment">     * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment">     * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment">     * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment">     * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">     * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">     * returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//  返回当前线程是否被中断过,线程第一次调用将返回true，表示被中断，若线程两次调用，则第二次返回没被中断过，所以要注意其源码注释说明：after the first call had cleared its interrupted</span></span><br><span class="line">     * status and before the second call had examined it</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里因为线程被唤醒，显然之前在阻塞队列等待的过程就等于“被中断过”，故<code>parkAndCheckInterrupt</code>返回为true，将继续<code>acquireQueued</code>以下的for流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 线程唤醒后parkAndCheckInterrupt返回true，回到for循环，当线程能够获取锁资源成功后，这个线程中断状态interrupted = true就会acquireQueued返回外部的acquire调用者。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上流程，<code>acquireQueued</code>返回true，回到调用<code>acquireQueued</code>的流程 <code>lock.lock()--&gt;acquire(1)--&gt;acquireQueued--&gt;selfInterrupt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么将继续执行<code>selfInterrupt</code>逻辑：也即线程进入阻塞队列，被阻塞然后唤醒后（自己被中断过）拿到锁，最后线程自己中断一下，为何拿到锁后还要设计线程中断自己？这是什么逻辑？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释：</p><p>（1）先考察一个线程使用<code>lock.lock</code>且在<code>compareAndSetState</code>就直接拿到锁资源的情况（意味着它没有进入阻塞队列），显然整个过程线程自己没有被<code>LockSupport.park(this)</code>阻塞，因此这种线程无需执行<code>selfInterrupt</code> 操作，这样外界有其他逻辑检查这个线程的中断状态时就会知道它未中断过。</p><p>（2）由于Doug Lea采用这样的设计：Acquires in exclusive uninterruptible mode for thread already in queue（已在阻塞队列中的线程节点以独占且不可中断（不响应中断）的模式去等待获取锁资源）。只要有一个线程进入阻塞队列然后阻塞自己最后被唤醒且拿到锁的过程显然线程自己是有“中断过”的情况，因此拿到锁后，需要给自己补充一个“中断过”的标记，这样外界有其他逻辑检查这个线程的中断状态时就会知道它曾经中断过。</p><h4 id="7、reentrantlock的公平锁模式"><a href="#7、reentrantlock的公平锁模式" class="headerlink" title="7、reentrantlock的公平锁模式"></a>7、reentrantlock的公平锁模式</h4><p>有了以上基础，那么分析公平锁则显得简单一些。内部使用的是 FairSync内部同步器实现相关逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);  <span class="comment">// 构造器指定公平锁方式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FairSync</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">// 以下是体现公平锁的设计思想：</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">      <span class="comment">//若state同步状态变量此时为0，那么说明线程可以直接去竞争锁资源</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/* ① 请求独占锁前先问问阻塞队列有无阻塞线程正在等待锁（这就体现公平的原则，后者当然要等先到者）</span></span><br><span class="line"><span class="comment">          如果阻塞队列有正在排队的线程节点，那么当前新来的线程就无法设置state值，只能去到③（假设非重入线程） 返回false，最终可能是需要进入acquireQueued逻辑把自己入队处理，因此这里的逻辑正是体现了获取锁资源的“公平性”</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ② 如果当前线程就是持有锁的线程，当然可以让它多次重入，只要不超过重入次数最大值即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ③</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁请求锁资源为<code>acquire(1)</code>是AQS的内部的<code>acquire</code>方法，再调用子类的<code>tryAcquire</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此完整过程是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock() --&gt; lock内部的acquire(1) --&gt; FairSync内部的tryAcquire--&gt; 查询阻塞队列是否有线程节点正在排队 --&gt; 如果tryAcquire失败则进入AQS的acquireQueued内部逻辑</span><br></pre></td></tr></table></figure><p>hasQueuedPredecessors的设计逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Queries whether any threads have been waiting to acquire longer than the current thread.</span></span><br><span class="line"><span class="comment">     查询是否有线程节点的等待获取锁资源时间长于当前线程。</span></span><br><span class="line"><span class="comment">     或者用以下表达式也可以达到相同目的，但是hasQueuedPredecessors比它更高效</span></span><br><span class="line"><span class="comment">  An invocation of this method is equivalent to (but may be more efficient than):</span></span><br><span class="line"><span class="comment">     获取第一个线程节点 != 当前节点且阻塞队列不为空，则返回true，说明当前节点排还不能马上去抢锁资源需要排在阻塞队列的线程节点之后</span></span><br><span class="line"><span class="comment">     如果阻塞队列为空，则返回false，当前节点可以马上去获取锁资源</span></span><br><span class="line"><span class="comment">     getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     由于中断或者timeout导致线程节点的“取消排队”的情况在任何时候都可以发生，因此返回true也不能保证其他线程就是比当前线程更早申请锁资源</span></span><br><span class="line"><span class="comment">     同理，返回false也不能说明现在阻塞队列是空，因为return false的瞬间可能会有其他线程成功竞争到进入排队</span></span><br><span class="line"><span class="comment">     Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment">     timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment">     guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment">     thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment">     race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">     due to the queue being empty.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hasQueuedPredecessors方法用于公平同步器使用以避免线程之间的碰撞竞争。</span></span><br><span class="line"><span class="comment">This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer&#x27;s tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:</span></span><br><span class="line"><span class="comment">公平的、可重入的、独占模式的同步器内部定义的tryAcquire应该是以下流程：</span></span><br><span class="line"><span class="comment"> protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">   // 表示同一线程重入获取锁资源，只需要增加state值即可</span></span><br><span class="line"><span class="comment">     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment">     return true;</span></span><br><span class="line"><span class="comment">   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">   //如果阻塞队列里面有线程节点那么当前线程不能马上acquire到锁资源，要等其他线程节点，因此返回false</span></span><br><span class="line"><span class="comment">     return false;</span></span><br><span class="line"><span class="comment">   &#125; else &#123;</span></span><br><span class="line"><span class="comment">    // 其他情况说明锁资源没有其他线程竞争，当前线程节点可以直接去acquire</span></span><br><span class="line"><span class="comment">     // try to acquire normally</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> 以上的设计流程就是Reentrantlock里面公平锁FairSync的tryAcquire实现流程</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     （1）如果有一个排队线程在当前线程之前则返回true，例如公平锁的FairSync，外面新来的当前线程使用tryAcquire则需要判断阻塞队列是否有阻塞线程，如果有，那么当前线程就没办法马上拿到锁，只能等，这就体现公平原则：先来先得，等得越久的那个线程节点优先获取锁资源</span></span><br><span class="line"><span class="comment">     （2）如果当前线程恰好位于第一个线程节点或者阻塞队列没有线程节点，则返回false</span></span><br><span class="line"><span class="comment">true if there is a queued thread preceding the current thread, and false if the current thread is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">      </span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">      <span class="comment">// 返回true条件： </span></span><br><span class="line">      <span class="comment">// 情况1：head辅助节点已经完成初始化也即：compareAndSetHead(new Node())  且 head的后驱节点第一个线程节点是null</span></span><br><span class="line">        <span class="comment">// 情况2：head辅助节点已经完成初始化也即：compareAndSetHead(new Node())  且 head的后驱节点第一个线程节点不是当前节点</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8、到此可以总结公平和非公平的锁的区别"><a href="#8、到此可以总结公平和非公平的锁的区别" class="headerlink" title="8、到此可以总结公平和非公平的锁的区别"></a>8、到此可以总结公平和非公平的锁的区别</h4><p>非公平：直接CAS竞争state这个锁资源，不需要询问阻塞队列是否有线程节点正在等待获取锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平：当state为0时，需要询问阻塞队列是否有线程节点正在等待获取锁资源，如果有则无法马上获取锁资源，需要等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非公平的优点：线程并发性能高，因为所有新来的线程先通过<code>compareAndSetState(0, 1)</code>竞争锁资源，如果成功就能马上返回，无需经过排队。</p><p>非公平的缺点：因为新来的线程很快通过<code>compareAndSetState(0, 1)</code>提前获得锁资源，导致阻塞队列的线程节点可能一直没有机会出队获取锁资源，也即出现“线程饥饿”</p><p>线程饿死的解释：</p><blockquote><p>If a thread is not granted CPU time because other threads grab it all, it is called “starvation”. The thread is “starved to death” because other threads are allowed the CPU time instead of it. The solution to starvation is called “fairness” - that all threads are fairly granted a chance to execute.</p></blockquote><p>公平的优点：不会出现线程饿死，保证每个新来的线程都有机会获得竞争锁资源</p><p>公共的缺点：线程并发性能可能比非公平锁低一些。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是入门和理解AQS框架的重要文章，尽管AQS还有共享模式以及条件Condition等设计，但重入锁仍然是最适合理解AQS底层数据结构及其算法设计的切入点。&lt;/p&gt;
&lt;h4 id=&quot;单线程使用可重入锁的内部简单工作机制&quot;&gt;&lt;a href=&quot;#单线程使用可重入锁的内部简单工作机制&quot; class=&quot;headerlink&quot; title=&quot;单线程使用可重入锁的内部简单工作机制&quot;&gt;&lt;/a&gt;单线程使用可重入锁的内部简单工作机制&lt;/h4&gt;&lt;p&gt;分别在以下两个断点位置进行debug，断点条件i==5，并且在variables窗口watch一个特殊的变量&lt;code&gt;state&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReentrantLockDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ReentrantLock lock=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lock.lock(); &lt;span class=&quot;comment&quot;&gt;// 断点位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lock.unlock();&lt;span class=&quot;comment&quot;&gt;// 断点位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到&lt;code&gt;lock.lock()&lt;/code&gt;的内部执行流程如下所示，&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1、java.util.concurrent.locks.ReentrantLock$NonfairSync@29444d75[State = 4, empty queue]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          sync.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2、java.util.concurrent.locks.ReentrantLock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (compareAndSetState(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// 重点：使用cas更新state的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                setExclusiveOwnerThread(Thread.currentThread());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                acquire(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3、java.util.concurrent.locks.AbstractQueuedSynchronizer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareAndSetState&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; expect, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; update)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// See below for intrinsics setup to support this&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, stateOffset, expect, update);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 4、java.util.concurrent.locks.AbstractQueuedSynchronizer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp; &lt;span class=&quot;comment&quot;&gt;// 调用下面5在ReentrantLock定义的tryAcquire方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            selfInterrupt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 5、java.util.concurrent.locks.ReentrantLock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nonfairTryAcquire(acquires);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 6、java.util.concurrent.locks.ReentrantLock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nonfairTryAcquire&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = getState();&lt;span class=&quot;comment&quot;&gt;// 重点：获取state变量当前值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (compareAndSetState(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, acquires)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    setExclusiveOwnerThread(current);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nextc = c + acquires;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// overflow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;string&quot;&gt;&amp;quot;Maximum lock count exceeded&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                setState(nextc); &lt;span class=&quot;comment&quot;&gt;// 重点：更新state变量值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;经过这么一轮debug，可以观察到原来&lt;code&gt;lock.lock()&lt;/code&gt; 通过cas更改state变量值来实现“可重入性”，例如，这里for循环5次使得该线程在同一锁对象上加锁了5次，可以看到对应的state累加计数等于5，基于此可以推出&lt;code&gt;lock.unlock()&lt;/code&gt;操作则是每次&lt;code&gt;unlock()&lt;/code&gt;就是对state进行cas减1操作，如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度讨论jdk1.7的ConcurrentHashMap设计及其核心方法实现</title>
    <link href="https://yield-bytes.github.io/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yield-bytes.github.io/2021/04/18/Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%AE%A8%E8%AE%BAjdk1.7%E7%9A%84ConcurrentHashMap%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-17T16:00:00.000Z</published>
    <updated>2022-05-09T13:48:35.840Z</updated>
    
    <content type="html"><![CDATA[<p>阅读本文前，需要部分JDK源码深度知识储备：Unsafe与CAS原理、jdk1.7的HashMap原理设计以及分析过其源代码</p><p><img src="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>《gitee 博客封面图》</p><h4 id="1、为何引入ConcurrentHashMap这种适应并发场景数据结构？"><a href="#1、为何引入ConcurrentHashMap这种适应并发场景数据结构？" class="headerlink" title="1、为何引入ConcurrentHashMap这种适应并发场景数据结构？"></a>1、为何引入ConcurrentHashMap这种适应并发场景数据结构？</h4><ul><li>HashTable</li></ul><p>从Java7和Java8的HashMap源码设计可以得出基本结论：两者都不是线程安全，如果非得在并发情况下使用它们，会出现一些问题，如Java7的HashMap死循环导致CPU利用率飙高、put/get不一致问题等，当然也有绝对线程安全的HashTable，但从其源码实现来看，HashTable简单粗暴地在put/get/size等方法前加一个<code>synchronized</code> 修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//...</span></span></span><br></pre></td></tr></table></figure><p>在并发操作HashTable的线程数量不多的场景下，其性能影响不大，而且线程隔离程度最高（保证线程安全）；但在高并发场景下，HashTable的性能显得力不从心，考察以下情况：</p><p>例如有1000个线程对HashTable（数组长度为1024）进行读写操作，由于synchronized是对整个数组进行加锁，只要有一个线程在数组的某个桶位上进行put/get等操作，其他999个线程都会被阻塞无法做其他事情，就连读操作也会被阻塞而不能并发读。</p><a id="more"></a><ul><li>Collections.synchronizedMap(map)</li></ul><p>此方法也能实现线程安全：用它可以将非线程安全版本的HashMap“包装”为线程安全的HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; map=Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer,String&gt;());</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>其内部实现方式，如外界不指定加锁对象，那么它会对“当前SynchronizedMap对象的引用”加锁，然后再套用HashMap的方法即可完成线程安全的设计，简单、粗暴、直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.m = m; <span class="comment">// </span></span><br><span class="line">      mutex = <span class="keyword">this</span>;<span class="comment">// 当前SynchronizedMap对象的引用,后面的get、put会对其加锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HashTable是在方法前面加synchronized修饰</span></span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Collections.unmodifiableMap(map)</li></ul><p>当然也还有一个冷门的unmodifiableMap类支持多线程并发的读的场景，但不支持并发写，因为unmodifiableMap类是只读的map，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">Map&lt;Integer, String&gt; map1 = Collections.unmodifiableMap(map);</span><br><span class="line">map1.put(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>); <span class="comment">// 抛出UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p>查看unmodifiableMap源码即可了解其设计思想：对“写入操作”相关方法改造为抛出异常，从而实现将可读写的map“包装”成只读map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>此外unmodifiableMap类业务场景受限，它不支持并发写入等复杂操作的场景。</p><p>以上三种map虽然都是线程安全map，但它们在高并发场景下，读写（当然unmodifiableMap不支持写入操作）性能低，因此有必要介绍能支持高并发的HashMap，也即ConcurrentHashMap简称CHM，当然本文特指jdk1.7版本的CHM。</p><h4 id="2、ConcurrentHashMap双层结构图及其基本术语"><a href="#2、ConcurrentHashMap双层结构图及其基本术语" class="headerlink" title="2、ConcurrentHashMap双层结构图及其基本术语"></a>2、ConcurrentHashMap双层结构图及其基本术语</h4><p><img src="https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>从图中可以看出，ConcurrentHashMap具有两层结构：Segment数组+HashEntry数组</p><ul><li>第一层结构：是一个Segment数组，该数组每个元素都是一个Segment对象，Segment对象是什么？首先它是ConcurrentHashMap的一个内部“辅佐类”，本质是一个锁对象，继承了ReentrantLock，只不过在ReentrantLock基础上增加各种功能，Segment定义源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">        Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的“分段锁”、“锁分段”说的就是Segment数组里每个元素（每个桶位）都是一个锁，换句话说：Segment数组的每个桶位都持有一个锁，都可以独立加锁和解锁，桶位之间的读写操作互不影响，这种直接继承ReentrantLock来封装成为新的“工具”的设计思想确实巧妙。</p><ul><li>第二层结构：从Segment类的定义可以看出，每个Segment对象又包含了一个HashEntry数组，它才是键值对或者冲突链真正存放的地方，显然这一层结构就是大家所熟悉的Java7 HashMap结构。在Segment对象内部，对HashEntry数组的并发写操作采用CAS无锁原子操作机制，并发读操作使用volatile和Unsafe机制实现。</li></ul><p>这里还是以前面第1节的案例说明：</p><blockquote><p>例如有1000个线程对ConcurrentHashMap（数组长度为1024）进行(key,value)读写操作，假设1000个线程能够均匀分别1000个不同Segment数组桶位上，由于Segment数组每个桶位都是一把锁，每个线程对自己桶位进行加锁后独立进行读写操作，完全不会阻塞其他桶位上的线程操作，因此1000个线程可以同一时刻并发执行读写，整个ConcurrentHashMap的操作效率大增。</p></blockquote><h4 id="3、重点成员变量以及构造方法"><a href="#3、重点成员变量以及构造方法" class="headerlink" title="3、重点成员变量以及构造方法"></a>3、重点成员变量以及构造方法</h4><p>从最熟悉的用法put开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>通常是以该类的重点成员变量以及最多参数那个构造方法作为分析切入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一层结构Segment数组的默认初始容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//第二层结构里面HashMap的负载因子，注意：这里不是Segment数组的负载因子，Segment数组没有扩容机制，初始化设定多少就是多少（原因看后面的源码分析），因此不需要LOAD_FACTOR</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 写并发度，也即允许同时操作多少个线程来操作该Segment数组，数组的一个桶位对应一个写操作并发度，读并发度不限制</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 第二层结构里面HashMap的最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 第二层结构里面HashMap的初始默认容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一层结构Segment数组的最大容量65536，Doug Lea自己也认为该最值设定有点保守，因为同一台服务器，cpu、内存等配置不同，同时开启的线程数量也不同，性能好的服务器，同时打开10万个线程也不成问题</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; <span class="comment">// slightly conservative</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment">     * methods before resorting to locking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 在计算size时，加阻塞锁的最大尝试次数，后面的size方法会提到。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应第一层结构的Segment数组，注意这里是final修饰，也再次能说明：Segment数组一旦创建，以后就不能修改和扩容了</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="comment">// 如果给定的并发度例如10万，显然大于默认Segment数组的长度，只能取到65536，</span></span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">  <span class="comment">// 用于算出给定相关参数下的最佳Segment数组容量，2的n次幂，以下以默认构造方法的入参作为说明，因此给定initialCapacity=16作为实例说明，其他参数loadFactor=0.75，concurrencyLevel=16。</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>; <span class="comment">// ssize变量就是创建Segment数组的容量值</span></span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">          <span class="comment">// 找出大于等于并发度的2整数幂值，因为concurrencyLevel默认为16，因此经过以下简单计算，sshift=4，ssize=16</span></span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// segmentShift=32-4=28，用于计算key的hash值，采用这种方式能够使得key分布更加离散</span></span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">      <span class="comment">// segmentMask=16-1=15&lt;==&gt;1111,使用二进制能够快速计算定位到key对应的桶位号，这个知识点已经在jdk1.8HashMap解析的文章详细解析过。</span></span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize; <span class="comment">// 由于initialCapacity=16， ssize=16，那么c计算为1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 由于c*ssize=1*16恰好能满足c * ssize&gt;=initialCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity) </span><br><span class="line">            ++c; <span class="comment">// 此时c=1</span></span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">//默认创建HashEntry[]的容量，值为2</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c) <span class="comment">//  由于c=1,显然这里cap不再调整，cap还是取默认值MIN_SEGMENT_TABLE_CAPACITY=2</span></span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">      <span class="comment">// 创建第0个segment对象，用于未来其他线程创建新segment对象时以s0作为模板去“克隆创建”</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]); <span class="comment">// 从上面可知，这里cap就是2，因此位于s0位置的HashEntry数组长度为2</span></span><br><span class="line">        <span class="comment">// 创建一个容量为ssize的segments数组</span></span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        <span class="comment">// 数组的segments[0]=s0 </span></span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss; <span class="comment">// segments数组内部变量名</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该构造方法有以下几个重要细节：</p><ul><li><p>1、Segment数组是在new ConcurrentHashMap&lt;&gt;()时创建的，默认容量为16，同时会在Segment数组的第0个桶位上创建一个Segment对象，赋给变量s0，而Segment数组其他1~15的位置则为null，也即惰性创建，在以后有新的key put进来时再到相应的下标创建新的Segment。此外，在Segment数组第0号下标也创建好一个默认容量为2的HashEntry数组。</p></li><li><p>2、这里使用<code>UNSAFE.putOrderedObject(ss, SBASE, s0)</code> ，为何不使用 putObjectVolatile()方法？</p></li></ul><blockquote><p>首先putOrderedObject()是有序、延迟版本的 putObjectVolatile方法，用它写入值不会立即被其他线程获取到，这样做的好处是写入性能比 putObjectVolatile() 高，</p></blockquote><ul><li>3、如何理解“这样做的好处是写入性能比 putObjectVolatile() 高？</li></ul><blockquote><p>首先，假设在new构造方法阶段和put阶段，采用putObjectVolatile()，那么s0会马上写入主存，由于new阶段之后紧接着put操作，而put方法里有相关操作也涉及到立即写入主存的需求，如果这些写入操作都直接使用putObjectVolatile，那么相当于主存与cpu缓存之间来回跑了几次，其实完全可以这么设计：“从new到put方法的finally之前，积攒多个写入操作后再一次性写入主存”</p><p>Doug Lea就是这么干的：在new构造方法开始使用putOrderedObject，让s0变量写入主存的时间延迟到<code>put</code>方法的结尾前，也即在finally的unclock执行前，就能实现“积攒多个写入操作后一次性写入主存”，因此写入性能有提高的，而且保证的数据一致性。</p><p>注意：JMM规定，对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p><p>参考：<a href="https://www.zhihu.com/question/60888757">https://www.zhihu.com/question/60888757</a></p></blockquote><h4 id="4-put方法解析"><a href="#4-put方法解析" class="headerlink" title="4 put方法解析"></a>4 put方法解析</h4><p>基于ConcurrentHashMap两层结构可知，要put一个key进去，需要两次hash定位，第一次定位在Segment数组对应的Segment上，第二次定位：在第一次定位的基础上，确定key位于HashEntry数组的哪个桶位上，显然，第二次定位才是key真正要put的位置，由于是多线程并发put，因此代码设计相对复杂：</p><p>第一次定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="comment">// 这里可以看出ConcurrentHashMap不允许放入null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="comment">// 对比HashMap的index=hashCode&amp;table.length-1的桶位计算即可知道，j就是确定key所在的Segment数据下标位置</span></span><br><span class="line">  <span class="comment">// 第一次定位，也即找出key所在的Segment数组的下标位置，这里的hash右移了segmentShift位，目的是让key的高位特征参与桶位计算，使得hash进一步分散</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 投机写法：若当前还未有其他线程写入，那么可以使用getObject快速获取segment实例</span></span><br><span class="line">  <span class="comment">// 如果key对应的Segment对象恰好为null，说明还未创建Segment对象，因此需要在ensureSegment方法内部创建key对应的Segment对象，具体逻辑参考ensureSegment方法的解析</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck in ensureSegment</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) </span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">  <span class="comment">// 真正将键值对put入HashEntry数组</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次定位 <code>s.put(key, hash, value, false)</code>  </p><p>该put方法是Segment对象自己的内部方法，其内部设计也很巧妙，这里给出其总体设计思想：</p><p>1、此put方法是真正将key放入HashEntry数组的逻辑，那么当前线程必须要获得锁才能保证独占put</p><p>2、使用非租塞方式自旋方式获取锁，但不会让当前线程白白浪费自旋，因此在自旋期间给当前线程安排了任务（对应下面的scanAndLockForPut方法）</p><p>3、任务是：麻烦你（当前线程）在自旋的过程中，顺便帮我检查key是否存在链表中，如果不存在，顺便帮我提前创建key对应的Entry节点，以便我获取锁后可以马上使用。（对应下面的HashEntry<K,V> node = tryLock() ? null :scanAndLockForPut(key, hash, value);）</p><p>4、拿到锁后，即可在HashEntry数组上找到合适位置并插入新key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应上面的 s.put(key, hash, value, false)调用       </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//由于segment对象自己就是一个ReentrantLock，因此当然有tryLock()加锁方法，所以在这里先尝试第一次加锁</span></span><br><span class="line"><span class="comment">// 若第一次加锁成功，则node没机会提前被创建，因此对应为null。若第一次加锁失败（说明有其他线程竞争并抢占成功），当前线程会在scanAndLockForPut里面尝试加锁且顺便提前为key创建好对应的node节点。 </span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :scanAndLockForPut(key, hash, value);</span><br><span class="line">  <span class="comment">// ===========================加锁成功（进入临界区）===========================</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 这一句代码非常能体现作者对并发性能的理解是有多细腻！参考后面解释</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">              <span class="comment">// 使用Volatile语义获取key对应的桶位头节点，也即冲突链的头结点，用于下面遍历</span></span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">              <span class="comment">// 以下内容其实在HashMap解析中已经讲过，逻辑不难</span></span><br><span class="line">             <span class="comment">// 从冲突链的头节点开始遍历，在合适位置插入key，若key已经在链表中存在，则更新其value</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                  <span class="comment">//冲突链的头节点不为空，则进入链表遍历，若在链中找到对应key，则结束遍历。</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                              <span class="comment">// 更新value后，ConcurrentMap结构修改次数加1</span></span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">// 用于保持链表的遍历</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 程序运行到该分支，说明key所在的桶位头节点是null</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 若上面的自旋加锁期间顺便把key对应的node节点创建好，那么就直接使用头插法将此node插入桶位上</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 若上面 的tryLock() ? 没有机会提前将key对应的node节点创建好，在这里也可以为该key创建节点，显然是用头插法</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">// HashEntry容量统计加1</span></span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 添加新节点后，若HashEntry数组容量达到扩容阈值，则进行扩容rehash</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意，这里是在HashEntry数组的index桶位创建key对应的node节点，也是用了延迟写入主存的策略（putOrderedObject）：</span></span><br><span class="line"><span class="comment">setEntryAt(tab,i,e) </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            put方法在代码开始位置就获得了锁，那么key写入后，自然需要释放锁，注意这里需联系前面构造方法里面的</span></span><br><span class="line"><span class="comment">            UNSAFE.putOrderedObject(ss, SBASE, s0)使用延迟写入主存的原因</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                unlock();<span class="comment">// 执行unlock之前，jvm能把之前每个调用putOrderedObject的写入操作在此刻全部一起写入到主存</span></span><br><span class="line">  <span class="comment">// ===========================成功释放锁（离开临界区）===========================</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在put方法的前面，Dung Lea安排了<code>HashEntry&lt;K,V&gt;[] tab = table</code>，将原本volatile修饰的table变量转为普通变量，</p><p>这是因为：在这一句之前，当前线程已经通过tryLock获取了独占锁，因此只会有一个线程对table进行写操作，既然如此，那就不必再使用volatile语义的table变量，将table赋值给put方法中的一个局部变量，从而使得能够减少volatile带来的不必要性能损耗。</p><h5 id="ensureSegment方法解析"><a href="#ensureSegment方法解析" class="headerlink" title="ensureSegment方法解析"></a>ensureSegment方法解析</h5><p>该方法的解析主要是来自前面put方面里面的<code>s = ensureSegment(j)，主要设计思想：</code></p><p>1、先投机性去主存Segment数组j下标取segment对象，若该位置对应的Segment对象不为空，则直接返回它，</p><p>2、若在1步骤发现j位置下Segment为null，那么当前线程准备把它创建了，创建方式当然基于自旋+CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法里面的初始化的Segment数组</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">  <span class="comment">// key定位到j下标对应的相对地址，注意j下标和u的不同</span></span><br><span class="line">  <span class="comment">// int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span></span><br><span class="line">  <span class="comment">// s = ensureSegment(j);</span></span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">  <span class="comment">//到这这一步,可能出现多线程并发创建Segment，因此使用Volatile语义判断Segment数组j下标是否已经创建Segment实例以及该Segment对应的hashEntry数组</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若当前j下标元素为空，用Segment数组的第0号桶位上的segment实例作为模板为桶位j创建segment实例</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]; </span><br><span class="line">   <span class="comment">// 再次检查当前j下标是否有其他线程创建了segment实例，若没有创建，就使用自旋+CAS方式来创建，这时一定原子操作，而且仅有一个线程会创建segment成功</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">          <span class="comment">// 自旋检查j下标位置是否有其他线程创建了segment实例，若自旋中恰好发现还未创建segment实例，则使用CAS原子操作创建</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                  <span class="comment">// 若当前线程创建segment实例成果，则退出自旋</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者这样考虑ensureSegment的设计：考察多个线程一起调用ensureSegment情况，其实只要其中一个线程抢先在j位置创Segment对象，那么其他线程只需要判断该位置不为空时就不用重复在j位置创建segment实例，直接 return seg即可。</p><p>再使用并发思维理解以下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line"><span class="comment">// 自旋检查j下标位置是否有其他线程创建了segment实例</span></span><br><span class="line"> <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">        == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">       <span class="comment">// 若当前线程能成功创建segment实例，则退出自旋</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>考察A、B两个线程同时执行到上面compareAndSwapObject，由于原子性操作，因此可保证只有A线程（假设A线程先抢到）去操作CAS且返回true，B线程去<code>UNSAFE.compareAndSwapObject(ss, u, null, seg = s)</code> 就会返回false，此时的u位置不再是null而是A线程已写入的segment实例，线程B在while循环发现seg已不为空，所以B线程不会再重复创建segment对象。</p><h5 id="scanAndLockForPut解析1"><a href="#scanAndLockForPut解析1" class="headerlink" title="scanAndLockForPut解析1"></a>scanAndLockForPut解析1</h5><p>put方法里面，因为要写入key，线程对当前segment写入操作前，当然需要先获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :scanAndLockForPut(key, hash, value);</span><br><span class="line">V oldValue;</span><br></pre></td></tr></table></figure><p>为了能够通俗理解<code>scanAndLockForPut</code>逻辑设计，这先给出ReentrantLock阻塞锁和非阻塞锁的对比，因此这一节称为<code>scanAndLockForPut解析1</code>，真正的源码解析安排下一节：<code>scanAndLockForPut解析2</code></p><ul><li>阻塞锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock Lock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Lock.unlock();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A在工作时，线程B被阻塞了，啥事都做不了</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程B在运行中&quot;</span>);</span><br><span class="line">            Lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的运行结果来看：线程A在工作时，线程B被阻塞了，而且被阻塞了5秒。在5秒里，线程B啥事都做不了，线程B明明也可以干活，但却被阻塞，这种并发设计未能充分利用cpu。</p><ul><li>非租塞锁</li></ul><p>如果使用非阻塞锁，那么线程A在工作时，线程B不会被阻塞，线程B可以自由做其他事情，没有白白自旋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> ReentrantLock Lock= <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A在运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);<span class="comment">// 让线程A先运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程A在工作时，使用tryLock非阻塞锁，这样线程B不会被线程A阻塞，线程A工作的同时，线程B同时也可以去干点别的事情</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (!Lock.tryLock())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B在工作中，对链表扫描是否存在key节点&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                Lock.unlock();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A在运行中</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br><span class="line">线程B在工作中，对链表扫描是否存在key节点</span><br></pre></td></tr></table></figure><p>使用trylock非阻塞锁后，在这5秒时间内线程B没有白白浪费CPU资源，它顺便完成了查询key节点的工作，对比scanAndLockForPut的<code>while (!tryLock())</code>，即可理解其设计思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123; <span class="comment">// 若当前线程抢锁失败后不会白白浪费自旋cpu资源，而是顺便完成链表的遍历以及新key节点的创建</span></span><br><span class="line"> <span class="comment">// ......         </span></span><br><span class="line">         node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// ...... </span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在<code>scanAndLockForPut</code> 内部使用非阻塞锁，也不会阻塞读线程在桶位的并发读，一石二鸟！</p><h5 id="scanAndLockForPut解析2"><a href="#scanAndLockForPut解析2" class="headerlink" title="scanAndLockForPut解析2"></a>scanAndLockForPut解析2</h5><p>完整逻辑分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取key定位在HashEntry数组的桶位头节点</span></span><br><span class="line">          HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">          HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">          <span class="comment">// 该节点就是线程自旋抢锁过程中“顺便”把key节点提前创建好</span></span><br><span class="line">          HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 记录自旋次数</span></span><br><span class="line">          <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">          <span class="comment">// 自旋尝试抢锁（加锁）</span></span><br><span class="line">          <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">              <span class="comment">// 以下的执行流都是基于“未拿到锁的条件下”进行的</span></span><br><span class="line">              HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">          <span class="comment">// 分支1：把能做的事情先做好了：创建了一个新的node节点，但还没获取到锁，只能继续循环</span></span><br><span class="line">              <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前key定位到的桶位为空</span></span><br><span class="line">                  <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                          node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 将retries置为0：是为了下一次循环跳到分支2或者分支3处理逻辑 </span></span><br><span class="line">                      retries = <span class="number">0</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"><span class="comment">//如果给定的key能在链表中找到，就不需要new一个node节点，继续while去获取锁</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                      retries = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">else</span> </span><br><span class="line">                  <span class="comment">//   如果给定的key不是头节点key，说明要继续遍历该链表</span></span><br><span class="line">                      e = e.next;</span><br><span class="line">              &#125; <span class="comment">// 分支2：如果自旋获取锁的尝试大于64次，此时调用独占锁（阻塞锁），保证当前线程一定能获取到锁</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                  lock();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;<span class="comment">// 分支3：注意，此分支还未加锁，因此多个线程可能并发执行以下逻辑，如果获取锁的尝试次数未超默认值，在1~64次重试过程中，每达到偶数次：(retries &amp; 1) == 0，当前线程就去检查头节点是否发生了改变，如果头结点发生改变，说明有其他线程已经抢先将某个新节点放入链表头位置，因此当前线程只能重新实施while (!tryLock())。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                  e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                <span class="comment">// 重置尝试次数</span></span><br><span class="line">                  retries = -<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里有一个细节需要注意：代码最后部分“关于重试次数为偶数时就去判断当前桶位的头结点有无变化”，作者设计是基于这么思考：其实无需遍历64次，因为“安排当前线程在自旋过程中顺便去创建node节点”这个任务可要也可不要，如果在头节点恰好在奇数次例如（第3次）发生改变，那么在偶数次（第4次及其以后）就会错过判断，怎么办？ 从代码逻辑可以看出，retries次数达到64后，就会直接加阻塞锁成功，然后退出自旋，那么node节点将会在scanAndLockForPut外部被创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!tryLock())&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">           lock();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">//  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doug Lea设计的scanAndLockForPut确实精妙，拿捏得死死的！（ 让线程没有”空跑、摸鱼”的余地）</p><h4 id="5、size方法"><a href="#5、size方法" class="headerlink" title="5、size方法"></a>5、size方法</h4><p>先理解主要设计设计思想：</p><p>1、从ConcurrentHashMap的两层结构可知：将每个segment段的HashEntry数组节点数进行累加即可得到总数，在多线程场景下，可以这样设计：先锁住所有segment段，累加后再解锁所有segment段。但这样设计有一个问题：直接加锁后，会阻塞其他线程对当前Segment段的并发写，有一丁点性能损耗。</p><p>2、基于1的优化：先“投机性赌一把”，赌遍历时没有其他线程来更新该map，那么当前线程可以先不加锁尝试3次遍历累计所有segment的更改次数（modCounts），如果相邻两次更改次数一样，说明这两次统计过程中没有其他线程来更新该map，赌成功了，此时size的计算结果相对很准确。（后面会解释为何是相对很准确，而不是100%准确）</p><p>如果相邻两次更改次数不一样，说明这两次统计过程中有其他线程来（put/remove/clear）该map，赌失败了，下一次尝试统计就需要对所有segment段加锁再统计size</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 先尝试几次不加锁情况下的统计，如果统计失败，说明有持续的并发线程来更改HashEntry数组， resort to直译是使用(武力)，在这里则表示使用”暴力“的阻塞锁</span></span><br><span class="line">       <span class="comment">// 作者英文注释，简单明了解释了size方法设计思想:Try a few times to get accurate count. On failure due to continuous async changes in table, resort to locking.</span></span><br><span class="line">       <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">       <span class="keyword">int</span> size;</span><br><span class="line">     <span class="comment">// 统计size是否有溢出32位最大值</span></span><br><span class="line">       <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">     <span class="comment">// sum 和last 用于比较相邻两次的map修改数</span></span><br><span class="line">       <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">       <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">       <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="comment">// 如果无锁情况下，统计尝试次数达到3次（从-1到1），则对所有segment段都加锁</span></span><br><span class="line">               <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                       ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">               &#125;</span><br><span class="line">               sum = <span class="number">0L</span>;</span><br><span class="line">               size = <span class="number">0</span>;</span><br><span class="line">               overflow = <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">// 遍历所有segment并累计modCount，以及累计所有segment的HashEntry的节个数c</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                   Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                   <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       sum += seg.modCount;</span><br><span class="line">                       <span class="keyword">int</span> c = seg.count;</span><br><span class="line">ß                     <span class="comment">// 判断累计的节个数c是否有溢出</span></span><br><span class="line">                       <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                           overflow = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">// 相邻两次modCount总修改数相等，说明当前没有其他线程来（put/remove/clear）map结构，可以结束统计</span></span><br><span class="line">               <span class="keyword">if</span> (sum == last)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               last = sum;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 前面加锁统计完size后，这里就需要释放锁</span></span><br><span class="line">           <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                   segmentAt(segments, j).unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// size溢出则返回Integer.MAX_VALUE，否则返回实际统计的size值</span></span><br><span class="line">       <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从finally的逻辑可以看出，size结果是相对很准确，而不是100%准确，因为它在逐个释放锁的过程中，有可能其他线程正在对“已释放锁的Segment”进行写操作（put/remove）。</p><h4 id="6、rehash方法"><a href="#6、rehash方法" class="headerlink" title="6、rehash方法"></a>6、rehash方法</h4><p>rehash方法是Segment内部类方法，因此所谓的ConcurrentHashMap扩容，也是只是委托了对应的Segment段里面的HashEntry数组扩容，而不是Segment数组扩容！需要留意的是，rehash在put方法内部调用，执行rehash方法时，当前线程已经获得阻塞锁，因此可以独立扩容处理。</p><p>此外，java7的ConcurrentHashMap的原表节点转移到新表的设计跟java7的HashMap有点不一样</p><p>java7的HashMap扩容设计相对简单：针对冲突链的处理，将低位节点和高位节点区分开，分别放在新表的i位置、oldTab.length+i位置</p><p>而java7的ConcurrentHashMap的扩展设计：针对冲突链的处理，将“在新数组桶位相同的连续子链”和其他剩余节点区分开，然后两者放到新表对应位置。</p><p><font color=red> 新数组桶位相同的连续子链是指 ：子链尾节点必须是该父链尾节点，此子链才能定义为”连续子类“，所以19-&gt;35-&gt;51不是rehash定义的“连续子链”</font>， 参考后面的图示。</p><p>这里找子链的方法其实也不难，在一些leecode算法题例如在长字符串找一个“字符连续相同的子串”（abaaaab=&gt;aaaa）、在链表里找一个子链等。</p><p>以下准备了两张图解用于解释其扩容过程，基本约定：</p><p>1、hash计算约定：假设使用简单hash方法，也即hash（数字）=数字本身，桶位计算方式：j=hash&amp;oldTab.length-1</p><p>2、原数组长度为8，扩容阈值=8*0.75=6，链表已经达到6个节点，因此该桶位链表需要扩容，新表容量为16</p><p>3、在原数组桶位i=3位置上，形成冲突链，给定两种假设：</p><p>A、桶位含有“在新数组桶位相同的连续子链”的链表：3-&gt;11-&gt;19-&gt;35-&gt;51-&gt;67-&gt;null，如下图所示</p><p>（图中也清楚展示了“低位节点”和“高位节点”的情况，关于什么是低位和高位节点，只要有看过本博客关于HashMap的深度文章解析，这些是基本常识，这里不再累赘）<br><img src="https://img-blog.csdnimg.cn/3238fd00eb9a4704a77076200e1f9df6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="“桶位有连续子链”对应的扩容过程图解："><a href="#“桶位有连续子链”对应的扩容过程图解：" class="headerlink" title="“桶位有连续子链”对应的扩容过程图解："></a>“桶位有连续子链”对应的扩容过程图解：</h5><p><img src="https://img-blog.csdnimg.cn/198b28346f38434b879c3bfc4c67b771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>B、桶位不含有“子链”的链表：3-&gt;11-&gt;19-&gt;35-&gt;51-&gt;27-&gt;null，如下图所示</p><p>图中也清楚展示了“低位节点”和“高位节点”的情况</p><p><img src="https://img-blog.csdnimg.cn/afab5722a7e149bd89688b03bb7a10cf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="“桶位无连续子链”对应的扩容过程下面图解："><a href="#“桶位无连续子链”对应的扩容过程下面图解：" class="headerlink" title="“桶位无连续子链”对应的扩容过程下面图解："></a>“桶位无连续子链”对应的扩容过程下面图解：</h5><p><img src="https://img-blog.csdnimg.cn/e0247aaaadae4453a0e2da4cb18c117f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="rehash源码详细解析"><a href="#rehash源码详细解析" class="headerlink" title="rehash源码详细解析"></a>rehash源码详细解析</h5><p>基于以上四张图，再理解rehash源码设计思路则会简单很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 以下的原数组和新数组分别指代同一个segment段下，原HashEntry数组和新HashEntry数组</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">          <span class="comment">// 新数组容量=2倍原数组容量</span></span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 新数组的扩容阈值</span></span><br><span class="line">            threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// new一个新数组    </span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =(HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            </span><br><span class="line"> <span class="comment">// 使用位方式计算节点在新数组的桶位，在jdk1.8的HashMap源码解析中，已经对这部分知识讲得非常清楚，这里不再赘述</span></span><br><span class="line">            <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 遍历原数组每个桶位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">             <span class="comment">// 若原数组i桶位头节点不为空，且next节点为null，说明该桶位仅有一个头节点，计算出该节点在新数组的idx位置后，头插法：newTable[idx] = e</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line"><span class="comment">//  若原数组i桶位头节点不为空，且next节点不为空，说明该桶位是一条冲突链，它的扩容处理比较复杂，可结合上面的图解内容进行综合分析</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="keyword">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                          <span class="comment">// 计算当前遍历节点在新数组桶位号</span></span><br><span class="line">                            <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                          </span><br><span class="line"><span class="comment">// 如果前一个节点在新数组桶位号和后一个节点在新数组桶位号相同，说明找到“连续的、新表桶位相同的子链”(对应图解里面图4的情况)，将lastRun指向该子链头节点，对应图中节点11。</span></span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//                       </span></span><br><span class="line">                        newTable[lastIdx] = lastRun;<span class="comment">// lastRun指向的子链整体迁移</span></span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<span class="comment">// 迁移其他非lastRun节点</span></span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                            <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n); <span class="comment">// 注意这里是用旧桶位节点的key和value来创建新节点，因此原桶位节点不会有任何改动，也说明rehash的同时也支持并发读</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 完成扩容后，对rehash(node)里面的新节点node放入到新newTable里面</span></span><br><span class="line">            <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里用putOrderedObject添加新节点到新数组里面，也是将其写入主存的操作延迟到外部方法put的finally的unlock位置，目的还是为减少频繁的“线程工作内存&lt;--&gt;主存”之间“来回跑”，等”凑齐“多个延迟写入的操作，然后在unlock前一并写入主存，提高put性能，作者对put性能提高的设计确定足够细腻！！！</span></span><br><span class="line"><span class="comment">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</span></span><br><span class="line"><span class="comment">            UNSAFE.putOrderedObject(this, nextOffset, n);</span></span><br><span class="line"><span class="comment">        &#125;  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable; <span class="comment">// 将table引用指向newTable，原table指向的对象将会被GC</span></span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7、其他方法"><a href="#7、其他方法" class="headerlink" title="7、其他方法"></a>7、其他方法</h4><p>这里需要强调的是，前面第4到6节核心方法的设计及其源码都能理解的话，那么关于jdk1.7的ConcurrentHashMap其他方法的理解则变得相对简单很多</p><h5 id="get方法："><a href="#get方法：" class="headerlink" title="get方法："></a>get方法：</h5><p>两次定位，第一次定位到key对应segment位置，第二次定位到对应的HashEntry数组位置</p><p>两次定位都使用UNSAFE.getObjectVolatile方法实现，使用无锁实现高效率并发读，这也证明了读操作是并发的，不受写操作、独占锁影响，而且基于 happen-before</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">  <span class="comment">// key对应的segment和HashEntry数组都在的情况下</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 定位HashEntry数组的对应桶位，然后再桶位上查找是否key这个节点</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">          <span class="comment">// 找到则返回值</span></span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 找不到key，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>首先remove方法设计相对简单，它是委托key所在的Segment段实施的，因此不会影响其他Segment段的并发读写操作。</p><p>可以看出，remove属于写操作，跟put方法一样，首先需要获取独占锁。</p><p>remove两次hash定位和get方法一样，第一次先定位（路由、查找）到对应的Segment段，第二次定位HashEntry数组的桶位，remove方法内部内部封装了Segment的remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// map.remove(&quot;foo&quot;)  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">       <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Segment段内部remove方法设计：</p><p>设计说明</p><p>A、remove头节点情况：例如需要移除3-&gt;7-&gt;11-&gt;15-&gt;null的头节点3</p><p>e=3,next=7-&gt;11-&gt;15-&gt;null，</p><p>因此只需将节点7插入原桶位头节点即可：<code>setEntryAt(tab, index, next)</code>，而且使用<code>UNSAFE.putOrderedObject</code>方式，不急着写入到主存，等到finally的unlock前才一并写入主存。</p><p>B、remove非头结点情况：例如需要移除3-&gt;7-&gt;11-&gt;15-&gt;null的节点7</p><p>pred=3,e=7,next=11-&gt;15-&gt;null</p><p>只需将节点3的next指向节点11即可：pred.setNext(next)，也是使用UNSAFE.putOrderedObject方法，不急着写入到主存，等到finally的unlock前才一并写入主存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先获取独占锁，跟scanAndLockForPut方法类似，但更简单，少了创建Node节点的任务。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    <span class="comment">//====tryLock加锁成功，进入临界区====    </span></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">      <span class="comment">// 定位key所在的桶位</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，找出链表中与给定key相同的节点</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                  <span class="comment">// 对应A情况</span></span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="comment">// 对应B情况</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                  <span class="comment">// 删除一个节点，map结构变化次数加1，节点数量当然需要减1</span></span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//====释放锁，离开临界区====    </span></span><br><span class="line">       <span class="comment">// 释放独占锁， 前面所有使用UNSAFE.putOrderedObject的逻辑，将在这里一并写入到主存中</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace方法类似，此处不再累赘。</p><h5 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a>isEmpty方法</h5><p>第一次遍历所有Segment，对每个Segment的modCount进行累加：sum += seg.modCount，而且在遍历过程中，只要出现Segment对应的HashEntry数组长度不为0时，即可直接返回结果，不需再遍历剩余的Segment。</p><p>第二次遍历所有Segment，如果Segment里面的HashEntry数组长度为0，则进行操作：sum -= seg.modCount</p><p>设计思路：</p><ul><li><p>要证明ConcurrentHashMap为空，那么以上两次操作后，sum变量必须为0，表示两次统计modCount没有发生变化且为0次ModCount。</p></li><li><p>要证明ConcurrentHashMap不为空，那么在第二次遍历所有Segment，只要出现任意一个Segment的的HashEntry数据长度不为0，即可证明当前ConcurrentHashMap不为空</p></li></ul><p>以上就是isEmpty的设计思想，当然遍历数组Segment过程中访问Segment段还是会使用<code>UNSAFE.getObjectVolatile(ss, u)</code>方式来取。</p><p>为何不用map.size()==0来判断是否为空？</p><p>对比size方法计算流程和isEmpty计算流程可以得出答案，isEmpty代码简洁且效率会快一些，因为isEmpty在遍历过程出现一个Segment的HashEntry数组长度不为0即可返回结果，而size方法要计算所有Segment且需要计算两次（运气不好时还需要加锁计算）才能得出结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">   <span class="comment">// 对应第一次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 只要有其中一个Segment的HashEntry数组长度不为0，即可返回结果：不空</span></span><br><span class="line">            <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 对应第二次遍历的情况</span></span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 只要有其中一个Segment的HashEntry数组长度不为0，即可返回结果：不空</span></span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum -= seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8、关键总结"><a href="#8、关键总结" class="headerlink" title="8、关键总结"></a>8、关键总结</h4><p><code>HashEntry</code>的成员变量<code>value</code>和<code>next</code>是被关键字<code>volatile</code>修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因而可以在不加锁的情况下读取到这两个引用的最新值</p><h5 id="8-1-ConcurrentHashMap与HashMap不同点对比"><a href="#8-1-ConcurrentHashMap与HashMap不同点对比" class="headerlink" title="8.1 ConcurrentHashMap与HashMap不同点对比"></a>8.1 ConcurrentHashMap与HashMap不同点对比</h5><ul><li><p>最简单区别当然线程安全：ConcurrentHashMap写操作：put/remove/replace都是需要加锁（scanAndLockForPut、scanAndLock）</p></li><li><p>HashMap允许Key和Value为null，而ConcurrentHashMap不允许key、value为空，参考8.5解释</p></li><li><p>HashMap不允许通过Iterator遍历的同时通过HashMap修改（强一致性要求），而ConcurrentHashMap允许该行为（本质原因CHM是弱一致性），并且该更新对后续的遍历可见，参考8.6</p></li></ul><h5 id="8-2-ConcurrentHashMap的并发度问题"><a href="#8-2-ConcurrentHashMap的并发度问题" class="headerlink" title="8.2 ConcurrentHashMap的并发度问题"></a>8.2 ConcurrentHashMap的并发度问题</h5><p> ConcurrentHashMap的并发度concurrencyLevel在new 构造方法就已经固定（默认并发度16个线程），例如一开始给定Segment数组是128，那么并发度最多128线程同时写操作，但对于读操作，则不限制，可以是128也可以10000等不同数量线程并发读。</p><p>此提问可衍生另外一个知识点：</p><p>如果ConrruentHashMap需要扩容，通过第6节的rehash方法可知，它是委托key所在的Segment段去扩容该段里面的HashEntry数组，而不是对Segment数组本身扩容，对于这个问题，如果不了解ConrruentHashMap，应该也会惯性思维认为：“扩容时，Segment数组也会被扩容”这样的错误理解。</p><p>由于Segment数组初始化就限制了并发度，因此需要你提前根据业务场景设定号并发度值，这也算是jdk1.7 ConrruentHashMap需要优化的地方。</p><h5 id="8-3-ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴"><a href="#8-3-ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴" class="headerlink" title="8.3 ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴"></a>8.3 ConcurrentHashMap分段锁的巧妙设计思想是值得借鉴</h5><p>尤其在一些计高并发计数场景，例如jdk1.8的LongAdder、jdk1.8 ConcurrentHashMap里面的fullAddCount方法，但jdk1.8的思路更优，采用分段无锁方式，比Segment分段锁lock更高性能。</p><h5 id="8-4-ConcurrentHashMap有可能退化成SynchronizedMap"><a href="#8-4-ConcurrentHashMap有可能退化成SynchronizedMap" class="headerlink" title="8.4 ConcurrentHashMap有可能退化成SynchronizedMap"></a>8.4 ConcurrentHashMap有可能退化成SynchronizedMap</h5><p>假设有些业务的key不够合理，绝大部分的key都hash到同一个segment段，那么容易导致多个线程仅在这个Segment段进行写操作，退化成SynchronizedMap，这个段就是全局锁，这也是jdk1.7 ConrruentHashMap需要优化的地方。</p><h5 id="8-5-关于ConcurrentHashMap的key和value都不能为空的讨论"><a href="#8-5-关于ConcurrentHashMap的key和value都不能为空的讨论" class="headerlink" title="8.5 关于ConcurrentHashMap的key和value都不能为空的讨论"></a>8.5 关于ConcurrentHashMap的key和value都不能为空的讨论</h5><ul><li>ConcurrentHashMap的value不能为空的原因</li></ul><p>考察HashMap：在单线程操作的HashMap场景下，value可以放入null值，当使用get方法返回的值是null时，这个“null”存在二义性：要么key对应的value为null，要么key不在map里面，那么怎么唯一区分呢？很简单，只需结合containsKey方法就可以唯一确定取出的null是属于哪种情况，演示逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程能顺序执行以下所有逻辑</span></span><br><span class="line"><span class="comment">// 如果map包含该key，那么get返回的null是属于“key存在且对应的value为null”的情况</span></span><br><span class="line"><span class="comment">// 否则抛出key不存在的提示，这时就可以知道get返回的null是属于“key存不在map里面”的情况</span></span><br><span class="line"><span class="keyword">if</span> (m.containsKey(k)) &#123;</span><br><span class="line">   <span class="keyword">return</span> m.get(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotPresentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上的知识铺垫，下面我们再通过反证法来论证ConcurrentHashMap的value不能真实原因</p><p>在并发场景下 ，若将ConcurrentHashMap的value可以设为null，当使用get方法返回的值是null时，存在二义性：要么key对应的value为null，要么key不在map里面，考察使用containsKey方法来区分，参考图解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.containsKey(k)) &#123;</span><br><span class="line">   <span class="keyword">return</span> m.get(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> KeyNotPresentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/749bdcdee5ce43819369aec363bf8703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这张图很好解释了ConcurrentHashMap的value不能设为空的原因，并发条件下，执行m.containsKey(k)和m.get(k)之间会有其他线程“捣乱流程”：</p><blockquote><p>线程A 执行m.containsKey(k)后返回true，线程A此时认为key存在map中，正准执行m.get前，线程B提前删除该key，接着线程A使用m.get得到的是null，然后线程A很自信得出“key是存在，只是value对应为null”的结论，而实际上呢，该key已经被线程B删除，实际情况为key不存在map中，ConcurrentHashMap这就是无法解决的二义性。</p></blockquote><ul><li>至于ConcurrentHashMap的key不能为空的依据：</li></ul><p>1、纯粹是基于Java关于null是否符合“程序优雅设计与否”的经验知识，其实Doug Lea认为map中允许键值为null是一种不合理的设计，HashMap虽然可以判断二义性，但是Doug Lea仍然觉得这样设计是不合理的。在java项目中，如果key为null通常意味着有些地方已经有出错的苗头，所以早点抛异常比允许null key更合适。</p><p>2、允许key为null另外一个不够优雅地方就是不方便遍历哈希表，尤其对于ConcurrentMap。</p><p>3、基于以上背景，Doug Lea在源码hash计算方法设计上就不支持key为null的处理，若为null，那么使用k.hashCode()抛出NPE，可以参考hash(key)方法。</p><h5 id="8-5-Fast-fail产生原因"><a href="#8-5-Fast-fail产生原因" class="headerlink" title="8.5 Fast-fail产生原因"></a>8.5 Fast-fail产生原因</h5><p><a href="http://www.jasongj.com/java/concurrenthashmap/">http://www.jasongj.com/java/concurrenthashmap/</a></p><p>在使用迭代器的过程中如果HashMap被修改，那么<code>ConcurrentModificationException</code>将被抛出，也即Fast-fail策略。</p><p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">  expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">  Entry[] t = table;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出<code>ConcurrentModificationException</code>。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。</p><h5 id="8-6-ConcurrentHashMap高并发读为什么可以无锁？"><a href="#8-6-ConcurrentHashMap高并发读为什么可以无锁？" class="headerlink" title="8.6 ConcurrentHashMap高并发读为什么可以无锁？"></a>8.6 ConcurrentHashMap高并发读为什么可以无锁？</h5><p>首先：JMM实现了对volatile的保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</p><p>HashEntry定义中使用volatile修饰value、next字段，恰恰能享受到以上JMM所提及volatile两点收益：</p><p>1、volatile语义可以保证写操作在读操作之前（写操作happens-before于读操作），也即保证了写操作对后续的读操作都是可见的</p><p>2、其次在写入操作的时候使用`UNSAFE.putOrderedObjectE写入主存的时机延迟到put方法的unlock前，保证了数据的一致性。</p><p>有了以上两个机制后，那么使用 UNSAFE.getObjectVolatile即可支持并发无锁读</p><h5 id="8-8-为何HashEntry节点类型设置为final"><a href="#8-8-为何HashEntry节点类型设置为final" class="headerlink" title="8.8 为何HashEntry节点类型设置为final"></a>8.8 为何HashEntry节点类型设置为final</h5><p>首先ConcurrentHashMap的HashEntry为final类型（一旦创建就成为不可变类），而HashMap的Entry节点是非final类型，ConcurrentHashMap为何这么设计？</p><p>要回答这一问题，其实需要理解final有什么用？jvm会对final定义的变量做怎样的处理？<a href="https://www.infoq.cn/article/java-memory-model-6/">具体解释可参考此文章</a></p><p>简单来说：</p><p>1、对于使用final修饰的对象，java编译器会保证在读final域之前一定被写入过，即保证写在读之前发生，避免多线程并发条件下出现读后写，读到非预期的值。</p><p>ok，按这样的思路去解释HashEntry类：java编译器会保证在读HashEntry节点域里面的属性如key、value之前，一定会保证key、value先被写入后再来读，避免并发情况下出现“读后写，读到非预期的值”，也即保证线程安全。</p><p>2、对比volatile，final不需要额外的线程本地内存和主存之间的同步开销。</p><h5 id="8-7-HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？"><a href="#8-7-HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？" class="headerlink" title="8.7 HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？"></a>8.7 HashMap在第一次put时才完成初始化，那么ConcurrentHashMap在什么时机开始初始化？</h5><p>ConcurrentHashMap的初始化在new 构造方法时就已经完成部分初始化，完成Segment数组创建、第0号位的Segment对象创建以及在其里面的HashEntry容量2的创建，因此，它的初始化可不是在第一次put才初始化</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阅读本文前，需要部分JDK源码深度知识储备：Unsafe与CAS原理、jdk1.7的HashMap原理设计以及分析过其源代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/b127d7c290df4cc1b6ae2242f91614cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客封面图》&lt;/p&gt;
&lt;h4 id=&quot;1、为何引入ConcurrentHashMap这种适应并发场景数据结构？&quot;&gt;&lt;a href=&quot;#1、为何引入ConcurrentHashMap这种适应并发场景数据结构？&quot; class=&quot;headerlink&quot; title=&quot;1、为何引入ConcurrentHashMap这种适应并发场景数据结构？&quot;&gt;&lt;/a&gt;1、为何引入ConcurrentHashMap这种适应并发场景数据结构？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;HashTable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从Java7和Java8的HashMap源码设计可以得出基本结论：两者都不是线程安全，如果非得在并发情况下使用它们，会出现一些问题，如Java7的HashMap死循环导致CPU利用率飙高、put/get不一致问题等，当然也有绝对线程安全的HashTable，但从其源码实现来看，HashTable简单粗暴地在put/get/size等方法前加一个&lt;code&gt;synchronized&lt;/code&gt; 修饰：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object key)&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key, V value)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在并发操作HashTable的线程数量不多的场景下，其性能影响不大，而且线程隔离程度最高（保证线程安全）；但在高并发场景下，HashTable的性能显得力不从心，考察以下情况：&lt;/p&gt;
&lt;p&gt;例如有1000个线程对HashTable（数组长度为1024）进行读写操作，由于synchronized是对整个数组进行加锁，只要有一个线程在数组的某个桶位上进行put/get等操作，其他999个线程都会被阻塞无法做其他事情，就连读操作也会被阻塞而不能并发读。&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://yield-bytes.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java高级主题：深度解析jdk1.8的HashMap红黑树balanceDeletion节点删除平衡算法设计（核心文章）</title>
    <link href="https://yield-bytes.github.io/2021/03/13/Java%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90jdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91balanceDeletion%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%A0%B8%E5%BF%83%E6%96%87%E7%AB%A0%EF%BC%89/"/>
    <id>https://yield-bytes.github.io/2021/03/13/Java%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90jdk1.8%E7%9A%84HashMap%E7%BA%A2%E9%BB%91%E6%A0%91balanceDeletion%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%A0%B8%E5%BF%83%E6%96%87%E7%AB%A0%EF%BC%89/</id>
    <published>2021-03-12T16:00:00.000Z</published>
    <updated>2022-05-09T13:40:55.133Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是全网最期待的jdk1.8的红黑树balanceDeletion的源代码解析技术文章！</p><p>其实掌握HashMap红黑树的同学都知道，<code>balanceDeletion</code>方法的源代码是HashMap红黑树部分最复杂也是最难理解的部分，目前少有coder对<code>balanceDeletion</code>有足够深入且可理解的分析，绝大部分关于深入HashMap分析的文章都会跳过<code>balanceDeletion</code>源代码，有部分文章的coder他并不直接给出<code>balanceDeletion</code>的源代码解析，而是自行实现非HashMap的“红黑树删除平衡”代码，<a href="https://mp.weixin.qq.com/s/9ysi_wrjhmm2czTOui3SyA">如链接</a>，但显然不能跟jdk源码高质量功能相比（HashMap源码里面的<code>removeTreeNode</code>和<code>balanceDeletion</code>的代码设计是最完整的），因此要想真正掌握完整jdk级别的HashMap红黑树的balanceDeletion逻辑，那么源代码解析肯定要搬出来。</p><p>目前个人认可的文章是<a href="https://blog.csdn.net/anlian523/article/details/103649200#comments_14954397">这篇文章</a>，个人也给它留了评论和鼓励（该博客作者能深钻JUC源代码实现），但也发现该文在解析<code>balanceDeletion</code>源码、图示（少部分）不够直观、简约、清晰，因此亲自实现一篇相对高质量且尽量可理解的<code>removeTreeNode</code>和<code>balanceDeletion</code>源代码分析，本文不会跟类似文章图或者文章组织或者思路重复。</p><p><img src="https://img-blog.csdnimg.cn/82cde64db30a44919c1675305adc8605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>《gitee 博客文章封面》</p><a id="more"></a><h3 id="1、removeNode"><a href="#1、removeNode" class="headerlink" title="1、removeNode"></a>1、removeNode</h3><p>remove方法删除逻辑由内部的removeNode方法代理，如果能找到key对应的删除节点，那么removeNode返回这个节点的value，否则返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是removeNode源码说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 显然如果table还未有节点或者key定位到桶位节点p为空，就返回null，否则进入主体逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">      <span class="comment">//① 桶位节点p恰好就是要删除的节点，先不执行删除，而是将p节点赋给node引用，统一在后面处理</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">      <span class="comment">//② 桶位节点p不是目标删除节点，那么就只能从链表找到目标删除节点或者从红黑树找到目标删除节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//③ 若桶位节点p是红黑树节点类型，则从红黑树找到目标删除节点。由getTreeNode负责找出目标删除节点，找到就赋给node引用</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">          <span class="comment">//④ 若桶位节点p是链表头节点，遍历链表找到目标删除节点，找到就赋给node引用</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对找到的目标删除节点node进行处理，分节点类型情况处理，这里首先需要判断value有无设定约束删除条件，即“key相等且value不等才可删除”或者“key相等且value也相等才可删除”</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//1、如果目标删除节点node是TreeNode类型，则调用removeTreeNode删除之，此方法是本文的核心和（特指内部的balanceDeletion）难点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//2、如果目标删除节点node是桶位头节点，直接用删除节点的后继节点放在桶位即可。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">          <span class="comment">//3、如果目标删除节点node在链表上，也即：p-&gt;node&gt;node.next，将其改为p-&gt;node.next即可完成node节点的删除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">          <span class="comment">// 删除节点属于改变HashMap结构的情况，当然需要计数 </span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到removeNode内部逻辑清晰易懂，而最关键最难的逻辑是红黑树的删除节点逻辑（特指内部的balanceDeletion逻辑）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br></pre></td></tr></table></figure><p>node是通过<code>((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key)</code> 在红黑树中找到的目标删除节点，removeTreeNode方法中入参this也就是指代这个node节点本身，具体分析见后面章节。</p><h3 id="2、removeTreeNode（难点）"><a href="#2、removeTreeNode（难点）" class="headerlink" title="2、removeTreeNode（难点）"></a>2、removeTreeNode（难点）</h3><p>removeTreeNode方法的官方注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by &quot;next&quot; pointers that are accessible independently during traversal. So instead we swap the tree linkages. If the current tree appears to have too few nodes, the bin is converted back to a plain bin. (The test triggers somewhere between 2 and 6 nodes, depending on tree structure).</span><br></pre></td></tr></table></figure><p>node with a leaf successor: 当前节点有后继节点</p><p>在理解以下复杂且难以理解的删除逻辑前，首先要记着红黑树是“具有两种数据结构”特征的，因为对于TreeNode类来说，</p><font color=red>TreeNode的parent、left、right、red属性构成红黑树结构，而TreeNode的prev、next属性构成双向链表结构，因此在删除一个指定节点node时，即要在“双向链表结构”中删除这个node，也要在“红黑树结构”删除这个node，这样才能正确的实现“红黑树已删除该node节点”的逻辑，理解这一点很重要 。HashMap的红黑树结构不像其他普通的二叉树设计，而普通版本的二叉树删除节点只需在树中删除该节点即可，因为普通的二叉树节点并没有prev和next属性，因此也无“双向链表”这一说。</font><h4 id="2-1-removeTreeNode（前部分逻辑）"><a href="#2-1-removeTreeNode（前部分逻辑）" class="headerlink" title="2.1 removeTreeNode（前部分逻辑）"></a>2.1 removeTreeNode（前部分逻辑）</h4><p>removeTreeNode主体逻辑分为两部分，第一部分：</p><p>1、在TreeNode构成的双向链表中删除node节点，这部分逻辑相对简单，调整前后驱关系即可完成</p><p>2、在TreeNode构成的红黑树中删除node节点，这部分逻辑设计最为复杂也是最难理解的，需要分开多个情况处理：</p><ul><li>2.1在TreeNode构成的红黑树中删除node节点过程，如果红黑树本身节点就很少（2到6个），注意：此时不需要再附加”删除节点操作“，因为在1中的双向链表已经删除了节点，到了这里，只需将这个“小树”调整为链表即可。</li></ul><p>以上逻辑被归到<font color=red>removeTreeNode（前部分逻辑）</font>，下面是属于第二部分：</p><ul><li>2.2 在TreeNode构成的红黑树中删除node节点过程，如果红黑树本身节点多，那么其节点删除的方式其实就是通过调整树代际关系实现删除，并在此之后实施红黑树删除平衡逻辑。</li></ul><p>第二部分部分的源代码设计参考<font color=red>removeTreeNode（后部分逻辑）</font>章节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span></span><br><span class="line"><span class="comment"> 这个node是从红黑树找出的符合删除条件的节点，然后调用其内部removeTreeNode方法</span></span><br><span class="line"><span class="comment"> 以下的当前节点指代this节点，也指代调用removeTreeNode方法的这个“node”节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//removeTreeNode（前部分逻辑）</span></span><br><span class="line">    <span class="comment">//① 如果tab都为空，也即无节点可删除，直接返回即可</span></span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 当前节点所在的桶位</span></span><br><span class="line">          <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 先取出index桶位的头节点first，同时first节点也是红黑树的root根节点，因此也有root=first,rl是root节点的左子节点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于调用removeTreeNode的节点就是一个TreeNode，因此其next节点就是后继节点赋给succ变量，prev节点为前驱节点赋给pred变量</span></span><br><span class="line">          TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 如果当前节点node的前驱节点为空,说明前节点node就位于桶位头节点上，因为要删除当前节点node，故只需将将first指向succ，并将当前节点node的后继节点succ放入桶位上，就可完成“删除当前节点node”的操作</span></span><br><span class="line">    <span class="comment">//  node(头节点) &lt;=&gt; succ &lt;=&gt; succ.next  变成 succ(头节点) &lt;=&gt; succ.next</span></span><br><span class="line">          <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">              tab[index] = first = succ;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          <span class="comment">/* 如果前驱节点不为空，说明当前要删除的node位于双向链表的其他位置，使用链表删除节点的方式即可完成对node节点的删除，如下： </span></span><br><span class="line"><span class="comment">          &lt;=&gt;符号:  前后指向关系已经建立</span></span><br><span class="line"><span class="comment">          -&gt; 符号:  前驱节点指向后面节点关系建立了，还差后面节点指向前驱节点的关系</span></span><br><span class="line"><span class="comment">           将 pred&lt;=&gt; node &lt;=&gt; succ &lt;=&gt; succ.next 变成 pred -&gt; succ &lt;=&gt; succ.next</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">              pred.next = succ;</span><br><span class="line">    <span class="comment">// 如果后驱节点不为空，因为那么需要将后继节点的前驱指针指向前一个节点，以保证形成双向链关系。</span></span><br><span class="line">    <span class="comment">// 例如将pred -&gt; succ &lt;=&gt; succ.next 变成 pred &lt;=&gt; succ &lt;=&gt; succ.next，这里pred节点可以是null也可以是非null</span></span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">          <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">              succ.prev = pred;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前面可知tab[index] = first = succ，如果first为空，也即succ为空，说明本次删除节点已经完成，对于这种情况，删除当前节点node，其实tab[index]=null，也即该桶位为空了，就不需要做删除之后的平衡操作或者树转链表从中，可直接返回。</span></span><br><span class="line">          <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⑤ 代码执行到这里，说明first节点不为空，由前面root=first有：先判断root节点是否为树的根节点，如果root不是根节点，就调用内部root()找到真正的红黑树根节点</span></span><br><span class="line">          <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">              root = root.root();</span><br><span class="line">    <span class="comment">// ⑥ 在前面的②和③中所要删除的节点已经在双向链表中删除了，因此当遇到红黑树结构节点很少时，直接将该树转成链表即可，不需要再实施树平衡操作。</span></span><br><span class="line">          <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">              || (movable</span><br><span class="line">                  &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                      || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                      || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">              tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>针对第⑥点的分析：TreeNode构成的红黑树中删除node节点过程，如果红黑树本身节点就很少（2到6个），注意：此时不需要再附加”删除节点操作“，因为在1中的双向链表已经删除了节点，到了这里，只需将这个“小树”调整为链表即可。</p><p>节点数量不多的红黑树具有的特征：</p><p>1、只有一个root节点，且空节点</p><p>2、root.right == null，说明只有一个左子节点，因此从红黑树性质可知：此时树只有两个节点：根节点root（黑色）、左子节点（红色）</p><p>3、若root.right == null不成立，则来到条件：(rl = root.left) == null，它成立说明左子节点为空，且只有一个右子节点，由于红黑树性质可推导出：此时树只有两个节点：根节点root（黑色）、右子节点（红色）</p><p>4、若root.right == null不成立，(rl = root.left) == null不成立，也即根节点有左右子节点，则来到条件rl.left == null，它成立则说明此时红黑树也是一棵简单的红黑树且构成有多种形式，但红黑树约束性质可知：基本对应到有2到6个节点，可以通过枚举法画出2到6个节点对应的红黑树结构，这里不再一一列举。</p><p>这里也顺便解释了源码官方注释为何提到2到6个节点对应的红黑树就是一棵“tree appears to have too few nodes”的实际情况：</p><blockquote><p>If the current tree appears to have too few nodes, the bin is converted back to a plain bin. (The test triggers somewhere between 2 and 6 nodes, depending on tree structure).</p></blockquote><h4 id="2-2-removeTreeNode（后部分逻辑）"><a href="#2-2-removeTreeNode（后部分逻辑）" class="headerlink" title="2.2 removeTreeNode（后部分逻辑）"></a>2.2 removeTreeNode（后部分逻辑）</h4><p>红黑树节点超过6个对应的删除逻辑（难点）</p><p>若目标删除节点为p，删除它前，需要考察以下三种情况（注意：以下均不考虑删除平衡调整的内容，此部分放在后面一章）：</p><p>1、p恰好无左、右子节点，这种情况简单，直接删除</p><p>2、p仅有一个子节点（左子节点或者右子节点），那么可用子节点替换p节点，符合“独子继承”的观念</p><p>注意这里左子节点可能是p节点一个子节点也可能是p节点的左子树，右子节点同理。</p><p>3、p有两个子节点，这种情况最复杂，需要找到p的后继节点或者p的前驱节点来替换p，而不是简单的用p的左子节点或用p的右子节点替换p。p的后继节点或者p的前驱节点如何找出来？（Doug Lea在源代码中选中使用p的后继节点）</p><blockquote><p>首先HashMap的红黑树节点是符合二叉查找树值的排序规则，即：</p><ul><li>若任意节点左子树不为空，它的左子树上所有节点值均小于等于它的根节点的值</li><li>若任意节点的右子树不为空，它的右子树上所有节点的值均大于等于它的根节点的值</li></ul><p>根据以上特点，要删除p节点就等价于用左子树中的最大节点或者右子树中的最小节点来替换p节点。</p><p>也即：</p><p>p的前继节点是指：p的左子树中的最大节点</p><p>p的后继节点是指：p的右子树中的最小节点</p></blockquote><p>本节内容根据removeTreeNode方法（后部分）的源代码逻辑安排以下分析框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="comment">// p的左子节点pl、右子节点pr均不为空的条件下，对p和s做位置交换以及关系调整、候选节点replacement的选取</span></span><br><span class="line"><span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line"><span class="comment">// p仅有左子节点pl的条件下，此时无需后继节点s作为辅助处理，只需完成候选节点replacement的选取</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">  replacement = pl;</span><br><span class="line"><span class="comment">// 代码片段3，与代码片段2对称</span></span><br><span class="line"><span class="comment">// p仅有右子节点pr的条件下，此时无需后继节点s作为辅助处理，只需完成候选节点replacement的选取</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">  replacement = pr;</span><br><span class="line"><span class="comment">// 代码片段4</span></span><br><span class="line"><span class="comment">// p无左和右子节点，此时无需后继节点s作为辅助处理，只需完成候选节点replacement的选取</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   replacement = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段5</span></span><br><span class="line"><span class="keyword">if</span> (replacement != p)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码片段6</span></span><br><span class="line">TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段7</span></span><br><span class="line"><span class="keyword">if</span> (replacement == p)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码片段8</span></span><br><span class="line"><span class="keyword">if</span> (movable)&#123;</span><br><span class="line">  moveRootToFront(tab, r)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>具体分析过程如下：</p><font color=red>这里必须记着一个贯穿全文策略：p来到后继节点s的位置后，要删除p节点，就等效于将p节点的候选节点replacement放到p位置，然后再将p的三个指针设为null。此外针对“单纯的删除节点操作”，以下图示不需要给出颜色标记，因为还到执行到进行删除平衡操作的逻辑</font><h5 id="代码片段1"><a href="#代码片段1" class="headerlink" title="代码片段1"></a>代码片段1</h5><p>p的左子节点pl、右子节点pr均不为空的条件下，对p和s做位置交换以及关系调整、候选节点replacement的选取，该处理逻辑相对复杂，因此给出对应的图示辅助大家理解其设计意图：<br><img src="https://img-blog.csdnimg.cn/d977342630a84d148cf01ce0f6a4afea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h5 id="代码片段2"><a href="#代码片段2" class="headerlink" title="代码片段2"></a>代码片段2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//2.1 如果p节点仅有一个左子节点pl，那么左子节点pl就是作为替代父节点p的候选节点，逻辑无需图示。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">          replacement = pl;</span><br></pre></td></tr></table></figure><h5 id="代码片段3"><a href="#代码片段3" class="headerlink" title="代码片段3"></a>代码片段3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 3.1 如果p节点仅有一个右子节点pr，那么右子节点pr就是作为替代父节点p的候选节点，逻辑无需图示。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">          replacement = pr;</span><br></pre></td></tr></table></figure><h5 id="代码片段4"><a href="#代码片段4" class="headerlink" title="代码片段4"></a>代码片段4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.1 如果p节点没有左、右子节点，此情况的处理相对简单，那么先将replacement指向p节点本身，方便后面删除操作，逻辑无需图示。         </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">           replacement = p;</span><br></pre></td></tr></table></figure><h5 id="代码片段5-7"><a href="#代码片段5-7" class="headerlink" title="代码片段5~7"></a>代码片段5~7</h5><p>后面这三个代码片段逻辑相对复杂，也给出对应的图示说明：<br><img src="https://img-blog.csdnimg.cn/b6acaff5f34a4a758e2fef4692d8a706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="代码片段8"><a href="#代码片段8" class="headerlink" title="代码片段8"></a>代码片段8</h5><p>在上面的代码片段6，若p节点为黑色节点，p删除后，必然引起所在子树少了1个黑色节点，导致红黑树黑高不平衡，需要做平衡调整。做完红黑树结构的平衡调整后，还需要保证桶位上头节点<code>table[i]</code>即是红黑树根节点，也是双向链表的头节点，因此还需在双向链表结构这一侧执行moveRootToFront操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//  movable默认设为true</span></span><br><span class="line"><span class="keyword">if</span> (movable)</span><br><span class="line">           moveRootToFront(tab, r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上分析完成removeTreeNode方法的整体设计解析，虽然有一定难度，但好在其调整思路比较明确，因此根据图解分析也能很好掌握其设计，而最复杂的部分当然是下面的balanceDeletion操作！</p><h3 id="3、balanceDeletion删除平衡调整"><a href="#3、balanceDeletion删除平衡调整" class="headerlink" title="3、balanceDeletion删除平衡调整"></a>3、balanceDeletion删除平衡调整</h3><p>首先一定要清楚balanceDeletion被调用的代码上下文环境：红黑树节点超过6个的情况下，删除了一个黑色的p节点，候选节点replacement顶替p节点，接下来做树平衡调整，首先认识两种“基于红色节点”的调整策略：</p><h4 id="红色节点对树平衡的贡献1"><a href="#红色节点对树平衡的贡献1" class="headerlink" title="红色节点对树平衡的贡献1"></a>红色节点对树平衡的贡献1</h4><p>如图3-1，pl的兄弟节点那一侧有红色节点，经过变色和左旋后，使得左子树增加了1个黑色节点，正好使得左右子树的黑色节点数量同为N，完成平衡调整。</p><p>注意是一个非常有启发意义的调整算法：</p><font color=red>左子树的新黑色节点是右子树“补充”过来的，也即通过“左旋”将一个节点“补充”到左子树中，这是因为利用的右子树“多出1个”红色节点调整而来。我们知道红黑树的红色节点不计入黑高平衡约束，但在关键时刻我们可以将它变为黑色节点补充到缺少节点的一方，从而实现当前左右子树黑高平衡。这就是balanceDeletion的核心设计思路，理解这一点才能真正掌握红黑树的删除平衡设计逻辑。</font><p><img src="https://img-blog.csdnimg.cn/img_convert/09c7bbc67a79735f706e9dec7e7088ec.png" alt="balDel_1"></p><p>图中的N（或者N-1）标记是指当前节点到叶子节点路径所包含的黑色节点数量，便于随时观察每个小图中黑高平衡动态变化的过程。</p><h4 id="红色节点对树平衡的贡献2"><a href="#红色节点对树平衡的贡献2" class="headerlink" title="红色节点对树平衡的贡献2"></a>红色节点对树平衡的贡献2</h4><p>图3-4到6再次展示“红色节点对调整树平衡所起的关键作用”，这也是balanceDeletion用的调整算法之一，显然这是最简单的方式。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f6fd3581249efa0e3be797a2483ea6e.png" alt="balDel_2"></p><h4 id="核心代码分析"><a href="#核心代码分析" class="headerlink" title="核心代码分析"></a>核心代码分析</h4><h5 id="代码主要框架"><a href="#代码主要框架" class="headerlink" title="代码主要框架"></a>代码主要框架</h5><p>首先其主体代码框架主要分为5部分，对应5个条件，其中第5部分的逻辑是第4部分逻辑的对称实现。如果想掌握balanceDeletion的代码实现（可能需要多次研究本文），你会发现，Doug Lea 的思路就是在第4部分经过各种调整后，让执行流来到第1或者第2或者第3部分的“循环出口”逻辑，从而结束删除平衡调整，可见第4部分的调整算法是最关键的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        x.red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (x.red)&#123;</span><br><span class="line">        x.red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x)&#123;</span><br><span class="line">      <span class="comment">//......（核心逻辑也是最难的逻辑）</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 5 此部分逻辑和4的逻辑是对称的</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">// symmetric</span></span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="源码解析1"><a href="#源码解析1" class="headerlink" title="源码解析1"></a>源码解析1</h5><p>前面3部分源码说明，此部分的代码作用是用于循环出口，也分别称为循环出口1、循环出口2、循环出口3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement),这里的x节点就是replacement节点</span></span><br><span class="line">      <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">              <span class="comment">// 1、循环出口1</span></span><br><span class="line">              <span class="comment">// (1)这里是for循环的出口之一，情况4.3.2调整完后会走这个出口。</span></span><br><span class="line">              <span class="comment">// (2)当然候选节点replacement本身就是root节点，那么也不需要平衡调整，返回根节点即可。</span></span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              <span class="comment">// 2、循环出口2</span></span><br><span class="line">              <span class="comment">// (1)这里是for循环的出口之一,表示：经过多次平衡调整后，当前调整节点x的父节点为空时，说明此时调整来到根节点位置，也即x就是根节点，直接将其变黑色即可结束调整。</span></span><br><span class="line">              <span class="comment">// (2)当然此情况也可能出现在首次循环时即满足该分支条件。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> x;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 3、非循环出口，适用最简单的调整情况。代码执行到这里，说明候选节点x的位置不是在树根位置，如果候选节点x为红色，因为删除的p是黑色，x放在p位置后，只需将x设为黑色，即可补回“刚刚被删除的黑节点p”，显然马上达到平衡，返回root节点即可。参考上面的“红色节点对树平衡的贡献2”图示。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                  x.red = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> root;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><h5 id="源码解析2"><a href="#源码解析2" class="headerlink" title="源码解析2"></a>源码解析2</h5><p>第4部分的逻辑是balanceDeletion最复杂也是最精华的设计，如果执行流能走到第4部分，说明候选节点x是黑色节点，并针对x位于xp左或者右子节点位置进行删除平衡调整。本章选择从x位于xp左子节点位置前置条件进行分析，而右边是对称情况，本章不再给出说明，调整算法也主要分为以下4种情况：</p><ul><li>4.1 候选节点x有兄弟节点xpr，且xpr为红色节点</li><li>4.2 候选节点x没有兄弟节点xpr</li><li>4.3.1 候选节点x有兄弟节点xpr，xpr为黑色节点，且xpr仅有黑色子节点或者都为空子节点（包含两个黑色子节点或者其中一个子节点为黑色）</li><li>4.3.2 候选节点x有兄弟节点xpr，xpr为黑色节点，且xpr存在红色子节点（包含两个红色子节点或者其中一个为红色子节点），xp节点是红色或者黑色都适用，对应图示给出这两种情况的调整过程。</li></ul><p>进一步解释：</p><ul><li>4.1的情况经过调整后，会变成4.3.1情况或者4.3.2情况，如果转为4.3.1情况，则走循环出口2结束；如果转为4.3.2情况，则走循环出口1结束。</li><li>4.2的情况最终可能走循环出口1或者循环出口2</li><li>4.3.1的情况最终走循环出口2结束。</li><li>4.3.2的情况，最终走循环出口1结束。</li></ul><p>关于4.1、4.2、4.3.1情况的源代码分析如下：</p><p>对比<a href="https://blog.csdn.net/anlian523/article/details/103649200#comments_14954397">该文</a>你会发现，它是从x位于右子树方向着手分析，而本文则按照“coder阅读代码思路（从上到下）”，源代码是从x位于左子树位置开始，因此本文也从“x在左”作为分析入口。此外，需要点赞这篇文章的一个地方——作者在结构图中的节点旁边标注黑高N，这一点对阅读者是非常友好和易于理解的，因此本文也采用了在节点旁边标注黑高，方便观察调整后黑高动态变化过程，以及两边黑高平衡情况。而其他内容包括作图等细节则无需参考该文，否则文章就没有异于他人、独立的、相对好理解的内容。</p><p><img src="https://img-blog.csdnimg.cn/8918d35c61bb4db1be89f87467528faf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>关于4.3.2情况的源代码分析如下：<br><img src="https://img-blog.csdnimg.cn/82cde64db30a44919c1675305adc8605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>要想写出如此精密、严谨的红黑树结构删除节点的调整逻辑确实不容易，看看jdk1.8源代码文件HashMap文件的作者，尤其是前两位。（HashMap红黑树removTreeNode和balanceDeletion的源代码非常值得多次研究或者复现）</p><blockquote><p>Since:1.2<br>Author:<br>Doug Lea, Josh Bloch, Arthur van Hoff, Neal Gafter</p></blockquote><p>这里也提供另外一个解析balanceDeletion很好的思路：使用逆向思维去考察。既然左旋是将一个黑色节点“补充到”x左子树这边，那么不妨从这个新补充的黑色节点开始逆向推导，这样你自然会思考左旋前，x节点的兄弟这一边树结构满足什么条件才能创造“左旋”的机会。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这可能是全网最期待的jdk1.8的红黑树balanceDeletion的源代码解析技术文章！&lt;/p&gt;
&lt;p&gt;其实掌握HashMap红黑树的同学都知道，&lt;code&gt;balanceDeletion&lt;/code&gt;方法的源代码是HashMap红黑树部分最复杂也是最难理解的部分，目前少有coder对&lt;code&gt;balanceDeletion&lt;/code&gt;有足够深入且可理解的分析，绝大部分关于深入HashMap分析的文章都会跳过&lt;code&gt;balanceDeletion&lt;/code&gt;源代码，有部分文章的coder他并不直接给出&lt;code&gt;balanceDeletion&lt;/code&gt;的源代码解析，而是自行实现非HashMap的“红黑树删除平衡”代码，&lt;a href=&quot;https://mp.weixin.qq.com/s/9ysi_wrjhmm2czTOui3SyA&quot;&gt;如链接&lt;/a&gt;，但显然不能跟jdk源码高质量功能相比（HashMap源码里面的&lt;code&gt;removeTreeNode&lt;/code&gt;和&lt;code&gt;balanceDeletion&lt;/code&gt;的代码设计是最完整的），因此要想真正掌握完整jdk级别的HashMap红黑树的balanceDeletion逻辑，那么源代码解析肯定要搬出来。&lt;/p&gt;
&lt;p&gt;目前个人认可的文章是&lt;a href=&quot;https://blog.csdn.net/anlian523/article/details/103649200#comments_14954397&quot;&gt;这篇文章&lt;/a&gt;，个人也给它留了评论和鼓励（该博客作者能深钻JUC源代码实现），但也发现该文在解析&lt;code&gt;balanceDeletion&lt;/code&gt;源码、图示（少部分）不够直观、简约、清晰，因此亲自实现一篇相对高质量且尽量可理解的&lt;code&gt;removeTreeNode&lt;/code&gt;和&lt;code&gt;balanceDeletion&lt;/code&gt;源代码分析，本文不会跟类似文章图或者文章组织或者思路重复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/82cde64db30a44919c1675305adc8605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B5c2Vuc2U=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;《gitee 博客文章封面》&lt;/p&gt;</summary>
    
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/categories/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="Java高级主题" scheme="https://yield-bytes.github.io/tags/Java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
